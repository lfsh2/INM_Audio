(function () {
  const e = document.createElement('link').relList;
  if (e && e.supports && e.supports('modulepreload')) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === 'childList')
        for (const a of o.addedNodes) a.tagName === 'LINK' && a.rel === 'modulepreload' && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (o.credentials = 'include')
        : i.crossOrigin === 'anonymous'
        ? (o.credentials = 'omit')
        : (o.credentials = 'same-origin'),
      o
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = t(i);
    fetch(i.href, o);
  }
})();
function R1(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, 'default') ? r.default : r;
}
var Xv = { exports: {} },
  Vd = {},
  Jv = { exports: {} },
  An = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cx;
function b1() {
  if (cx) return An;
  cx = 1;
  var r = Symbol.for('react.element'),
    e = Symbol.for('react.portal'),
    t = Symbol.for('react.fragment'),
    n = Symbol.for('react.strict_mode'),
    i = Symbol.for('react.profiler'),
    o = Symbol.for('react.provider'),
    a = Symbol.for('react.context'),
    u = Symbol.for('react.forward_ref'),
    d = Symbol.for('react.suspense'),
    h = Symbol.for('react.memo'),
    m = Symbol.for('react.lazy'),
    g = Symbol.iterator;
  function v(Y) {
    return Y === null || typeof Y != 'object'
      ? null
      : ((Y = (g && Y[g]) || Y['@@iterator']), typeof Y == 'function' ? Y : null);
  }
  var x = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    A = Object.assign,
    C = {};
  function E(Y, ue, He) {
    (this.props = Y), (this.context = ue), (this.refs = C), (this.updater = He || x);
  }
  (E.prototype.isReactComponent = {}),
    (E.prototype.setState = function (Y, ue) {
      if (typeof Y != 'object' && typeof Y != 'function' && Y != null)
        throw Error(
          'setState(...): takes an object of state variables to update or a function which returns an object of state variables.',
        );
      this.updater.enqueueSetState(this, Y, ue, 'setState');
    }),
    (E.prototype.forceUpdate = function (Y) {
      this.updater.enqueueForceUpdate(this, Y, 'forceUpdate');
    });
  function S() {}
  S.prototype = E.prototype;
  function b(Y, ue, He) {
    (this.props = Y), (this.context = ue), (this.refs = C), (this.updater = He || x);
  }
  var I = (b.prototype = new S());
  (I.constructor = b), A(I, E.prototype), (I.isPureReactComponent = !0);
  var B = Array.isArray,
    z = Object.prototype.hasOwnProperty,
    N = { current: null },
    G = { key: !0, ref: !0, __self: !0, __source: !0 };
  function k(Y, ue, He) {
    var ge,
      De = {},
      Ie = null,
      Ue = null;
    if (ue != null)
      for (ge in (ue.ref !== void 0 && (Ue = ue.ref), ue.key !== void 0 && (Ie = '' + ue.key), ue))
        z.call(ue, ge) && !G.hasOwnProperty(ge) && (De[ge] = ue[ge]);
    var et = arguments.length - 2;
    if (et === 1) De.children = He;
    else if (1 < et) {
      for (var Bt = Array(et), ht = 0; ht < et; ht++) Bt[ht] = arguments[ht + 2];
      De.children = Bt;
    }
    if (Y && Y.defaultProps)
      for (ge in ((et = Y.defaultProps), et)) De[ge] === void 0 && (De[ge] = et[ge]);
    return { $$typeof: r, type: Y, key: Ie, ref: Ue, props: De, _owner: N.current };
  }
  function L(Y, ue) {
    return { $$typeof: r, type: Y.type, key: ue, ref: Y.ref, props: Y.props, _owner: Y._owner };
  }
  function D(Y) {
    return typeof Y == 'object' && Y !== null && Y.$$typeof === r;
  }
  function V(Y) {
    var ue = { '=': '=0', ':': '=2' };
    return (
      '$' +
      Y.replace(/[=:]/g, function (He) {
        return ue[He];
      })
    );
  }
  var oe = /\/+/g;
  function ie(Y, ue) {
    return typeof Y == 'object' && Y !== null && Y.key != null ? V('' + Y.key) : ue.toString(36);
  }
  function ce(Y, ue, He, ge, De) {
    var Ie = typeof Y;
    (Ie === 'undefined' || Ie === 'boolean') && (Y = null);
    var Ue = !1;
    if (Y === null) Ue = !0;
    else
      switch (Ie) {
        case 'string':
        case 'number':
          Ue = !0;
          break;
        case 'object':
          switch (Y.$$typeof) {
            case r:
            case e:
              Ue = !0;
          }
      }
    if (Ue)
      return (
        (Ue = Y),
        (De = De(Ue)),
        (Y = ge === '' ? '.' + ie(Ue, 0) : ge),
        B(De)
          ? ((He = ''),
            Y != null && (He = Y.replace(oe, '$&/') + '/'),
            ce(De, ue, He, '', function (ht) {
              return ht;
            }))
          : De != null &&
            (D(De) &&
              (De = L(
                De,
                He +
                  (!De.key || (Ue && Ue.key === De.key)
                    ? ''
                    : ('' + De.key).replace(oe, '$&/') + '/') +
                  Y,
              )),
            ue.push(De)),
        1
      );
    if (((Ue = 0), (ge = ge === '' ? '.' : ge + ':'), B(Y)))
      for (var et = 0; et < Y.length; et++) {
        Ie = Y[et];
        var Bt = ge + ie(Ie, et);
        Ue += ce(Ie, ue, He, Bt, De);
      }
    else if (((Bt = v(Y)), typeof Bt == 'function'))
      for (Y = Bt.call(Y), et = 0; !(Ie = Y.next()).done; )
        (Ie = Ie.value), (Bt = ge + ie(Ie, et++)), (Ue += ce(Ie, ue, He, Bt, De));
    else if (Ie === 'object')
      throw (
        ((ue = String(Y)),
        Error(
          'Objects are not valid as a React child (found: ' +
            (ue === '[object Object]'
              ? 'object with keys {' + Object.keys(Y).join(', ') + '}'
              : ue) +
            '). If you meant to render a collection of children, use an array instead.',
        ))
      );
    return Ue;
  }
  function xe(Y, ue, He) {
    if (Y == null) return Y;
    var ge = [],
      De = 0;
    return (
      ce(Y, ge, '', '', function (Ie) {
        return ue.call(He, Ie, De++);
      }),
      ge
    );
  }
  function de(Y) {
    if (Y._status === -1) {
      var ue = Y._result;
      (ue = ue()),
        ue.then(
          function (He) {
            (Y._status === 0 || Y._status === -1) && ((Y._status = 1), (Y._result = He));
          },
          function (He) {
            (Y._status === 0 || Y._status === -1) && ((Y._status = 2), (Y._result = He));
          },
        ),
        Y._status === -1 && ((Y._status = 0), (Y._result = ue));
    }
    if (Y._status === 1) return Y._result.default;
    throw Y._result;
  }
  var Ce = { current: null },
    X = { transition: null },
    fe = { ReactCurrentDispatcher: Ce, ReactCurrentBatchConfig: X, ReactCurrentOwner: N };
  function te() {
    throw Error('act(...) is not supported in production builds of React.');
  }
  return (
    (An.Children = {
      map: xe,
      forEach: function (Y, ue, He) {
        xe(
          Y,
          function () {
            ue.apply(this, arguments);
          },
          He,
        );
      },
      count: function (Y) {
        var ue = 0;
        return (
          xe(Y, function () {
            ue++;
          }),
          ue
        );
      },
      toArray: function (Y) {
        return (
          xe(Y, function (ue) {
            return ue;
          }) || []
        );
      },
      only: function (Y) {
        if (!D(Y))
          throw Error('React.Children.only expected to receive a single React element child.');
        return Y;
      },
    }),
    (An.Component = E),
    (An.Fragment = t),
    (An.Profiler = i),
    (An.PureComponent = b),
    (An.StrictMode = n),
    (An.Suspense = d),
    (An.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fe),
    (An.act = te),
    (An.cloneElement = function (Y, ue, He) {
      if (Y == null)
        throw Error(
          'React.cloneElement(...): The argument must be a React element, but you passed ' +
            Y +
            '.',
        );
      var ge = A({}, Y.props),
        De = Y.key,
        Ie = Y.ref,
        Ue = Y._owner;
      if (ue != null) {
        if (
          (ue.ref !== void 0 && ((Ie = ue.ref), (Ue = N.current)),
          ue.key !== void 0 && (De = '' + ue.key),
          Y.type && Y.type.defaultProps)
        )
          var et = Y.type.defaultProps;
        for (Bt in ue)
          z.call(ue, Bt) &&
            !G.hasOwnProperty(Bt) &&
            (ge[Bt] = ue[Bt] === void 0 && et !== void 0 ? et[Bt] : ue[Bt]);
      }
      var Bt = arguments.length - 2;
      if (Bt === 1) ge.children = He;
      else if (1 < Bt) {
        et = Array(Bt);
        for (var ht = 0; ht < Bt; ht++) et[ht] = arguments[ht + 2];
        ge.children = et;
      }
      return { $$typeof: r, type: Y.type, key: De, ref: Ie, props: ge, _owner: Ue };
    }),
    (An.createContext = function (Y) {
      return (
        (Y = {
          $$typeof: a,
          _currentValue: Y,
          _currentValue2: Y,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (Y.Provider = { $$typeof: o, _context: Y }),
        (Y.Consumer = Y)
      );
    }),
    (An.createElement = k),
    (An.createFactory = function (Y) {
      var ue = k.bind(null, Y);
      return (ue.type = Y), ue;
    }),
    (An.createRef = function () {
      return { current: null };
    }),
    (An.forwardRef = function (Y) {
      return { $$typeof: u, render: Y };
    }),
    (An.isValidElement = D),
    (An.lazy = function (Y) {
      return { $$typeof: m, _payload: { _status: -1, _result: Y }, _init: de };
    }),
    (An.memo = function (Y, ue) {
      return { $$typeof: h, type: Y, compare: ue === void 0 ? null : ue };
    }),
    (An.startTransition = function (Y) {
      var ue = X.transition;
      X.transition = {};
      try {
        Y();
      } finally {
        X.transition = ue;
      }
    }),
    (An.unstable_act = te),
    (An.useCallback = function (Y, ue) {
      return Ce.current.useCallback(Y, ue);
    }),
    (An.useContext = function (Y) {
      return Ce.current.useContext(Y);
    }),
    (An.useDebugValue = function () {}),
    (An.useDeferredValue = function (Y) {
      return Ce.current.useDeferredValue(Y);
    }),
    (An.useEffect = function (Y, ue) {
      return Ce.current.useEffect(Y, ue);
    }),
    (An.useId = function () {
      return Ce.current.useId();
    }),
    (An.useImperativeHandle = function (Y, ue, He) {
      return Ce.current.useImperativeHandle(Y, ue, He);
    }),
    (An.useInsertionEffect = function (Y, ue) {
      return Ce.current.useInsertionEffect(Y, ue);
    }),
    (An.useLayoutEffect = function (Y, ue) {
      return Ce.current.useLayoutEffect(Y, ue);
    }),
    (An.useMemo = function (Y, ue) {
      return Ce.current.useMemo(Y, ue);
    }),
    (An.useReducer = function (Y, ue, He) {
      return Ce.current.useReducer(Y, ue, He);
    }),
    (An.useRef = function (Y) {
      return Ce.current.useRef(Y);
    }),
    (An.useState = function (Y) {
      return Ce.current.useState(Y);
    }),
    (An.useSyncExternalStore = function (Y, ue, He) {
      return Ce.current.useSyncExternalStore(Y, ue, He);
    }),
    (An.useTransition = function () {
      return Ce.current.useTransition();
    }),
    (An.version = '18.3.1'),
    An
  );
}
var fx;
function Ng() {
  return fx || ((fx = 1), (Jv.exports = b1())), Jv.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var dx;
function I1() {
  if (dx) return Vd;
  dx = 1;
  var r = Ng(),
    e = Symbol.for('react.element'),
    t = Symbol.for('react.fragment'),
    n = Object.prototype.hasOwnProperty,
    i = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(u, d, h) {
    var m,
      g = {},
      v = null,
      x = null;
    h !== void 0 && (v = '' + h),
      d.key !== void 0 && (v = '' + d.key),
      d.ref !== void 0 && (x = d.ref);
    for (m in d) n.call(d, m) && !o.hasOwnProperty(m) && (g[m] = d[m]);
    if (u && u.defaultProps) for (m in ((d = u.defaultProps), d)) g[m] === void 0 && (g[m] = d[m]);
    return { $$typeof: e, type: u, key: v, ref: x, props: g, _owner: i.current };
  }
  return (Vd.Fragment = t), (Vd.jsx = a), (Vd.jsxs = a), Vd;
}
var hx;
function B1() {
  return hx || ((hx = 1), (Xv.exports = I1())), Xv.exports;
}
var Vt = B1(),
  je = Ng(),
  Jp = {},
  Yv = { exports: {} },
  Zr = {},
  Kv = { exports: {} },
  jv = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var px;
function P1() {
  return (
    px ||
      ((px = 1),
      (function (r) {
        function e(X, fe) {
          var te = X.length;
          X.push(fe);
          e: for (; 0 < te; ) {
            var Y = (te - 1) >>> 1,
              ue = X[Y];
            if (0 < i(ue, fe)) (X[Y] = fe), (X[te] = ue), (te = Y);
            else break e;
          }
        }
        function t(X) {
          return X.length === 0 ? null : X[0];
        }
        function n(X) {
          if (X.length === 0) return null;
          var fe = X[0],
            te = X.pop();
          if (te !== fe) {
            X[0] = te;
            e: for (var Y = 0, ue = X.length, He = ue >>> 1; Y < He; ) {
              var ge = 2 * (Y + 1) - 1,
                De = X[ge],
                Ie = ge + 1,
                Ue = X[Ie];
              if (0 > i(De, te))
                Ie < ue && 0 > i(Ue, De)
                  ? ((X[Y] = Ue), (X[Ie] = te), (Y = Ie))
                  : ((X[Y] = De), (X[ge] = te), (Y = ge));
              else if (Ie < ue && 0 > i(Ue, te)) (X[Y] = Ue), (X[Ie] = te), (Y = Ie);
              else break e;
            }
          }
          return fe;
        }
        function i(X, fe) {
          var te = X.sortIndex - fe.sortIndex;
          return te !== 0 ? te : X.id - fe.id;
        }
        if (typeof performance == 'object' && typeof performance.now == 'function') {
          var o = performance;
          r.unstable_now = function () {
            return o.now();
          };
        } else {
          var a = Date,
            u = a.now();
          r.unstable_now = function () {
            return a.now() - u;
          };
        }
        var d = [],
          h = [],
          m = 1,
          g = null,
          v = 3,
          x = !1,
          A = !1,
          C = !1,
          E = typeof setTimeout == 'function' ? setTimeout : null,
          S = typeof clearTimeout == 'function' ? clearTimeout : null,
          b = typeof setImmediate < 'u' ? setImmediate : null;
        typeof navigator < 'u' &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function I(X) {
          for (var fe = t(h); fe !== null; ) {
            if (fe.callback === null) n(h);
            else if (fe.startTime <= X) n(h), (fe.sortIndex = fe.expirationTime), e(d, fe);
            else break;
            fe = t(h);
          }
        }
        function B(X) {
          if (((C = !1), I(X), !A))
            if (t(d) !== null) (A = !0), de(z);
            else {
              var fe = t(h);
              fe !== null && Ce(B, fe.startTime - X);
            }
        }
        function z(X, fe) {
          (A = !1), C && ((C = !1), S(k), (k = -1)), (x = !0);
          var te = v;
          try {
            for (I(fe), g = t(d); g !== null && (!(g.expirationTime > fe) || (X && !V())); ) {
              var Y = g.callback;
              if (typeof Y == 'function') {
                (g.callback = null), (v = g.priorityLevel);
                var ue = Y(g.expirationTime <= fe);
                (fe = r.unstable_now()),
                  typeof ue == 'function' ? (g.callback = ue) : g === t(d) && n(d),
                  I(fe);
              } else n(d);
              g = t(d);
            }
            if (g !== null) var He = !0;
            else {
              var ge = t(h);
              ge !== null && Ce(B, ge.startTime - fe), (He = !1);
            }
            return He;
          } finally {
            (g = null), (v = te), (x = !1);
          }
        }
        var N = !1,
          G = null,
          k = -1,
          L = 5,
          D = -1;
        function V() {
          return !(r.unstable_now() - D < L);
        }
        function oe() {
          if (G !== null) {
            var X = r.unstable_now();
            D = X;
            var fe = !0;
            try {
              fe = G(!0, X);
            } finally {
              fe ? ie() : ((N = !1), (G = null));
            }
          } else N = !1;
        }
        var ie;
        if (typeof b == 'function')
          ie = function () {
            b(oe);
          };
        else if (typeof MessageChannel < 'u') {
          var ce = new MessageChannel(),
            xe = ce.port2;
          (ce.port1.onmessage = oe),
            (ie = function () {
              xe.postMessage(null);
            });
        } else
          ie = function () {
            E(oe, 0);
          };
        function de(X) {
          (G = X), N || ((N = !0), ie());
        }
        function Ce(X, fe) {
          k = E(function () {
            X(r.unstable_now());
          }, fe);
        }
        (r.unstable_IdlePriority = 5),
          (r.unstable_ImmediatePriority = 1),
          (r.unstable_LowPriority = 4),
          (r.unstable_NormalPriority = 3),
          (r.unstable_Profiling = null),
          (r.unstable_UserBlockingPriority = 2),
          (r.unstable_cancelCallback = function (X) {
            X.callback = null;
          }),
          (r.unstable_continueExecution = function () {
            A || x || ((A = !0), de(z));
          }),
          (r.unstable_forceFrameRate = function (X) {
            0 > X || 125 < X
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (L = 0 < X ? Math.floor(1e3 / X) : 5);
          }),
          (r.unstable_getCurrentPriorityLevel = function () {
            return v;
          }),
          (r.unstable_getFirstCallbackNode = function () {
            return t(d);
          }),
          (r.unstable_next = function (X) {
            switch (v) {
              case 1:
              case 2:
              case 3:
                var fe = 3;
                break;
              default:
                fe = v;
            }
            var te = v;
            v = fe;
            try {
              return X();
            } finally {
              v = te;
            }
          }),
          (r.unstable_pauseExecution = function () {}),
          (r.unstable_requestPaint = function () {}),
          (r.unstable_runWithPriority = function (X, fe) {
            switch (X) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                X = 3;
            }
            var te = v;
            v = X;
            try {
              return fe();
            } finally {
              v = te;
            }
          }),
          (r.unstable_scheduleCallback = function (X, fe, te) {
            var Y = r.unstable_now();
            switch (
              (typeof te == 'object' && te !== null
                ? ((te = te.delay), (te = typeof te == 'number' && 0 < te ? Y + te : Y))
                : (te = Y),
              X)
            ) {
              case 1:
                var ue = -1;
                break;
              case 2:
                ue = 250;
                break;
              case 5:
                ue = 1073741823;
                break;
              case 4:
                ue = 1e4;
                break;
              default:
                ue = 5e3;
            }
            return (
              (ue = te + ue),
              (X = {
                id: m++,
                callback: fe,
                priorityLevel: X,
                startTime: te,
                expirationTime: ue,
                sortIndex: -1,
              }),
              te > Y
                ? ((X.sortIndex = te),
                  e(h, X),
                  t(d) === null && X === t(h) && (C ? (S(k), (k = -1)) : (C = !0), Ce(B, te - Y)))
                : ((X.sortIndex = ue), e(d, X), A || x || ((A = !0), de(z))),
              X
            );
          }),
          (r.unstable_shouldYield = V),
          (r.unstable_wrapCallback = function (X) {
            var fe = v;
            return function () {
              var te = v;
              v = fe;
              try {
                return X.apply(this, arguments);
              } finally {
                v = te;
              }
            };
          });
      })(jv)),
    jv
  );
}
var mx;
function D1() {
  return mx || ((mx = 1), (Kv.exports = P1())), Kv.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gx;
function L1() {
  if (gx) return Zr;
  gx = 1;
  var r = Ng(),
    e = D1();
  function t(s) {
    for (
      var l = 'https://reactjs.org/docs/error-decoder.html?invariant=' + s, p = 1;
      p < arguments.length;
      p++
    )
      l += '&args[]=' + encodeURIComponent(arguments[p]);
    return (
      'Minified React error #' +
      s +
      '; visit ' +
      l +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    );
  }
  var n = new Set(),
    i = {};
  function o(s, l) {
    a(s, l), a(s + 'Capture', l);
  }
  function a(s, l) {
    for (i[s] = l, s = 0; s < l.length; s++) n.add(l[s]);
  }
  var u = !(
      typeof window > 'u' ||
      typeof window.document > 'u' ||
      typeof window.document.createElement > 'u'
    ),
    d = Object.prototype.hasOwnProperty,
    h =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    m = {},
    g = {};
  function v(s) {
    return d.call(g, s) ? !0 : d.call(m, s) ? !1 : h.test(s) ? (g[s] = !0) : ((m[s] = !0), !1);
  }
  function x(s, l, p, _) {
    if (p !== null && p.type === 0) return !1;
    switch (typeof l) {
      case 'function':
      case 'symbol':
        return !0;
      case 'boolean':
        return _
          ? !1
          : p !== null
          ? !p.acceptsBooleans
          : ((s = s.toLowerCase().slice(0, 5)), s !== 'data-' && s !== 'aria-');
      default:
        return !1;
    }
  }
  function A(s, l, p, _) {
    if (l === null || typeof l > 'u' || x(s, l, p, _)) return !0;
    if (_) return !1;
    if (p !== null)
      switch (p.type) {
        case 3:
          return !l;
        case 4:
          return l === !1;
        case 5:
          return isNaN(l);
        case 6:
          return isNaN(l) || 1 > l;
      }
    return !1;
  }
  function C(s, l, p, _, w, R, O) {
    (this.acceptsBooleans = l === 2 || l === 3 || l === 4),
      (this.attributeName = _),
      (this.attributeNamespace = w),
      (this.mustUseProperty = p),
      (this.propertyName = s),
      (this.type = l),
      (this.sanitizeURL = R),
      (this.removeEmptyString = O);
  }
  var E = {};
  'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (s) {
      E[s] = new C(s, 0, !1, s, null, !1, !1);
    }),
    [
      ['acceptCharset', 'accept-charset'],
      ['className', 'class'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
    ].forEach(function (s) {
      var l = s[0];
      E[l] = new C(l, 1, !1, s[1], null, !1, !1);
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (s) {
      E[s] = new C(s, 2, !1, s.toLowerCase(), null, !1, !1);
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (
      s,
    ) {
      E[s] = new C(s, 2, !1, s, null, !1, !1);
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
      .split(' ')
      .forEach(function (s) {
        E[s] = new C(s, 3, !1, s.toLowerCase(), null, !1, !1);
      }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (s) {
      E[s] = new C(s, 3, !0, s, null, !1, !1);
    }),
    ['capture', 'download'].forEach(function (s) {
      E[s] = new C(s, 4, !1, s, null, !1, !1);
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (s) {
      E[s] = new C(s, 6, !1, s, null, !1, !1);
    }),
    ['rowSpan', 'start'].forEach(function (s) {
      E[s] = new C(s, 5, !1, s.toLowerCase(), null, !1, !1);
    });
  var S = /[\-:]([a-z])/g;
  function b(s) {
    return s[1].toUpperCase();
  }
  'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (s) {
      var l = s.replace(S, b);
      E[l] = new C(l, 1, !1, s, null, !1, !1);
    }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
      .split(' ')
      .forEach(function (s) {
        var l = s.replace(S, b);
        E[l] = new C(l, 1, !1, s, 'http://www.w3.org/1999/xlink', !1, !1);
      }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (s) {
      var l = s.replace(S, b);
      E[l] = new C(l, 1, !1, s, 'http://www.w3.org/XML/1998/namespace', !1, !1);
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (s) {
      E[s] = new C(s, 1, !1, s.toLowerCase(), null, !1, !1);
    }),
    (E.xlinkHref = new C('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (s) {
      E[s] = new C(s, 1, !1, s.toLowerCase(), null, !0, !0);
    });
  function I(s, l, p, _) {
    var w = E.hasOwnProperty(l) ? E[l] : null;
    (w !== null
      ? w.type !== 0
      : _ || !(2 < l.length) || (l[0] !== 'o' && l[0] !== 'O') || (l[1] !== 'n' && l[1] !== 'N')) &&
      (A(l, p, w, _) && (p = null),
      _ || w === null
        ? v(l) && (p === null ? s.removeAttribute(l) : s.setAttribute(l, '' + p))
        : w.mustUseProperty
        ? (s[w.propertyName] = p === null ? (w.type === 3 ? !1 : '') : p)
        : ((l = w.attributeName),
          (_ = w.attributeNamespace),
          p === null
            ? s.removeAttribute(l)
            : ((w = w.type),
              (p = w === 3 || (w === 4 && p === !0) ? '' : '' + p),
              _ ? s.setAttributeNS(_, l, p) : s.setAttribute(l, p))));
  }
  var B = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    z = Symbol.for('react.element'),
    N = Symbol.for('react.portal'),
    G = Symbol.for('react.fragment'),
    k = Symbol.for('react.strict_mode'),
    L = Symbol.for('react.profiler'),
    D = Symbol.for('react.provider'),
    V = Symbol.for('react.context'),
    oe = Symbol.for('react.forward_ref'),
    ie = Symbol.for('react.suspense'),
    ce = Symbol.for('react.suspense_list'),
    xe = Symbol.for('react.memo'),
    de = Symbol.for('react.lazy'),
    Ce = Symbol.for('react.offscreen'),
    X = Symbol.iterator;
  function fe(s) {
    return s === null || typeof s != 'object'
      ? null
      : ((s = (X && s[X]) || s['@@iterator']), typeof s == 'function' ? s : null);
  }
  var te = Object.assign,
    Y;
  function ue(s) {
    if (Y === void 0)
      try {
        throw Error();
      } catch (p) {
        var l = p.stack.trim().match(/\n( *(at )?)/);
        Y = (l && l[1]) || '';
      }
    return (
      `
` +
      Y +
      s
    );
  }
  var He = !1;
  function ge(s, l) {
    if (!s || He) return '';
    He = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l)
        if (
          ((l = function () {
            throw Error();
          }),
          Object.defineProperty(l.prototype, 'props', {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(l, []);
          } catch (Te) {
            var _ = Te;
          }
          Reflect.construct(s, [], l);
        } else {
          try {
            l.call();
          } catch (Te) {
            _ = Te;
          }
          s.call(l.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Te) {
          _ = Te;
        }
        s();
      }
    } catch (Te) {
      if (Te && _ && typeof Te.stack == 'string') {
        for (
          var w = Te.stack.split(`
`),
            R = _.stack.split(`
`),
            O = w.length - 1,
            $ = R.length - 1;
          1 <= O && 0 <= $ && w[O] !== R[$];

        )
          $--;
        for (; 1 <= O && 0 <= $; O--, $--)
          if (w[O] !== R[$]) {
            if (O !== 1 || $ !== 1)
              do
                if ((O--, $--, 0 > $ || w[O] !== R[$])) {
                  var ae =
                    `
` + w[O].replace(' at new ', ' at ');
                  return (
                    s.displayName &&
                      ae.includes('<anonymous>') &&
                      (ae = ae.replace('<anonymous>', s.displayName)),
                    ae
                  );
                }
              while (1 <= O && 0 <= $);
            break;
          }
      }
    } finally {
      (He = !1), (Error.prepareStackTrace = p);
    }
    return (s = s ? s.displayName || s.name : '') ? ue(s) : '';
  }
  function De(s) {
    switch (s.tag) {
      case 5:
        return ue(s.type);
      case 16:
        return ue('Lazy');
      case 13:
        return ue('Suspense');
      case 19:
        return ue('SuspenseList');
      case 0:
      case 2:
      case 15:
        return (s = ge(s.type, !1)), s;
      case 11:
        return (s = ge(s.type.render, !1)), s;
      case 1:
        return (s = ge(s.type, !0)), s;
      default:
        return '';
    }
  }
  function Ie(s) {
    if (s == null) return null;
    if (typeof s == 'function') return s.displayName || s.name || null;
    if (typeof s == 'string') return s;
    switch (s) {
      case G:
        return 'Fragment';
      case N:
        return 'Portal';
      case L:
        return 'Profiler';
      case k:
        return 'StrictMode';
      case ie:
        return 'Suspense';
      case ce:
        return 'SuspenseList';
    }
    if (typeof s == 'object')
      switch (s.$$typeof) {
        case V:
          return (s.displayName || 'Context') + '.Consumer';
        case D:
          return (s._context.displayName || 'Context') + '.Provider';
        case oe:
          var l = s.render;
          return (
            (s = s.displayName),
            s ||
              ((s = l.displayName || l.name || ''),
              (s = s !== '' ? 'ForwardRef(' + s + ')' : 'ForwardRef')),
            s
          );
        case xe:
          return (l = s.displayName || null), l !== null ? l : Ie(s.type) || 'Memo';
        case de:
          (l = s._payload), (s = s._init);
          try {
            return Ie(s(l));
          } catch {}
      }
    return null;
  }
  function Ue(s) {
    var l = s.type;
    switch (s.tag) {
      case 24:
        return 'Cache';
      case 9:
        return (l.displayName || 'Context') + '.Consumer';
      case 10:
        return (l._context.displayName || 'Context') + '.Provider';
      case 18:
        return 'DehydratedFragment';
      case 11:
        return (
          (s = l.render),
          (s = s.displayName || s.name || ''),
          l.displayName || (s !== '' ? 'ForwardRef(' + s + ')' : 'ForwardRef')
        );
      case 7:
        return 'Fragment';
      case 5:
        return l;
      case 4:
        return 'Portal';
      case 3:
        return 'Root';
      case 6:
        return 'Text';
      case 16:
        return Ie(l);
      case 8:
        return l === k ? 'StrictMode' : 'Mode';
      case 22:
        return 'Offscreen';
      case 12:
        return 'Profiler';
      case 21:
        return 'Scope';
      case 13:
        return 'Suspense';
      case 19:
        return 'SuspenseList';
      case 25:
        return 'TracingMarker';
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == 'function') return l.displayName || l.name || null;
        if (typeof l == 'string') return l;
    }
    return null;
  }
  function et(s) {
    switch (typeof s) {
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return s;
      case 'object':
        return s;
      default:
        return '';
    }
  }
  function Bt(s) {
    var l = s.type;
    return (s = s.nodeName) && s.toLowerCase() === 'input' && (l === 'checkbox' || l === 'radio');
  }
  function ht(s) {
    var l = Bt(s) ? 'checked' : 'value',
      p = Object.getOwnPropertyDescriptor(s.constructor.prototype, l),
      _ = '' + s[l];
    if (
      !s.hasOwnProperty(l) &&
      typeof p < 'u' &&
      typeof p.get == 'function' &&
      typeof p.set == 'function'
    ) {
      var w = p.get,
        R = p.set;
      return (
        Object.defineProperty(s, l, {
          configurable: !0,
          get: function () {
            return w.call(this);
          },
          set: function (O) {
            (_ = '' + O), R.call(this, O);
          },
        }),
        Object.defineProperty(s, l, { enumerable: p.enumerable }),
        {
          getValue: function () {
            return _;
          },
          setValue: function (O) {
            _ = '' + O;
          },
          stopTracking: function () {
            (s._valueTracker = null), delete s[l];
          },
        }
      );
    }
  }
  function Jt(s) {
    s._valueTracker || (s._valueTracker = ht(s));
  }
  function Ye(s) {
    if (!s) return !1;
    var l = s._valueTracker;
    if (!l) return !0;
    var p = l.getValue(),
      _ = '';
    return (
      s && (_ = Bt(s) ? (s.checked ? 'true' : 'false') : s.value),
      (s = _),
      s !== p ? (l.setValue(s), !0) : !1
    );
  }
  function ke(s) {
    if (((s = s || (typeof document < 'u' ? document : void 0)), typeof s > 'u')) return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  function j(s, l) {
    var p = l.checked;
    return te({}, l, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: p ?? s._wrapperState.initialChecked,
    });
  }
  function It(s, l) {
    var p = l.defaultValue == null ? '' : l.defaultValue,
      _ = l.checked != null ? l.checked : l.defaultChecked;
    (p = et(l.value != null ? l.value : p)),
      (s._wrapperState = {
        initialChecked: _,
        initialValue: p,
        controlled:
          l.type === 'checkbox' || l.type === 'radio' ? l.checked != null : l.value != null,
      });
  }
  function qe(s, l) {
    (l = l.checked), l != null && I(s, 'checked', l, !1);
  }
  function yt(s, l) {
    qe(s, l);
    var p = et(l.value),
      _ = l.type;
    if (p != null)
      _ === 'number'
        ? ((p === 0 && s.value === '') || s.value != p) && (s.value = '' + p)
        : s.value !== '' + p && (s.value = '' + p);
    else if (_ === 'submit' || _ === 'reset') {
      s.removeAttribute('value');
      return;
    }
    l.hasOwnProperty('value')
      ? Ht(s, l.type, p)
      : l.hasOwnProperty('defaultValue') && Ht(s, l.type, et(l.defaultValue)),
      l.checked == null && l.defaultChecked != null && (s.defaultChecked = !!l.defaultChecked);
  }
  function rt(s, l, p) {
    if (l.hasOwnProperty('value') || l.hasOwnProperty('defaultValue')) {
      var _ = l.type;
      if (!((_ !== 'submit' && _ !== 'reset') || (l.value !== void 0 && l.value !== null))) return;
      (l = '' + s._wrapperState.initialValue),
        p || l === s.value || (s.value = l),
        (s.defaultValue = l);
    }
    (p = s.name),
      p !== '' && (s.name = ''),
      (s.defaultChecked = !!s._wrapperState.initialChecked),
      p !== '' && (s.name = p);
  }
  function Ht(s, l, p) {
    (l !== 'number' || ke(s.ownerDocument) !== s) &&
      (p == null
        ? (s.defaultValue = '' + s._wrapperState.initialValue)
        : s.defaultValue !== '' + p && (s.defaultValue = '' + p));
  }
  var lt = Array.isArray;
  function K(s, l, p, _) {
    if (((s = s.options), l)) {
      l = {};
      for (var w = 0; w < p.length; w++) l['$' + p[w]] = !0;
      for (p = 0; p < s.length; p++)
        (w = l.hasOwnProperty('$' + s[p].value)),
          s[p].selected !== w && (s[p].selected = w),
          w && _ && (s[p].defaultSelected = !0);
    } else {
      for (p = '' + et(p), l = null, w = 0; w < s.length; w++) {
        if (s[w].value === p) {
          (s[w].selected = !0), _ && (s[w].defaultSelected = !0);
          return;
        }
        l !== null || s[w].disabled || (l = s[w]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function H(s, l) {
    if (l.dangerouslySetInnerHTML != null) throw Error(t(91));
    return te({}, l, {
      value: void 0,
      defaultValue: void 0,
      children: '' + s._wrapperState.initialValue,
    });
  }
  function ve(s, l) {
    var p = l.value;
    if (p == null) {
      if (((p = l.children), (l = l.defaultValue), p != null)) {
        if (l != null) throw Error(t(92));
        if (lt(p)) {
          if (1 < p.length) throw Error(t(93));
          p = p[0];
        }
        l = p;
      }
      l == null && (l = ''), (p = l);
    }
    s._wrapperState = { initialValue: et(p) };
  }
  function Le(s, l) {
    var p = et(l.value),
      _ = et(l.defaultValue);
    p != null &&
      ((p = '' + p),
      p !== s.value && (s.value = p),
      l.defaultValue == null && s.defaultValue !== p && (s.defaultValue = p)),
      _ != null && (s.defaultValue = '' + _);
  }
  function We(s) {
    var l = s.textContent;
    l === s._wrapperState.initialValue && l !== '' && l !== null && (s.value = l);
  }
  function ze(s) {
    switch (s) {
      case 'svg':
        return 'http://www.w3.org/2000/svg';
      case 'math':
        return 'http://www.w3.org/1998/Math/MathML';
      default:
        return 'http://www.w3.org/1999/xhtml';
    }
  }
  function Ct(s, l) {
    return s == null || s === 'http://www.w3.org/1999/xhtml'
      ? ze(l)
      : s === 'http://www.w3.org/2000/svg' && l === 'foreignObject'
      ? 'http://www.w3.org/1999/xhtml'
      : s;
  }
  var at,
    pt = (function (s) {
      return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
        ? function (l, p, _, w) {
            MSApp.execUnsafeLocalFunction(function () {
              return s(l, p, _, w);
            });
          }
        : s;
    })(function (s, l) {
      if (s.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in s) s.innerHTML = l;
      else {
        for (
          at = at || document.createElement('div'),
            at.innerHTML = '<svg>' + l.valueOf().toString() + '</svg>',
            l = at.firstChild;
          s.firstChild;

        )
          s.removeChild(s.firstChild);
        for (; l.firstChild; ) s.appendChild(l.firstChild);
      }
    });
  function $t(s, l) {
    if (l) {
      var p = s.firstChild;
      if (p && p === s.lastChild && p.nodeType === 3) {
        p.nodeValue = l;
        return;
      }
    }
    s.textContent = l;
  }
  var Ze = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    wt = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(Ze).forEach(function (s) {
    wt.forEach(function (l) {
      (l = l + s.charAt(0).toUpperCase() + s.substring(1)), (Ze[l] = Ze[s]);
    });
  });
  function Ft(s, l, p) {
    return l == null || typeof l == 'boolean' || l === ''
      ? ''
      : p || typeof l != 'number' || l === 0 || (Ze.hasOwnProperty(s) && Ze[s])
      ? ('' + l).trim()
      : l + 'px';
  }
  function Rt(s, l) {
    s = s.style;
    for (var p in l)
      if (l.hasOwnProperty(p)) {
        var _ = p.indexOf('--') === 0,
          w = Ft(p, l[p], _);
        p === 'float' && (p = 'cssFloat'), _ ? s.setProperty(p, w) : (s[p] = w);
      }
  }
  var St = te(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    },
  );
  function re(s, l) {
    if (l) {
      if (St[s] && (l.children != null || l.dangerouslySetInnerHTML != null))
        throw Error(t(137, s));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null) throw Error(t(60));
        if (
          typeof l.dangerouslySetInnerHTML != 'object' ||
          !('__html' in l.dangerouslySetInnerHTML)
        )
          throw Error(t(61));
      }
      if (l.style != null && typeof l.style != 'object') throw Error(t(62));
    }
  }
  function Re(s, l) {
    if (s.indexOf('-') === -1) return typeof l.is == 'string';
    switch (s) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1;
      default:
        return !0;
    }
  }
  var tt = null;
  function ne(s) {
    return (
      (s = s.target || s.srcElement || window),
      s.correspondingUseElement && (s = s.correspondingUseElement),
      s.nodeType === 3 ? s.parentNode : s
    );
  }
  var ye = null,
    we = null,
    Oe = null;
  function vt(s) {
    if ((s = Xs(s))) {
      if (typeof ye != 'function') throw Error(t(280));
      var l = s.stateNode;
      l && ((l = Hc(l)), ye(s.stateNode, s.type, l));
    }
  }
  function dt(s) {
    we ? (Oe ? Oe.push(s) : (Oe = [s])) : (we = s);
  }
  function Gt() {
    if (we) {
      var s = we,
        l = Oe;
      if (((Oe = we = null), vt(s), l)) for (s = 0; s < l.length; s++) vt(l[s]);
    }
  }
  function _n(s, l) {
    return s(l);
  }
  function Nn() {}
  var an = !1;
  function qn(s, l, p) {
    if (an) return s(l, p);
    an = !0;
    try {
      return _n(s, l, p);
    } finally {
      (an = !1), (we !== null || Oe !== null) && (Nn(), Gt());
    }
  }
  function ni(s, l) {
    var p = s.stateNode;
    if (p === null) return null;
    var _ = Hc(p);
    if (_ === null) return null;
    p = _[l];
    e: switch (l) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        (_ = !_.disabled) ||
          ((s = s.type),
          (_ = !(s === 'button' || s === 'input' || s === 'select' || s === 'textarea'))),
          (s = !_);
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (p && typeof p != 'function') throw Error(t(231, l, typeof p));
    return p;
  }
  var yo = !1;
  if (u)
    try {
      var _s = {};
      Object.defineProperty(_s, 'passive', {
        get: function () {
          yo = !0;
        },
      }),
        window.addEventListener('test', _s, _s),
        window.removeEventListener('test', _s, _s);
    } catch {
      yo = !1;
    }
  function Zi(s, l, p, _, w, R, O, $, ae) {
    var Te = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(p, Te);
    } catch ($e) {
      this.onError($e);
    }
  }
  var Mr = !1,
    Er = null,
    Ii = !1,
    nn = null,
    Go = {
      onError: function (s) {
        (Mr = !0), (Er = s);
      },
    };
  function _o(s, l, p, _, w, R, O, $, ae) {
    (Mr = !1), (Er = null), Zi.apply(Go, arguments);
  }
  function F(s, l, p, _, w, R, O, $, ae) {
    if ((_o.apply(this, arguments), Mr)) {
      if (Mr) {
        var Te = Er;
        (Mr = !1), (Er = null);
      } else throw Error(t(198));
      Ii || ((Ii = !0), (nn = Te));
    }
  }
  function W(s) {
    var l = s,
      p = s;
    if (s.alternate) for (; l.return; ) l = l.return;
    else {
      s = l;
      do (l = s), l.flags & 4098 && (p = l.return), (s = l.return);
      while (s);
    }
    return l.tag === 3 ? p : null;
  }
  function se(s) {
    if (s.tag === 13) {
      var l = s.memoizedState;
      if ((l === null && ((s = s.alternate), s !== null && (l = s.memoizedState)), l !== null))
        return l.dehydrated;
    }
    return null;
  }
  function Ee(s) {
    if (W(s) !== s) throw Error(t(188));
  }
  function Be(s) {
    var l = s.alternate;
    if (!l) {
      if (((l = W(s)), l === null)) throw Error(t(188));
      return l !== s ? null : s;
    }
    for (var p = s, _ = l; ; ) {
      var w = p.return;
      if (w === null) break;
      var R = w.alternate;
      if (R === null) {
        if (((_ = w.return), _ !== null)) {
          p = _;
          continue;
        }
        break;
      }
      if (w.child === R.child) {
        for (R = w.child; R; ) {
          if (R === p) return Ee(w), s;
          if (R === _) return Ee(w), l;
          R = R.sibling;
        }
        throw Error(t(188));
      }
      if (p.return !== _.return) (p = w), (_ = R);
      else {
        for (var O = !1, $ = w.child; $; ) {
          if ($ === p) {
            (O = !0), (p = w), (_ = R);
            break;
          }
          if ($ === _) {
            (O = !0), (_ = w), (p = R);
            break;
          }
          $ = $.sibling;
        }
        if (!O) {
          for ($ = R.child; $; ) {
            if ($ === p) {
              (O = !0), (p = R), (_ = w);
              break;
            }
            if ($ === _) {
              (O = !0), (_ = R), (p = w);
              break;
            }
            $ = $.sibling;
          }
          if (!O) throw Error(t(189));
        }
      }
      if (p.alternate !== _) throw Error(t(190));
    }
    if (p.tag !== 3) throw Error(t(188));
    return p.stateNode.current === p ? s : l;
  }
  function Pe(s) {
    return (s = Be(s)), s !== null ? it(s) : null;
  }
  function it(s) {
    if (s.tag === 5 || s.tag === 6) return s;
    for (s = s.child; s !== null; ) {
      var l = it(s);
      if (l !== null) return l;
      s = s.sibling;
    }
    return null;
  }
  var Qe = e.unstable_scheduleCallback,
    U = e.unstable_cancelCallback,
    Q = e.unstable_shouldYield,
    ee = e.unstable_requestPaint,
    q = e.unstable_now,
    le = e.unstable_getCurrentPriorityLevel,
    Ae = e.unstable_ImmediatePriority,
    Fe = e.unstable_UserBlockingPriority,
    Ve = e.unstable_NormalPriority,
    Je = e.unstable_LowPriority,
    ft = e.unstable_IdlePriority,
    ut = null,
    Xe = null;
  function mt(s) {
    if (Xe && typeof Xe.onCommitFiberRoot == 'function')
      try {
        Xe.onCommitFiberRoot(ut, s, void 0, (s.current.flags & 128) === 128);
      } catch {}
  }
  var gt = Math.clz32 ? Math.clz32 : Ut,
    qt = Math.log,
    Dt = Math.LN2;
  function Ut(s) {
    return (s >>>= 0), s === 0 ? 32 : (31 - ((qt(s) / Dt) | 0)) | 0;
  }
  var Mt = 64,
    cn = 4194304;
  function Wt(s) {
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return s & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return s;
    }
  }
  function en(s, l) {
    var p = s.pendingLanes;
    if (p === 0) return 0;
    var _ = 0,
      w = s.suspendedLanes,
      R = s.pingedLanes,
      O = p & 268435455;
    if (O !== 0) {
      var $ = O & ~w;
      $ !== 0 ? (_ = Wt($)) : ((R &= O), R !== 0 && (_ = Wt(R)));
    } else (O = p & ~w), O !== 0 ? (_ = Wt(O)) : R !== 0 && (_ = Wt(R));
    if (_ === 0) return 0;
    if (
      l !== 0 &&
      l !== _ &&
      !(l & w) &&
      ((w = _ & -_), (R = l & -l), w >= R || (w === 16 && (R & 4194240) !== 0))
    )
      return l;
    if ((_ & 4 && (_ |= p & 16), (l = s.entangledLanes), l !== 0))
      for (s = s.entanglements, l &= _; 0 < l; )
        (p = 31 - gt(l)), (w = 1 << p), (_ |= s[p]), (l &= ~w);
    return _;
  }
  function Hn(s, l) {
    switch (s) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function on(s, l) {
    for (
      var p = s.suspendedLanes, _ = s.pingedLanes, w = s.expirationTimes, R = s.pendingLanes;
      0 < R;

    ) {
      var O = 31 - gt(R),
        $ = 1 << O,
        ae = w[O];
      ae === -1 ? (!($ & p) || $ & _) && (w[O] = Hn($, l)) : ae <= l && (s.expiredLanes |= $),
        (R &= ~$);
    }
  }
  function pn(s) {
    return (s = s.pendingLanes & -1073741825), s !== 0 ? s : s & 1073741824 ? 1073741824 : 0;
  }
  function Yt() {
    var s = Mt;
    return (Mt <<= 1), !(Mt & 4194240) && (Mt = 64), s;
  }
  function Kn(s) {
    for (var l = [], p = 0; 31 > p; p++) l.push(s);
    return l;
  }
  function Cn(s, l, p) {
    (s.pendingLanes |= l),
      l !== 536870912 && ((s.suspendedLanes = 0), (s.pingedLanes = 0)),
      (s = s.eventTimes),
      (l = 31 - gt(l)),
      (s[l] = p);
  }
  function Gn(s, l) {
    var p = s.pendingLanes & ~l;
    (s.pendingLanes = l),
      (s.suspendedLanes = 0),
      (s.pingedLanes = 0),
      (s.expiredLanes &= l),
      (s.mutableReadLanes &= l),
      (s.entangledLanes &= l),
      (l = s.entanglements);
    var _ = s.eventTimes;
    for (s = s.expirationTimes; 0 < p; ) {
      var w = 31 - gt(p),
        R = 1 << w;
      (l[w] = 0), (_[w] = -1), (s[w] = -1), (p &= ~R);
    }
  }
  function ai(s, l) {
    var p = (s.entangledLanes |= l);
    for (s = s.entanglements; p; ) {
      var _ = 31 - gt(p),
        w = 1 << _;
      (w & l) | (s[_] & l) && (s[_] |= l), (p &= ~w);
    }
  }
  var xn = 0;
  function ur(s) {
    return (s &= -s), 1 < s ? (4 < s ? (s & 268435455 ? 16 : 536870912) : 4) : 1;
  }
  var Ll,
    jf,
    ep,
    uc,
    cc,
    Vo = !1,
    fc = [],
    xs = null,
    vn = null,
    Us = null,
    Wo = new Map(),
    Na = new Map(),
    xo = [],
    gv =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
        ' ',
      );
  function vi(s, l) {
    switch (s) {
      case 'focusin':
      case 'focusout':
        xs = null;
        break;
      case 'dragenter':
      case 'dragleave':
        vn = null;
        break;
      case 'mouseover':
      case 'mouseout':
        Us = null;
        break;
      case 'pointerover':
      case 'pointerout':
        Wo.delete(l.pointerId);
        break;
      case 'gotpointercapture':
      case 'lostpointercapture':
        Na.delete(l.pointerId);
    }
  }
  function Xo(s, l, p, _, w, R) {
    return s === null || s.nativeEvent !== R
      ? ((s = {
          blockedOn: l,
          domEventName: p,
          eventSystemFlags: _,
          nativeEvent: R,
          targetContainers: [w],
        }),
        l !== null && ((l = Xs(l)), l !== null && jf(l)),
        s)
      : ((s.eventSystemFlags |= _),
        (l = s.targetContainers),
        w !== null && l.indexOf(w) === -1 && l.push(w),
        s);
  }
  function vv(s, l, p, _, w) {
    switch (l) {
      case 'focusin':
        return (xs = Xo(xs, s, l, p, _, w)), !0;
      case 'dragenter':
        return (vn = Xo(vn, s, l, p, _, w)), !0;
      case 'mouseover':
        return (Us = Xo(Us, s, l, p, _, w)), !0;
      case 'pointerover':
        var R = w.pointerId;
        return Wo.set(R, Xo(Wo.get(R) || null, s, l, p, _, w)), !0;
      case 'gotpointercapture':
        return (R = w.pointerId), Na.set(R, Xo(Na.get(R) || null, s, l, p, _, w)), !0;
    }
    return !1;
  }
  function dc(s) {
    var l = To(s.target);
    if (l !== null) {
      var p = W(l);
      if (p !== null) {
        if (((l = p.tag), l === 13)) {
          if (((l = se(p)), l !== null)) {
            (s.blockedOn = l),
              cc(s.priority, function () {
                ep(p);
              });
            return;
          }
        } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function hc(s) {
    if (s.blockedOn !== null) return !1;
    for (var l = s.targetContainers; 0 < l.length; ) {
      var p = zr(s.domEventName, s.eventSystemFlags, l[0], s.nativeEvent);
      if (p === null) {
        p = s.nativeEvent;
        var _ = new p.constructor(p.type, p);
        (tt = _), p.target.dispatchEvent(_), (tt = null);
      } else return (l = Xs(p)), l !== null && jf(l), (s.blockedOn = p), !1;
      l.shift();
    }
    return !0;
  }
  function Fl(s, l, p) {
    hc(s) && p.delete(l);
  }
  function As() {
    (Vo = !1),
      xs !== null && hc(xs) && (xs = null),
      vn !== null && hc(vn) && (vn = null),
      Us !== null && hc(Us) && (Us = null),
      Wo.forEach(Fl),
      Na.forEach(Fl);
  }
  function Nl(s, l) {
    s.blockedOn === l &&
      ((s.blockedOn = null),
      Vo || ((Vo = !0), e.unstable_scheduleCallback(e.unstable_NormalPriority, As)));
  }
  function Ul(s) {
    function l(w) {
      return Nl(w, s);
    }
    if (0 < fc.length) {
      Nl(fc[0], s);
      for (var p = 1; p < fc.length; p++) {
        var _ = fc[p];
        _.blockedOn === s && (_.blockedOn = null);
      }
    }
    for (
      xs !== null && Nl(xs, s),
        vn !== null && Nl(vn, s),
        Us !== null && Nl(Us, s),
        Wo.forEach(l),
        Na.forEach(l),
        p = 0;
      p < xo.length;
      p++
    )
      (_ = xo[p]), _.blockedOn === s && (_.blockedOn = null);
    for (; 0 < xo.length && ((p = xo[0]), p.blockedOn === null); )
      dc(p), p.blockedOn === null && xo.shift();
  }
  var Qi = B.ReactCurrentBatchConfig,
    kr = !0;
  function pc(s, l, p, _) {
    var w = xn,
      R = Qi.transition;
    Qi.transition = null;
    try {
      (xn = 1), mc(s, l, p, _);
    } finally {
      (xn = w), (Qi.transition = R);
    }
  }
  function Zf(s, l, p, _) {
    var w = xn,
      R = Qi.transition;
    Qi.transition = null;
    try {
      (xn = 4), mc(s, l, p, _);
    } finally {
      (xn = w), (Qi.transition = R);
    }
  }
  function mc(s, l, p, _) {
    if (kr) {
      var w = zr(s, l, p, _);
      if (w === null) Fc(s, l, _, gc, p), vi(s, _);
      else if (vv(w, s, l, p, _)) _.stopPropagation();
      else if ((vi(s, _), l & 4 && -1 < gv.indexOf(s))) {
        for (; w !== null; ) {
          var R = Xs(w);
          if (
            (R !== null && Ll(R), (R = zr(s, l, p, _)), R === null && Fc(s, l, _, gc, p), R === w)
          )
            break;
          w = R;
        }
        w !== null && _.stopPropagation();
      } else Fc(s, l, _, null, p);
    }
  }
  var gc = null;
  function zr(s, l, p, _) {
    if (((gc = null), (s = ne(_)), (s = To(s)), s !== null))
      if (((l = W(s)), l === null)) s = null;
      else if (((p = l.tag), p === 13)) {
        if (((s = se(l)), s !== null)) return s;
        s = null;
      } else if (p === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated)
          return l.tag === 3 ? l.stateNode.containerInfo : null;
        s = null;
      } else l !== s && (s = null);
    return (gc = s), null;
  }
  function tp(s) {
    switch (s) {
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return 1;
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'toggle':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return 4;
      case 'message':
        switch (le()) {
          case Ae:
            return 1;
          case Fe:
            return 4;
          case Ve:
          case Je:
            return 16;
          case ft:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var rs = null,
    Qf = null,
    cr = null;
  function Ol() {
    if (cr) return cr;
    var s,
      l = Qf,
      p = l.length,
      _,
      w = 'value' in rs ? rs.value : rs.textContent,
      R = w.length;
    for (s = 0; s < p && l[s] === w[s]; s++);
    var O = p - s;
    for (_ = 1; _ <= O && l[p - _] === w[R - _]; _++);
    return (cr = w.slice(s, 1 < _ ? 1 - _ : void 0));
  }
  function Jo(s) {
    var l = s.keyCode;
    return (
      'charCode' in s ? ((s = s.charCode), s === 0 && l === 13 && (s = 13)) : (s = l),
      s === 10 && (s = 13),
      32 <= s || s === 13 ? s : 0
    );
  }
  function Os() {
    return !0;
  }
  function vc() {
    return !1;
  }
  function qi(s) {
    function l(p, _, w, R, O) {
      (this._reactName = p),
        (this._targetInst = w),
        (this.type = _),
        (this.nativeEvent = R),
        (this.target = O),
        (this.currentTarget = null);
      for (var $ in s) s.hasOwnProperty($) && ((p = s[$]), (this[$] = p ? p(R) : R[$]));
      return (
        (this.isDefaultPrevented = (
          R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1
        )
          ? Os
          : vc),
        (this.isPropagationStopped = vc),
        this
      );
    }
    return (
      te(l.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p &&
            (p.preventDefault
              ? p.preventDefault()
              : typeof p.returnValue != 'unknown' && (p.returnValue = !1),
            (this.isDefaultPrevented = Os));
        },
        stopPropagation: function () {
          var p = this.nativeEvent;
          p &&
            (p.stopPropagation
              ? p.stopPropagation()
              : typeof p.cancelBubble != 'unknown' && (p.cancelBubble = !0),
            (this.isPropagationStopped = Os));
        },
        persist: function () {},
        isPersistent: Os,
      }),
      l
    );
  }
  var Yo = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (s) {
        return s.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    kl = qi(Yo),
    Ko = te({}, Yo, { view: 0, detail: 0 }),
    Ua = qi(Ko),
    fr,
    Hr,
    Gr,
    Oa = te({}, Ko, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: So,
      button: 0,
      buttons: 0,
      relatedTarget: function (s) {
        return s.relatedTarget === void 0
          ? s.fromElement === s.srcElement
            ? s.toElement
            : s.fromElement
          : s.relatedTarget;
      },
      movementX: function (s) {
        return 'movementX' in s
          ? s.movementX
          : (s !== Gr &&
              (Gr && s.type === 'mousemove'
                ? ((fr = s.screenX - Gr.screenX), (Hr = s.screenY - Gr.screenY))
                : (Hr = fr = 0),
              (Gr = s)),
            fr);
      },
      movementY: function (s) {
        return 'movementY' in s ? s.movementY : Hr;
      },
    }),
    qf = qi(Oa),
    ks = te({}, Oa, { dataTransfer: 0 }),
    Ao = qi(ks),
    yc = te({}, Ko, { relatedTarget: 0 }),
    _c = qi(yc),
    xc = te({}, Yo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    np = qi(xc),
    ip = te({}, Yo, {
      clipboardData: function (s) {
        return 'clipboardData' in s ? s.clipboardData : window.clipboardData;
      },
    }),
    $f = qi(ip),
    Ac = te({}, Yo, { data: 0 }),
    ed = qi(Ac),
    rp = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified',
    },
    sp = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta',
    },
    td = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' };
  function ka(s) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(s) : (s = td[s]) ? !!l[s] : !1;
  }
  function So() {
    return ka;
  }
  var Sc = te({}, Ko, {
      key: function (s) {
        if (s.key) {
          var l = rp[s.key] || s.key;
          if (l !== 'Unidentified') return l;
        }
        return s.type === 'keypress'
          ? ((s = Jo(s)), s === 13 ? 'Enter' : String.fromCharCode(s))
          : s.type === 'keydown' || s.type === 'keyup'
          ? sp[s.keyCode] || 'Unidentified'
          : '';
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: So,
      charCode: function (s) {
        return s.type === 'keypress' ? Jo(s) : 0;
      },
      keyCode: function (s) {
        return s.type === 'keydown' || s.type === 'keyup' ? s.keyCode : 0;
      },
      which: function (s) {
        return s.type === 'keypress'
          ? Jo(s)
          : s.type === 'keydown' || s.type === 'keyup'
          ? s.keyCode
          : 0;
      },
    }),
    Mc = qi(Sc),
    Vr = te({}, Oa, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    wr = qi(Vr),
    jo = te({}, Ko, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: So,
    }),
    zs = qi(jo),
    Hs = te({}, Yo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Zo = qi(Hs),
    op = te({}, Oa, {
      deltaX: function (s) {
        return 'deltaX' in s ? s.deltaX : 'wheelDeltaX' in s ? -s.wheelDeltaX : 0;
      },
      deltaY: function (s) {
        return 'deltaY' in s
          ? s.deltaY
          : 'wheelDeltaY' in s
          ? -s.wheelDeltaY
          : 'wheelDelta' in s
          ? -s.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    nd = qi(op),
    id = [9, 13, 27, 32],
    $i = u && 'CompositionEvent' in window,
    Bi = null;
  u && 'documentMode' in document && (Bi = document.documentMode);
  var jn = u && 'TextEvent' in window && !Bi,
    za = u && (!$i || (Bi && 8 < Bi && 11 >= Bi)),
    Wr = ' ',
    rd = !1;
  function sd(s, l) {
    switch (s) {
      case 'keyup':
        return id.indexOf(l.keyCode) !== -1;
      case 'keydown':
        return l.keyCode !== 229;
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0;
      default:
        return !1;
    }
  }
  function Ec(s) {
    return (s = s.detail), typeof s == 'object' && 'data' in s ? s.data : null;
  }
  var Mo = !1;
  function ap(s, l) {
    switch (s) {
      case 'compositionend':
        return Ec(l);
      case 'keypress':
        return l.which !== 32 ? null : ((rd = !0), Wr);
      case 'textInput':
        return (s = l.data), s === Wr && rd ? null : s;
      default:
        return null;
    }
  }
  function zl(s, l) {
    if (Mo)
      return s === 'compositionend' || (!$i && sd(s, l))
        ? ((s = Ol()), (cr = Qf = rs = null), (Mo = !1), s)
        : null;
    switch (s) {
      case 'paste':
        return null;
      case 'keypress':
        if (!(l.ctrlKey || l.altKey || l.metaKey) || (l.ctrlKey && l.altKey)) {
          if (l.char && 1 < l.char.length) return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case 'compositionend':
        return za && l.locale !== 'ko' ? null : l.data;
      default:
        return null;
    }
  }
  var Ha = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function wc(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return l === 'input' ? !!Ha[s.type] : l === 'textarea';
  }
  function Ga(s, l, p, _) {
    dt(_),
      (l = Nc(l, 'onChange')),
      0 < l.length &&
        ((p = new kl('onChange', 'change', null, p, _)), s.push({ event: p, listeners: l }));
  }
  var Eo = null,
    Va = null;
  function lp(s) {
    Ya(s, 0);
  }
  function Gs(s) {
    var l = li(s);
    if (Ye(l)) return s;
  }
  function up(s, l) {
    if (s === 'change') return l;
  }
  var Wa = !1;
  if (u) {
    var dr;
    if (u) {
      var Qo = 'oninput' in document;
      if (!Qo) {
        var qo = document.createElement('div');
        qo.setAttribute('oninput', 'return;'), (Qo = typeof qo.oninput == 'function');
      }
      dr = Qo;
    } else dr = !1;
    Wa = dr && (!document.documentMode || 9 < document.documentMode);
  }
  function ss() {
    Eo && (Eo.detachEvent('onpropertychange', Cc), (Va = Eo = null));
  }
  function Cc(s) {
    if (s.propertyName === 'value' && Gs(Va)) {
      var l = [];
      Ga(l, Va, s, ne(s)), qn(lp, l);
    }
  }
  function Xa(s, l, p) {
    s === 'focusin'
      ? (ss(), (Eo = l), (Va = p), Eo.attachEvent('onpropertychange', Cc))
      : s === 'focusout' && ss();
  }
  function cp(s) {
    if (s === 'selectionchange' || s === 'keyup' || s === 'keydown') return Gs(Va);
  }
  function od(s, l) {
    if (s === 'click') return Gs(l);
  }
  function $n(s, l) {
    if (s === 'input' || s === 'change') return Gs(l);
  }
  function Tc(s, l) {
    return (s === l && (s !== 0 || 1 / s === 1 / l)) || (s !== s && l !== l);
  }
  var Cr = typeof Object.is == 'function' ? Object.is : Tc;
  function $o(s, l) {
    if (Cr(s, l)) return !0;
    if (typeof s != 'object' || s === null || typeof l != 'object' || l === null) return !1;
    var p = Object.keys(s),
      _ = Object.keys(l);
    if (p.length !== _.length) return !1;
    for (_ = 0; _ < p.length; _++) {
      var w = p[_];
      if (!d.call(l, w) || !Cr(s[w], l[w])) return !1;
    }
    return !0;
  }
  function Hl(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function Tr(s, l) {
    var p = Hl(s);
    s = 0;
    for (var _; p; ) {
      if (p.nodeType === 3) {
        if (((_ = s + p.textContent.length), s <= l && _ >= l)) return { node: p, offset: l - s };
        s = _;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = Hl(p);
    }
  }
  function ea(s, l) {
    return s && l
      ? s === l
        ? !0
        : s && s.nodeType === 3
        ? !1
        : l && l.nodeType === 3
        ? ea(s, l.parentNode)
        : 'contains' in s
        ? s.contains(l)
        : s.compareDocumentPosition
        ? !!(s.compareDocumentPosition(l) & 16)
        : !1
      : !1;
  }
  function ei() {
    for (var s = window, l = ke(); l instanceof s.HTMLIFrameElement; ) {
      try {
        var p = typeof l.contentWindow.location.href == 'string';
      } catch {
        p = !1;
      }
      if (p) s = l.contentWindow;
      else break;
      l = ke(s.document);
    }
    return l;
  }
  function Mi(s) {
    var l = s && s.nodeName && s.nodeName.toLowerCase();
    return (
      l &&
      ((l === 'input' &&
        (s.type === 'text' ||
          s.type === 'search' ||
          s.type === 'tel' ||
          s.type === 'url' ||
          s.type === 'password')) ||
        l === 'textarea' ||
        s.contentEditable === 'true')
    );
  }
  function Ei(s) {
    var l = ei(),
      p = s.focusedElem,
      _ = s.selectionRange;
    if (l !== p && p && p.ownerDocument && ea(p.ownerDocument.documentElement, p)) {
      if (_ !== null && Mi(p)) {
        if (((l = _.start), (s = _.end), s === void 0 && (s = l), 'selectionStart' in p))
          (p.selectionStart = l), (p.selectionEnd = Math.min(s, p.value.length));
        else if (
          ((s = ((l = p.ownerDocument || document) && l.defaultView) || window), s.getSelection)
        ) {
          s = s.getSelection();
          var w = p.textContent.length,
            R = Math.min(_.start, w);
          (_ = _.end === void 0 ? R : Math.min(_.end, w)),
            !s.extend && R > _ && ((w = _), (_ = R), (R = w)),
            (w = Tr(p, R));
          var O = Tr(p, _);
          w &&
            O &&
            (s.rangeCount !== 1 ||
              s.anchorNode !== w.node ||
              s.anchorOffset !== w.offset ||
              s.focusNode !== O.node ||
              s.focusOffset !== O.offset) &&
            ((l = l.createRange()),
            l.setStart(w.node, w.offset),
            s.removeAllRanges(),
            R > _
              ? (s.addRange(l), s.extend(O.node, O.offset))
              : (l.setEnd(O.node, O.offset), s.addRange(l)));
        }
      }
      for (l = [], s = p; (s = s.parentNode); )
        s.nodeType === 1 && l.push({ element: s, left: s.scrollLeft, top: s.scrollTop });
      for (typeof p.focus == 'function' && p.focus(), p = 0; p < l.length; p++)
        (s = l[p]), (s.element.scrollLeft = s.left), (s.element.scrollTop = s.top);
    }
  }
  var Rc = u && 'documentMode' in document && 11 >= document.documentMode,
    Ss = null,
    ta = null,
    Gl = null,
    wi = !1;
  function bc(s, l, p) {
    var _ = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    wi ||
      Ss == null ||
      Ss !== ke(_) ||
      ((_ = Ss),
      'selectionStart' in _ && Mi(_)
        ? (_ = { start: _.selectionStart, end: _.selectionEnd })
        : ((_ = ((_.ownerDocument && _.ownerDocument.defaultView) || window).getSelection()),
          (_ = {
            anchorNode: _.anchorNode,
            anchorOffset: _.anchorOffset,
            focusNode: _.focusNode,
            focusOffset: _.focusOffset,
          })),
      (Gl && $o(Gl, _)) ||
        ((Gl = _),
        (_ = Nc(ta, 'onSelect')),
        0 < _.length &&
          ((l = new kl('onSelect', 'select', null, l, p)),
          s.push({ event: l, listeners: _ }),
          (l.target = Ss))));
  }
  function Ja(s, l) {
    var p = {};
    return (
      (p[s.toLowerCase()] = l.toLowerCase()),
      (p['Webkit' + s] = 'webkit' + l),
      (p['Moz' + s] = 'moz' + l),
      p
    );
  }
  var wo = {
      animationend: Ja('Animation', 'AnimationEnd'),
      animationiteration: Ja('Animation', 'AnimationIteration'),
      animationstart: Ja('Animation', 'AnimationStart'),
      transitionend: Ja('Transition', 'TransitionEnd'),
    },
    os = {},
    as = {};
  u &&
    ((as = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete wo.animationend.animation,
      delete wo.animationiteration.animation,
      delete wo.animationstart.animation),
    'TransitionEvent' in window || delete wo.transitionend.transition);
  function Ms(s) {
    if (os[s]) return os[s];
    if (!wo[s]) return s;
    var l = wo[s],
      p;
    for (p in l) if (l.hasOwnProperty(p) && p in as) return (os[s] = l[p]);
    return s;
  }
  var Vl = Ms('animationend'),
    Wl = Ms('animationiteration'),
    ad = Ms('animationstart'),
    ld = Ms('transitionend'),
    ud = new Map(),
    cd =
      'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
        ' ',
      );
  function Vs(s, l) {
    ud.set(s, l), o(l, [s]);
  }
  for (var Ic = 0; Ic < cd.length; Ic++) {
    var Xl = cd[Ic],
      Jl = Xl.toLowerCase(),
      fp = Xl[0].toUpperCase() + Xl.slice(1);
    Vs(Jl, 'on' + fp);
  }
  Vs(Vl, 'onAnimationEnd'),
    Vs(Wl, 'onAnimationIteration'),
    Vs(ad, 'onAnimationStart'),
    Vs('dblclick', 'onDoubleClick'),
    Vs('focusin', 'onFocus'),
    Vs('focusout', 'onBlur'),
    Vs(ld, 'onTransitionEnd'),
    a('onMouseEnter', ['mouseout', 'mouseover']),
    a('onMouseLeave', ['mouseout', 'mouseover']),
    a('onPointerEnter', ['pointerout', 'pointerover']),
    a('onPointerLeave', ['pointerout', 'pointerover']),
    o('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')),
    o(
      'onSelect',
      'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' ',
      ),
    ),
    o('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
    o('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')),
    o(
      'onCompositionStart',
      'compositionstart focusout keydown keypress keyup mousedown'.split(' '),
    ),
    o(
      'onCompositionUpdate',
      'compositionupdate focusout keydown keypress keyup mousedown'.split(' '),
    );
  var Co =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' ',
      ),
    Bc = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Co));
  function Pc(s, l, p) {
    var _ = s.type || 'unknown-event';
    (s.currentTarget = p), F(_, l, void 0, s), (s.currentTarget = null);
  }
  function Ya(s, l) {
    l = (l & 4) !== 0;
    for (var p = 0; p < s.length; p++) {
      var _ = s[p],
        w = _.event;
      _ = _.listeners;
      e: {
        var R = void 0;
        if (l)
          for (var O = _.length - 1; 0 <= O; O--) {
            var $ = _[O],
              ae = $.instance,
              Te = $.currentTarget;
            if ((($ = $.listener), ae !== R && w.isPropagationStopped())) break e;
            Pc(w, $, Te), (R = ae);
          }
        else
          for (O = 0; O < _.length; O++) {
            if (
              (($ = _[O]),
              (ae = $.instance),
              (Te = $.currentTarget),
              ($ = $.listener),
              ae !== R && w.isPropagationStopped())
            )
              break e;
            Pc(w, $, Te), (R = ae);
          }
      }
    }
    if (Ii) throw ((s = nn), (Ii = !1), (nn = null), s);
  }
  function Vn(s, l) {
    var p = l[ra];
    p === void 0 && (p = l[ra] = new Set());
    var _ = s + '__bubble';
    p.has(_) || (Lc(l, s, 2, !1), p.add(_));
  }
  function Dc(s, l, p) {
    var _ = 0;
    l && (_ |= 4), Lc(p, s, _, l);
  }
  var Yl = '_reactListening' + Math.random().toString(36).slice(2);
  function Ka(s) {
    if (!s[Yl]) {
      (s[Yl] = !0),
        n.forEach(function (p) {
          p !== 'selectionchange' && (Bc.has(p) || Dc(p, !1, s), Dc(p, !0, s));
        });
      var l = s.nodeType === 9 ? s : s.ownerDocument;
      l === null || l[Yl] || ((l[Yl] = !0), Dc('selectionchange', !1, l));
    }
  }
  function Lc(s, l, p, _) {
    switch (tp(l)) {
      case 1:
        var w = pc;
        break;
      case 4:
        w = Zf;
        break;
      default:
        w = mc;
    }
    (p = w.bind(null, l, p, s)),
      (w = void 0),
      !yo || (l !== 'touchstart' && l !== 'touchmove' && l !== 'wheel') || (w = !0),
      _
        ? w !== void 0
          ? s.addEventListener(l, p, { capture: !0, passive: w })
          : s.addEventListener(l, p, !0)
        : w !== void 0
        ? s.addEventListener(l, p, { passive: w })
        : s.addEventListener(l, p, !1);
  }
  function Fc(s, l, p, _, w) {
    var R = _;
    if (!(l & 1) && !(l & 2) && _ !== null)
      e: for (;;) {
        if (_ === null) return;
        var O = _.tag;
        if (O === 3 || O === 4) {
          var $ = _.stateNode.containerInfo;
          if ($ === w || ($.nodeType === 8 && $.parentNode === w)) break;
          if (O === 4)
            for (O = _.return; O !== null; ) {
              var ae = O.tag;
              if (
                (ae === 3 || ae === 4) &&
                ((ae = O.stateNode.containerInfo),
                ae === w || (ae.nodeType === 8 && ae.parentNode === w))
              )
                return;
              O = O.return;
            }
          for (; $ !== null; ) {
            if (((O = To($)), O === null)) return;
            if (((ae = O.tag), ae === 5 || ae === 6)) {
              _ = R = O;
              continue e;
            }
            $ = $.parentNode;
          }
        }
        _ = _.return;
      }
    qn(function () {
      var Te = R,
        $e = ne(p),
        nt = [];
      e: {
        var Ke = ud.get(s);
        if (Ke !== void 0) {
          var Tt = kl,
            Lt = s;
          switch (s) {
            case 'keypress':
              if (Jo(p) === 0) break e;
            case 'keydown':
            case 'keyup':
              Tt = Mc;
              break;
            case 'focusin':
              (Lt = 'focus'), (Tt = _c);
              break;
            case 'focusout':
              (Lt = 'blur'), (Tt = _c);
              break;
            case 'beforeblur':
            case 'afterblur':
              Tt = _c;
              break;
            case 'click':
              if (p.button === 2) break e;
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              Tt = qf;
              break;
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              Tt = Ao;
              break;
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              Tt = zs;
              break;
            case Vl:
            case Wl:
            case ad:
              Tt = np;
              break;
            case ld:
              Tt = Zo;
              break;
            case 'scroll':
              Tt = Ua;
              break;
            case 'wheel':
              Tt = nd;
              break;
            case 'copy':
            case 'cut':
            case 'paste':
              Tt = $f;
              break;
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              Tt = wr;
          }
          var Nt = (l & 4) !== 0,
            _i = !Nt && s === 'scroll',
            _e = Nt ? (Ke !== null ? Ke + 'Capture' : null) : Ke;
          Nt = [];
          for (var he = Te, Se; he !== null; ) {
            Se = he;
            var ot = Se.stateNode;
            if (
              (Se.tag === 5 &&
                ot !== null &&
                ((Se = ot),
                _e !== null && ((ot = ni(he, _e)), ot != null && Nt.push(ja(he, ot, Se)))),
              _i)
            )
              break;
            he = he.return;
          }
          0 < Nt.length &&
            ((Ke = new Tt(Ke, Lt, null, p, $e)), nt.push({ event: Ke, listeners: Nt }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (
            ((Ke = s === 'mouseover' || s === 'pointerover'),
            (Tt = s === 'mouseout' || s === 'pointerout'),
            Ke && p !== tt && (Lt = p.relatedTarget || p.fromElement) && (To(Lt) || Lt[Rr]))
          )
            break e;
          if (
            (Tt || Ke) &&
            ((Ke =
              $e.window === $e
                ? $e
                : (Ke = $e.ownerDocument)
                ? Ke.defaultView || Ke.parentWindow
                : window),
            Tt
              ? ((Lt = p.relatedTarget || p.toElement),
                (Tt = Te),
                (Lt = Lt ? To(Lt) : null),
                Lt !== null &&
                  ((_i = W(Lt)), Lt !== _i || (Lt.tag !== 5 && Lt.tag !== 6)) &&
                  (Lt = null))
              : ((Tt = null), (Lt = Te)),
            Tt !== Lt)
          ) {
            if (
              ((Nt = qf),
              (ot = 'onMouseLeave'),
              (_e = 'onMouseEnter'),
              (he = 'mouse'),
              (s === 'pointerout' || s === 'pointerover') &&
                ((Nt = wr), (ot = 'onPointerLeave'), (_e = 'onPointerEnter'), (he = 'pointer')),
              (_i = Tt == null ? Ke : li(Tt)),
              (Se = Lt == null ? Ke : li(Lt)),
              (Ke = new Nt(ot, he + 'leave', Tt, p, $e)),
              (Ke.target = _i),
              (Ke.relatedTarget = Se),
              (ot = null),
              To($e) === Te &&
                ((Nt = new Nt(_e, he + 'enter', Lt, p, $e)),
                (Nt.target = Se),
                (Nt.relatedTarget = _i),
                (ot = Nt)),
              (_i = ot),
              Tt && Lt)
            )
              t: {
                for (Nt = Tt, _e = Lt, he = 0, Se = Nt; Se; Se = na(Se)) he++;
                for (Se = 0, ot = _e; ot; ot = na(ot)) Se++;
                for (; 0 < he - Se; ) (Nt = na(Nt)), he--;
                for (; 0 < Se - he; ) (_e = na(_e)), Se--;
                for (; he--; ) {
                  if (Nt === _e || (_e !== null && Nt === _e.alternate)) break t;
                  (Nt = na(Nt)), (_e = na(_e));
                }
                Nt = null;
              }
            else Nt = null;
            Tt !== null && dp(nt, Ke, Tt, Nt, !1),
              Lt !== null && _i !== null && dp(nt, _i, Lt, Nt, !0);
          }
        }
        e: {
          if (
            ((Ke = Te ? li(Te) : window),
            (Tt = Ke.nodeName && Ke.nodeName.toLowerCase()),
            Tt === 'select' || (Tt === 'input' && Ke.type === 'file'))
          )
            var zt = up;
          else if (wc(Ke))
            if (Wa) zt = $n;
            else {
              zt = cp;
              var Kt = Xa;
            }
          else
            (Tt = Ke.nodeName) &&
              Tt.toLowerCase() === 'input' &&
              (Ke.type === 'checkbox' || Ke.type === 'radio') &&
              (zt = od);
          if (zt && (zt = zt(s, Te))) {
            Ga(nt, zt, p, $e);
            break e;
          }
          Kt && Kt(s, Ke, Te),
            s === 'focusout' &&
              (Kt = Ke._wrapperState) &&
              Kt.controlled &&
              Ke.type === 'number' &&
              Ht(Ke, 'number', Ke.value);
        }
        switch (((Kt = Te ? li(Te) : window), s)) {
          case 'focusin':
            (wc(Kt) || Kt.contentEditable === 'true') && ((Ss = Kt), (ta = Te), (Gl = null));
            break;
          case 'focusout':
            Gl = ta = Ss = null;
            break;
          case 'mousedown':
            wi = !0;
            break;
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            (wi = !1), bc(nt, p, $e);
            break;
          case 'selectionchange':
            if (Rc) break;
          case 'keydown':
          case 'keyup':
            bc(nt, p, $e);
        }
        var jt;
        if ($i)
          e: {
            switch (s) {
              case 'compositionstart':
                var tn = 'onCompositionStart';
                break e;
              case 'compositionend':
                tn = 'onCompositionEnd';
                break e;
              case 'compositionupdate':
                tn = 'onCompositionUpdate';
                break e;
            }
            tn = void 0;
          }
        else
          Mo
            ? sd(s, p) && (tn = 'onCompositionEnd')
            : s === 'keydown' && p.keyCode === 229 && (tn = 'onCompositionStart');
        tn &&
          (za &&
            p.locale !== 'ko' &&
            (Mo || tn !== 'onCompositionStart'
              ? tn === 'onCompositionEnd' && Mo && (jt = Ol())
              : ((rs = $e), (Qf = 'value' in rs ? rs.value : rs.textContent), (Mo = !0))),
          (Kt = Nc(Te, tn)),
          0 < Kt.length &&
            ((tn = new ed(tn, s, null, p, $e)),
            nt.push({ event: tn, listeners: Kt }),
            jt ? (tn.data = jt) : ((jt = Ec(p)), jt !== null && (tn.data = jt)))),
          (jt = jn ? ap(s, p) : zl(s, p)) &&
            ((Te = Nc(Te, 'onBeforeInput')),
            0 < Te.length &&
              (($e = new ed('onBeforeInput', 'beforeinput', null, p, $e)),
              nt.push({ event: $e, listeners: Te }),
              ($e.data = jt)));
      }
      Ya(nt, l);
    });
  }
  function ja(s, l, p) {
    return { instance: s, listener: l, currentTarget: p };
  }
  function Nc(s, l) {
    for (var p = l + 'Capture', _ = []; s !== null; ) {
      var w = s,
        R = w.stateNode;
      w.tag === 5 &&
        R !== null &&
        ((w = R),
        (R = ni(s, p)),
        R != null && _.unshift(ja(s, R, w)),
        (R = ni(s, l)),
        R != null && _.push(ja(s, R, w))),
        (s = s.return);
    }
    return _;
  }
  function na(s) {
    if (s === null) return null;
    do s = s.return;
    while (s && s.tag !== 5);
    return s || null;
  }
  function dp(s, l, p, _, w) {
    for (var R = l._reactName, O = []; p !== null && p !== _; ) {
      var $ = p,
        ae = $.alternate,
        Te = $.stateNode;
      if (ae !== null && ae === _) break;
      $.tag === 5 &&
        Te !== null &&
        (($ = Te),
        w
          ? ((ae = ni(p, R)), ae != null && O.unshift(ja(p, ae, $)))
          : w || ((ae = ni(p, R)), ae != null && O.push(ja(p, ae, $)))),
        (p = p.return);
    }
    O.length !== 0 && s.push({ event: l, listeners: O });
  }
  var yv = /\r\n?/g,
    hp = /\u0000|\uFFFD/g;
  function fd(s) {
    return (typeof s == 'string' ? s : '' + s)
      .replace(
        yv,
        `
`,
      )
      .replace(hp, '');
  }
  function Kl(s, l, p) {
    if (((l = fd(l)), fd(s) !== l && p)) throw Error(t(425));
  }
  function jl() {}
  var Za = null,
    dd = null;
  function hd(s, l) {
    return (
      s === 'textarea' ||
      s === 'noscript' ||
      typeof l.children == 'string' ||
      typeof l.children == 'number' ||
      (typeof l.dangerouslySetInnerHTML == 'object' &&
        l.dangerouslySetInnerHTML !== null &&
        l.dangerouslySetInnerHTML.__html != null)
    );
  }
  var pd = typeof setTimeout == 'function' ? setTimeout : void 0,
    md = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    Uc = typeof Promise == 'function' ? Promise : void 0,
    _v =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof Uc < 'u'
        ? function (s) {
            return Uc.resolve(null).then(s).catch(pp);
          }
        : pd;
  function pp(s) {
    setTimeout(function () {
      throw s;
    });
  }
  function Oc(s, l) {
    var p = l,
      _ = 0;
    do {
      var w = p.nextSibling;
      if ((s.removeChild(p), w && w.nodeType === 8))
        if (((p = w.data), p === '/$')) {
          if (_ === 0) {
            s.removeChild(w), Ul(l);
            return;
          }
          _--;
        } else (p !== '$' && p !== '$?' && p !== '$!') || _++;
      p = w;
    } while (p);
    Ul(l);
  }
  function Ws(s) {
    for (; s != null; s = s.nextSibling) {
      var l = s.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (((l = s.data), l === '$' || l === '$!' || l === '$?')) break;
        if (l === '/$') return null;
      }
    }
    return s;
  }
  function gd(s) {
    s = s.previousSibling;
    for (var l = 0; s; ) {
      if (s.nodeType === 8) {
        var p = s.data;
        if (p === '$' || p === '$!' || p === '$?') {
          if (l === 0) return s;
          l--;
        } else p === '/$' && l++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  var ia = Math.random().toString(36).slice(2),
    yi = '__reactFiber$' + ia,
    Qa = '__reactProps$' + ia,
    Rr = '__reactContainer$' + ia,
    ra = '__reactEvents$' + ia,
    kc = '__reactListeners$' + ia,
    zc = '__reactHandles$' + ia;
  function To(s) {
    var l = s[yi];
    if (l) return l;
    for (var p = s.parentNode; p; ) {
      if ((l = p[Rr] || p[yi])) {
        if (((p = l.alternate), l.child !== null || (p !== null && p.child !== null)))
          for (s = gd(s); s !== null; ) {
            if ((p = s[yi])) return p;
            s = gd(s);
          }
        return l;
      }
      (s = p), (p = s.parentNode);
    }
    return null;
  }
  function Xs(s) {
    return (
      (s = s[yi] || s[Rr]),
      !s || (s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3) ? null : s
    );
  }
  function li(s) {
    if (s.tag === 5 || s.tag === 6) return s.stateNode;
    throw Error(t(33));
  }
  function Hc(s) {
    return s[Qa] || null;
  }
  var vd = [],
    Ci = -1;
  function ii(s) {
    return { current: s };
  }
  function Wn(s) {
    0 > Ci || ((s.current = vd[Ci]), (vd[Ci] = null), Ci--);
  }
  function kn(s, l) {
    Ci++, (vd[Ci] = s.current), (s.current = l);
  }
  var Js = {},
    Pi = ii(Js),
    er = ii(!1),
    Ys = Js;
  function sa(s, l) {
    var p = s.type.contextTypes;
    if (!p) return Js;
    var _ = s.stateNode;
    if (_ && _.__reactInternalMemoizedUnmaskedChildContext === l)
      return _.__reactInternalMemoizedMaskedChildContext;
    var w = {},
      R;
    for (R in p) w[R] = l[R];
    return (
      _ &&
        ((s = s.stateNode),
        (s.__reactInternalMemoizedUnmaskedChildContext = l),
        (s.__reactInternalMemoizedMaskedChildContext = w)),
      w
    );
  }
  function Hi(s) {
    return (s = s.childContextTypes), s != null;
  }
  function Zl() {
    Wn(er), Wn(Pi);
  }
  function yd(s, l, p) {
    if (Pi.current !== Js) throw Error(t(168));
    kn(Pi, l), kn(er, p);
  }
  function Ql(s, l, p) {
    var _ = s.stateNode;
    if (((l = l.childContextTypes), typeof _.getChildContext != 'function')) return p;
    _ = _.getChildContext();
    for (var w in _) if (!(w in l)) throw Error(t(108, Ue(s) || 'Unknown', w));
    return te({}, p, _);
  }
  function oa(s) {
    return (
      (s = ((s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext) || Js),
      (Ys = Pi.current),
      kn(Pi, s),
      kn(er, er.current),
      !0
    );
  }
  function _d(s, l, p) {
    var _ = s.stateNode;
    if (!_) throw Error(t(169));
    p
      ? ((s = Ql(s, l, Ys)),
        (_.__reactInternalMemoizedMergedChildContext = s),
        Wn(er),
        Wn(Pi),
        kn(Pi, s))
      : Wn(er),
      kn(er, p);
  }
  var ls = null,
    ql = !1,
    Gc = !1;
  function $l(s) {
    ls === null ? (ls = [s]) : ls.push(s);
  }
  function mp(s) {
    (ql = !0), $l(s);
  }
  function Es() {
    if (!Gc && ls !== null) {
      Gc = !0;
      var s = 0,
        l = xn;
      try {
        var p = ls;
        for (xn = 1; s < p.length; s++) {
          var _ = p[s];
          do _ = _(!0);
          while (_ !== null);
        }
        (ls = null), (ql = !1);
      } catch (w) {
        throw (ls !== null && (ls = ls.slice(s + 1)), Qe(Ae, Es), w);
      } finally {
        (xn = l), (Gc = !1);
      }
    }
    return null;
  }
  var aa = [],
    hr = 0,
    Vc = null,
    Wc = 0,
    tr = [],
    Ti = 0,
    la = null,
    ct = 1,
    Xr = '';
  function Ks(s, l) {
    (aa[hr++] = Wc), (aa[hr++] = Vc), (Vc = s), (Wc = l);
  }
  function xd(s, l, p) {
    (tr[Ti++] = ct), (tr[Ti++] = Xr), (tr[Ti++] = la), (la = s);
    var _ = ct;
    s = Xr;
    var w = 32 - gt(_) - 1;
    (_ &= ~(1 << w)), (p += 1);
    var R = 32 - gt(l) + w;
    if (30 < R) {
      var O = w - (w % 5);
      (R = (_ & ((1 << O) - 1)).toString(32)),
        (_ >>= O),
        (w -= O),
        (ct = (1 << (32 - gt(l) + w)) | (p << w) | _),
        (Xr = R + s);
    } else (ct = (1 << R) | (p << w) | _), (Xr = s);
  }
  function Ad(s) {
    s.return !== null && (Ks(s, 1), xd(s, 1, 0));
  }
  function js(s) {
    for (; s === Vc; ) (Vc = aa[--hr]), (aa[hr] = null), (Wc = aa[--hr]), (aa[hr] = null);
    for (; s === la; )
      (la = tr[--Ti]),
        (tr[Ti] = null),
        (Xr = tr[--Ti]),
        (tr[Ti] = null),
        (ct = tr[--Ti]),
        (tr[Ti] = null);
  }
  var Di = null,
    nr = null,
    Jn = !1,
    Jr = null;
  function Sd(s, l) {
    var p = bs(5, null, null, 0);
    (p.elementType = 'DELETED'),
      (p.stateNode = l),
      (p.return = s),
      (l = s.deletions),
      l === null ? ((s.deletions = [p]), (s.flags |= 16)) : l.push(p);
  }
  function Md(s, l) {
    switch (s.tag) {
      case 5:
        var p = s.type;
        return (
          (l = l.nodeType !== 1 || p.toLowerCase() !== l.nodeName.toLowerCase() ? null : l),
          l !== null ? ((s.stateNode = l), (Di = s), (nr = Ws(l.firstChild)), !0) : !1
        );
      case 6:
        return (
          (l = s.pendingProps === '' || l.nodeType !== 3 ? null : l),
          l !== null ? ((s.stateNode = l), (Di = s), (nr = null), !0) : !1
        );
      case 13:
        return (
          (l = l.nodeType !== 8 ? null : l),
          l !== null
            ? ((p = la !== null ? { id: ct, overflow: Xr } : null),
              (s.memoizedState = { dehydrated: l, treeContext: p, retryLane: 1073741824 }),
              (p = bs(18, null, null, 0)),
              (p.stateNode = l),
              (p.return = s),
              (s.child = p),
              (Di = s),
              (nr = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function Xc(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0;
  }
  function Jc(s) {
    if (Jn) {
      var l = nr;
      if (l) {
        var p = l;
        if (!Md(s, l)) {
          if (Xc(s)) throw Error(t(418));
          l = Ws(p.nextSibling);
          var _ = Di;
          l && Md(s, l) ? Sd(_, p) : ((s.flags = (s.flags & -4097) | 2), (Jn = !1), (Di = s));
        }
      } else {
        if (Xc(s)) throw Error(t(418));
        (s.flags = (s.flags & -4097) | 2), (Jn = !1), (Di = s);
      }
    }
  }
  function Yc(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; ) s = s.return;
    Di = s;
  }
  function qa(s) {
    if (s !== Di) return !1;
    if (!Jn) return Yc(s), (Jn = !0), !1;
    var l;
    if (
      ((l = s.tag !== 3) &&
        !(l = s.tag !== 5) &&
        ((l = s.type), (l = l !== 'head' && l !== 'body' && !hd(s.type, s.memoizedProps))),
      l && (l = nr))
    ) {
      if (Xc(s)) throw (Ed(), Error(t(418)));
      for (; l; ) Sd(s, l), (l = Ws(l.nextSibling));
    }
    if ((Yc(s), s.tag === 13)) {
      if (((s = s.memoizedState), (s = s !== null ? s.dehydrated : null), !s)) throw Error(t(317));
      e: {
        for (s = s.nextSibling, l = 0; s; ) {
          if (s.nodeType === 8) {
            var p = s.data;
            if (p === '/$') {
              if (l === 0) {
                nr = Ws(s.nextSibling);
                break e;
              }
              l--;
            } else (p !== '$' && p !== '$!' && p !== '$?') || l++;
          }
          s = s.nextSibling;
        }
        nr = null;
      }
    } else nr = Di ? Ws(s.stateNode.nextSibling) : null;
    return !0;
  }
  function Ed() {
    for (var s = nr; s; ) s = Ws(s.nextSibling);
  }
  function Ro() {
    (nr = Di = null), (Jn = !1);
  }
  function $a(s) {
    Jr === null ? (Jr = [s]) : Jr.push(s);
  }
  var xv = B.ReactCurrentBatchConfig;
  function eu(s, l, p) {
    if (((s = p.ref), s !== null && typeof s != 'function' && typeof s != 'object')) {
      if (p._owner) {
        if (((p = p._owner), p)) {
          if (p.tag !== 1) throw Error(t(309));
          var _ = p.stateNode;
        }
        if (!_) throw Error(t(147, s));
        var w = _,
          R = '' + s;
        return l !== null && l.ref !== null && typeof l.ref == 'function' && l.ref._stringRef === R
          ? l.ref
          : ((l = function (O) {
              var $ = w.refs;
              O === null ? delete $[R] : ($[R] = O);
            }),
            (l._stringRef = R),
            l);
      }
      if (typeof s != 'string') throw Error(t(284));
      if (!p._owner) throw Error(t(290, s));
    }
    return s;
  }
  function tu(s, l) {
    throw (
      ((s = Object.prototype.toString.call(l)),
      Error(
        t(31, s === '[object Object]' ? 'object with keys {' + Object.keys(l).join(', ') + '}' : s),
      ))
    );
  }
  function wd(s) {
    var l = s._init;
    return l(s._payload);
  }
  function Cd(s) {
    function l(_e, he) {
      if (s) {
        var Se = _e.deletions;
        Se === null ? ((_e.deletions = [he]), (_e.flags |= 16)) : Se.push(he);
      }
    }
    function p(_e, he) {
      if (!s) return null;
      for (; he !== null; ) l(_e, he), (he = he.sibling);
      return null;
    }
    function _(_e, he) {
      for (_e = new Map(); he !== null; )
        he.key !== null ? _e.set(he.key, he) : _e.set(he.index, he), (he = he.sibling);
      return _e;
    }
    function w(_e, he) {
      return (_e = cl(_e, he)), (_e.index = 0), (_e.sibling = null), _e;
    }
    function R(_e, he, Se) {
      return (
        (_e.index = Se),
        s
          ? ((Se = _e.alternate),
            Se !== null
              ? ((Se = Se.index), Se < he ? ((_e.flags |= 2), he) : Se)
              : ((_e.flags |= 2), he))
          : ((_e.flags |= 1048576), he)
      );
    }
    function O(_e) {
      return s && _e.alternate === null && (_e.flags |= 2), _e;
    }
    function $(_e, he, Se, ot) {
      return he === null || he.tag !== 6
        ? ((he = kv(Se, _e.mode, ot)), (he.return = _e), he)
        : ((he = w(he, Se)), (he.return = _e), he);
    }
    function ae(_e, he, Se, ot) {
      var zt = Se.type;
      return zt === G
        ? $e(_e, he, Se.props.children, ot, Se.key)
        : he !== null &&
          (he.elementType === zt ||
            (typeof zt == 'object' && zt !== null && zt.$$typeof === de && wd(zt) === he.type))
        ? ((ot = w(he, Se.props)), (ot.ref = eu(_e, he, Se)), (ot.return = _e), ot)
        : ((ot = Op(Se.type, Se.key, Se.props, null, _e.mode, ot)),
          (ot.ref = eu(_e, he, Se)),
          (ot.return = _e),
          ot);
    }
    function Te(_e, he, Se, ot) {
      return he === null ||
        he.tag !== 4 ||
        he.stateNode.containerInfo !== Se.containerInfo ||
        he.stateNode.implementation !== Se.implementation
        ? ((he = zv(Se, _e.mode, ot)), (he.return = _e), he)
        : ((he = w(he, Se.children || [])), (he.return = _e), he);
    }
    function $e(_e, he, Se, ot, zt) {
      return he === null || he.tag !== 7
        ? ((he = yu(Se, _e.mode, ot, zt)), (he.return = _e), he)
        : ((he = w(he, Se)), (he.return = _e), he);
    }
    function nt(_e, he, Se) {
      if ((typeof he == 'string' && he !== '') || typeof he == 'number')
        return (he = kv('' + he, _e.mode, Se)), (he.return = _e), he;
      if (typeof he == 'object' && he !== null) {
        switch (he.$$typeof) {
          case z:
            return (
              (Se = Op(he.type, he.key, he.props, null, _e.mode, Se)),
              (Se.ref = eu(_e, null, he)),
              (Se.return = _e),
              Se
            );
          case N:
            return (he = zv(he, _e.mode, Se)), (he.return = _e), he;
          case de:
            var ot = he._init;
            return nt(_e, ot(he._payload), Se);
        }
        if (lt(he) || fe(he)) return (he = yu(he, _e.mode, Se, null)), (he.return = _e), he;
        tu(_e, he);
      }
      return null;
    }
    function Ke(_e, he, Se, ot) {
      var zt = he !== null ? he.key : null;
      if ((typeof Se == 'string' && Se !== '') || typeof Se == 'number')
        return zt !== null ? null : $(_e, he, '' + Se, ot);
      if (typeof Se == 'object' && Se !== null) {
        switch (Se.$$typeof) {
          case z:
            return Se.key === zt ? ae(_e, he, Se, ot) : null;
          case N:
            return Se.key === zt ? Te(_e, he, Se, ot) : null;
          case de:
            return (zt = Se._init), Ke(_e, he, zt(Se._payload), ot);
        }
        if (lt(Se) || fe(Se)) return zt !== null ? null : $e(_e, he, Se, ot, null);
        tu(_e, Se);
      }
      return null;
    }
    function Tt(_e, he, Se, ot, zt) {
      if ((typeof ot == 'string' && ot !== '') || typeof ot == 'number')
        return (_e = _e.get(Se) || null), $(he, _e, '' + ot, zt);
      if (typeof ot == 'object' && ot !== null) {
        switch (ot.$$typeof) {
          case z:
            return (_e = _e.get(ot.key === null ? Se : ot.key) || null), ae(he, _e, ot, zt);
          case N:
            return (_e = _e.get(ot.key === null ? Se : ot.key) || null), Te(he, _e, ot, zt);
          case de:
            var Kt = ot._init;
            return Tt(_e, he, Se, Kt(ot._payload), zt);
        }
        if (lt(ot) || fe(ot)) return (_e = _e.get(Se) || null), $e(he, _e, ot, zt, null);
        tu(he, ot);
      }
      return null;
    }
    function Lt(_e, he, Se, ot) {
      for (
        var zt = null, Kt = null, jt = he, tn = (he = 0), Xi = null;
        jt !== null && tn < Se.length;
        tn++
      ) {
        jt.index > tn ? ((Xi = jt), (jt = null)) : (Xi = jt.sibling);
        var Dn = Ke(_e, jt, Se[tn], ot);
        if (Dn === null) {
          jt === null && (jt = Xi);
          break;
        }
        s && jt && Dn.alternate === null && l(_e, jt),
          (he = R(Dn, he, tn)),
          Kt === null ? (zt = Dn) : (Kt.sibling = Dn),
          (Kt = Dn),
          (jt = Xi);
      }
      if (tn === Se.length) return p(_e, jt), Jn && Ks(_e, tn), zt;
      if (jt === null) {
        for (; tn < Se.length; tn++)
          (jt = nt(_e, Se[tn], ot)),
            jt !== null &&
              ((he = R(jt, he, tn)), Kt === null ? (zt = jt) : (Kt.sibling = jt), (Kt = jt));
        return Jn && Ks(_e, tn), zt;
      }
      for (jt = _(_e, jt); tn < Se.length; tn++)
        (Xi = Tt(jt, _e, tn, Se[tn], ot)),
          Xi !== null &&
            (s && Xi.alternate !== null && jt.delete(Xi.key === null ? tn : Xi.key),
            (he = R(Xi, he, tn)),
            Kt === null ? (zt = Xi) : (Kt.sibling = Xi),
            (Kt = Xi));
      return (
        s &&
          jt.forEach(function (fl) {
            return l(_e, fl);
          }),
        Jn && Ks(_e, tn),
        zt
      );
    }
    function Nt(_e, he, Se, ot) {
      var zt = fe(Se);
      if (typeof zt != 'function') throw Error(t(150));
      if (((Se = zt.call(Se)), Se == null)) throw Error(t(151));
      for (
        var Kt = (zt = null), jt = he, tn = (he = 0), Xi = null, Dn = Se.next();
        jt !== null && !Dn.done;
        tn++, Dn = Se.next()
      ) {
        jt.index > tn ? ((Xi = jt), (jt = null)) : (Xi = jt.sibling);
        var fl = Ke(_e, jt, Dn.value, ot);
        if (fl === null) {
          jt === null && (jt = Xi);
          break;
        }
        s && jt && fl.alternate === null && l(_e, jt),
          (he = R(fl, he, tn)),
          Kt === null ? (zt = fl) : (Kt.sibling = fl),
          (Kt = fl),
          (jt = Xi);
      }
      if (Dn.done) return p(_e, jt), Jn && Ks(_e, tn), zt;
      if (jt === null) {
        for (; !Dn.done; tn++, Dn = Se.next())
          (Dn = nt(_e, Dn.value, ot)),
            Dn !== null &&
              ((he = R(Dn, he, tn)), Kt === null ? (zt = Dn) : (Kt.sibling = Dn), (Kt = Dn));
        return Jn && Ks(_e, tn), zt;
      }
      for (jt = _(_e, jt); !Dn.done; tn++, Dn = Se.next())
        (Dn = Tt(jt, _e, tn, Dn.value, ot)),
          Dn !== null &&
            (s && Dn.alternate !== null && jt.delete(Dn.key === null ? tn : Dn.key),
            (he = R(Dn, he, tn)),
            Kt === null ? (zt = Dn) : (Kt.sibling = Dn),
            (Kt = Dn));
      return (
        s &&
          jt.forEach(function (T1) {
            return l(_e, T1);
          }),
        Jn && Ks(_e, tn),
        zt
      );
    }
    function _i(_e, he, Se, ot) {
      if (
        (typeof Se == 'object' &&
          Se !== null &&
          Se.type === G &&
          Se.key === null &&
          (Se = Se.props.children),
        typeof Se == 'object' && Se !== null)
      ) {
        switch (Se.$$typeof) {
          case z:
            e: {
              for (var zt = Se.key, Kt = he; Kt !== null; ) {
                if (Kt.key === zt) {
                  if (((zt = Se.type), zt === G)) {
                    if (Kt.tag === 7) {
                      p(_e, Kt.sibling),
                        (he = w(Kt, Se.props.children)),
                        (he.return = _e),
                        (_e = he);
                      break e;
                    }
                  } else if (
                    Kt.elementType === zt ||
                    (typeof zt == 'object' &&
                      zt !== null &&
                      zt.$$typeof === de &&
                      wd(zt) === Kt.type)
                  ) {
                    p(_e, Kt.sibling),
                      (he = w(Kt, Se.props)),
                      (he.ref = eu(_e, Kt, Se)),
                      (he.return = _e),
                      (_e = he);
                    break e;
                  }
                  p(_e, Kt);
                  break;
                } else l(_e, Kt);
                Kt = Kt.sibling;
              }
              Se.type === G
                ? ((he = yu(Se.props.children, _e.mode, ot, Se.key)), (he.return = _e), (_e = he))
                : ((ot = Op(Se.type, Se.key, Se.props, null, _e.mode, ot)),
                  (ot.ref = eu(_e, he, Se)),
                  (ot.return = _e),
                  (_e = ot));
            }
            return O(_e);
          case N:
            e: {
              for (Kt = Se.key; he !== null; ) {
                if (he.key === Kt)
                  if (
                    he.tag === 4 &&
                    he.stateNode.containerInfo === Se.containerInfo &&
                    he.stateNode.implementation === Se.implementation
                  ) {
                    p(_e, he.sibling), (he = w(he, Se.children || [])), (he.return = _e), (_e = he);
                    break e;
                  } else {
                    p(_e, he);
                    break;
                  }
                else l(_e, he);
                he = he.sibling;
              }
              (he = zv(Se, _e.mode, ot)), (he.return = _e), (_e = he);
            }
            return O(_e);
          case de:
            return (Kt = Se._init), _i(_e, he, Kt(Se._payload), ot);
        }
        if (lt(Se)) return Lt(_e, he, Se, ot);
        if (fe(Se)) return Nt(_e, he, Se, ot);
        tu(_e, Se);
      }
      return (typeof Se == 'string' && Se !== '') || typeof Se == 'number'
        ? ((Se = '' + Se),
          he !== null && he.tag === 6
            ? (p(_e, he.sibling), (he = w(he, Se)), (he.return = _e), (_e = he))
            : (p(_e, he), (he = kv(Se, _e.mode, ot)), (he.return = _e), (_e = he)),
          O(_e))
        : p(_e, he);
    }
    return _i;
  }
  var ua = Cd(!0),
    nu = Cd(!1),
    ca = ii(null),
    fa = null,
    Zs = null,
    el = null;
  function da() {
    el = Zs = fa = null;
  }
  function iu(s) {
    var l = ca.current;
    Wn(ca), (s._currentValue = l);
  }
  function ru(s, l, p) {
    for (; s !== null; ) {
      var _ = s.alternate;
      if (
        ((s.childLanes & l) !== l
          ? ((s.childLanes |= l), _ !== null && (_.childLanes |= l))
          : _ !== null && (_.childLanes & l) !== l && (_.childLanes |= l),
        s === p)
      )
        break;
      s = s.return;
    }
  }
  function bo(s, l) {
    (fa = s),
      (el = Zs = null),
      (s = s.dependencies),
      s !== null && s.firstContext !== null && (s.lanes & l && (mn = !0), (s.firstContext = null));
  }
  function br(s) {
    var l = s._currentValue;
    if (el !== s)
      if (((s = { context: s, memoizedValue: l, next: null }), Zs === null)) {
        if (fa === null) throw Error(t(308));
        (Zs = s), (fa.dependencies = { lanes: 0, firstContext: s });
      } else Zs = Zs.next = s;
    return l;
  }
  var Qs = null;
  function Td(s) {
    Qs === null ? (Qs = [s]) : Qs.push(s);
  }
  function su(s, l, p, _) {
    var w = l.interleaved;
    return (
      w === null ? ((p.next = p), Td(l)) : ((p.next = w.next), (w.next = p)),
      (l.interleaved = p),
      us(s, _)
    );
  }
  function us(s, l) {
    s.lanes |= l;
    var p = s.alternate;
    for (p !== null && (p.lanes |= l), p = s, s = s.return; s !== null; )
      (s.childLanes |= l),
        (p = s.alternate),
        p !== null && (p.childLanes |= l),
        (p = s),
        (s = s.return);
    return p.tag === 3 ? p.stateNode : null;
  }
  var Un = !1;
  function fn(s) {
    s.updateQueue = {
      baseState: s.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function ui(s, l) {
    (s = s.updateQueue),
      l.updateQueue === s &&
        (l.updateQueue = {
          baseState: s.baseState,
          firstBaseUpdate: s.firstBaseUpdate,
          lastBaseUpdate: s.lastBaseUpdate,
          shared: s.shared,
          effects: s.effects,
        });
  }
  function On(s, l) {
    return { eventTime: s, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function Zn(s, l, p) {
    var _ = s.updateQueue;
    if (_ === null) return null;
    if (((_ = _.shared), In & 2)) {
      var w = _.pending;
      return (
        w === null ? (l.next = l) : ((l.next = w.next), (w.next = l)), (_.pending = l), us(s, p)
      );
    }
    return (
      (w = _.interleaved),
      w === null ? ((l.next = l), Td(_)) : ((l.next = w.next), (w.next = l)),
      (_.interleaved = l),
      us(s, p)
    );
  }
  function Gi(s, l, p) {
    if (((l = l.updateQueue), l !== null && ((l = l.shared), (p & 4194240) !== 0))) {
      var _ = l.lanes;
      (_ &= s.pendingLanes), (p |= _), (l.lanes = p), ai(s, p);
    }
  }
  function ha(s, l) {
    var p = s.updateQueue,
      _ = s.alternate;
    if (_ !== null && ((_ = _.updateQueue), p === _)) {
      var w = null,
        R = null;
      if (((p = p.firstBaseUpdate), p !== null)) {
        do {
          var O = {
            eventTime: p.eventTime,
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: p.callback,
            next: null,
          };
          R === null ? (w = R = O) : (R = R.next = O), (p = p.next);
        } while (p !== null);
        R === null ? (w = R = l) : (R = R.next = l);
      } else w = R = l;
      (p = {
        baseState: _.baseState,
        firstBaseUpdate: w,
        lastBaseUpdate: R,
        shared: _.shared,
        effects: _.effects,
      }),
        (s.updateQueue = p);
      return;
    }
    (s = p.lastBaseUpdate),
      s === null ? (p.firstBaseUpdate = l) : (s.next = l),
      (p.lastBaseUpdate = l);
  }
  function ri(s, l, p, _) {
    var w = s.updateQueue;
    Un = !1;
    var R = w.firstBaseUpdate,
      O = w.lastBaseUpdate,
      $ = w.shared.pending;
    if ($ !== null) {
      w.shared.pending = null;
      var ae = $,
        Te = ae.next;
      (ae.next = null), O === null ? (R = Te) : (O.next = Te), (O = ae);
      var $e = s.alternate;
      $e !== null &&
        (($e = $e.updateQueue),
        ($ = $e.lastBaseUpdate),
        $ !== O &&
          ($ === null ? ($e.firstBaseUpdate = Te) : ($.next = Te), ($e.lastBaseUpdate = ae)));
    }
    if (R !== null) {
      var nt = w.baseState;
      (O = 0), ($e = Te = ae = null), ($ = R);
      do {
        var Ke = $.lane,
          Tt = $.eventTime;
        if ((_ & Ke) === Ke) {
          $e !== null &&
            ($e = $e.next =
              {
                eventTime: Tt,
                lane: 0,
                tag: $.tag,
                payload: $.payload,
                callback: $.callback,
                next: null,
              });
          e: {
            var Lt = s,
              Nt = $;
            switch (((Ke = l), (Tt = p), Nt.tag)) {
              case 1:
                if (((Lt = Nt.payload), typeof Lt == 'function')) {
                  nt = Lt.call(Tt, nt, Ke);
                  break e;
                }
                nt = Lt;
                break e;
              case 3:
                Lt.flags = (Lt.flags & -65537) | 128;
              case 0:
                if (
                  ((Lt = Nt.payload),
                  (Ke = typeof Lt == 'function' ? Lt.call(Tt, nt, Ke) : Lt),
                  Ke == null)
                )
                  break e;
                nt = te({}, nt, Ke);
                break e;
              case 2:
                Un = !0;
            }
          }
          $.callback !== null &&
            $.lane !== 0 &&
            ((s.flags |= 64), (Ke = w.effects), Ke === null ? (w.effects = [$]) : Ke.push($));
        } else
          (Tt = {
            eventTime: Tt,
            lane: Ke,
            tag: $.tag,
            payload: $.payload,
            callback: $.callback,
            next: null,
          }),
            $e === null ? ((Te = $e = Tt), (ae = nt)) : ($e = $e.next = Tt),
            (O |= Ke);
        if ((($ = $.next), $ === null)) {
          if ((($ = w.shared.pending), $ === null)) break;
          (Ke = $),
            ($ = Ke.next),
            (Ke.next = null),
            (w.lastBaseUpdate = Ke),
            (w.shared.pending = null);
        }
      } while (!0);
      if (
        ($e === null && (ae = nt),
        (w.baseState = ae),
        (w.firstBaseUpdate = Te),
        (w.lastBaseUpdate = $e),
        (l = w.shared.interleaved),
        l !== null)
      ) {
        w = l;
        do (O |= w.lane), (w = w.next);
        while (w !== l);
      } else R === null && (w.shared.lanes = 0);
      (pu |= O), (s.lanes = O), (s.memoizedState = nt);
    }
  }
  function tl(s, l, p) {
    if (((s = l.effects), (l.effects = null), s !== null))
      for (l = 0; l < s.length; l++) {
        var _ = s[l],
          w = _.callback;
        if (w !== null) {
          if (((_.callback = null), (_ = p), typeof w != 'function')) throw Error(t(191, w));
          w.call(_);
        }
      }
  }
  var ws = {},
    Ir = ii(ws),
    pa = ii(ws),
    qs = ii(ws);
  function di(s) {
    if (s === ws) throw Error(t(174));
    return s;
  }
  function ou(s, l) {
    switch ((kn(qs, l), kn(pa, s), kn(Ir, ws), (s = l.nodeType), s)) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : Ct(null, '');
        break;
      default:
        (s = s === 8 ? l.parentNode : l),
          (l = s.namespaceURI || null),
          (s = s.tagName),
          (l = Ct(l, s));
    }
    Wn(Ir), kn(Ir, l);
  }
  function Io() {
    Wn(Ir), Wn(pa), Wn(qs);
  }
  function ma(s) {
    di(qs.current);
    var l = di(Ir.current),
      p = Ct(l, s.type);
    l !== p && (kn(pa, s), kn(Ir, p));
  }
  function nl(s) {
    pa.current === s && (Wn(Ir), Wn(pa));
  }
  var Yn = ii(0);
  function cs(s) {
    for (var l = s; l !== null; ) {
      if (l.tag === 13) {
        var p = l.memoizedState;
        if (p !== null && ((p = p.dehydrated), p === null || p.data === '$?' || p.data === '$!'))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128) return l;
      } else if (l.child !== null) {
        (l.child.return = l), (l = l.child);
        continue;
      }
      if (l === s) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === s) return null;
        l = l.return;
      }
      (l.sibling.return = l.return), (l = l.sibling);
    }
    return null;
  }
  var il = [];
  function Cs() {
    for (var s = 0; s < il.length; s++) il[s]._workInProgressVersionPrimary = null;
    il.length = 0;
  }
  var ga = B.ReactCurrentDispatcher,
    va = B.ReactCurrentBatchConfig,
    $s = 0,
    Xn = null,
    si = null,
    Tn = null,
    fs = !1,
    Vi = !1,
    Bo = 0,
    pr = 0;
  function Li() {
    throw Error(t(321));
  }
  function au(s, l) {
    if (l === null) return !1;
    for (var p = 0; p < l.length && p < s.length; p++) if (!Cr(s[p], l[p])) return !1;
    return !0;
  }
  function lu(s, l, p, _, w, R) {
    if (
      (($s = R),
      (Xn = l),
      (l.memoizedState = null),
      (l.updateQueue = null),
      (l.lanes = 0),
      (ga.current = s === null || s.memoizedState === null ? Sp : Mp),
      (s = p(_, w)),
      Vi)
    ) {
      R = 0;
      do {
        if (((Vi = !1), (Bo = 0), 25 <= R)) throw Error(t(301));
        (R += 1), (Tn = si = null), (l.updateQueue = null), (ga.current = Ep), (s = p(_, w));
      } while (Vi);
    }
    if (
      ((ga.current = ef),
      (l = si !== null && si.next !== null),
      ($s = 0),
      (Tn = si = Xn = null),
      (fs = !1),
      l)
    )
      throw Error(t(300));
    return s;
  }
  function Rd() {
    var s = Bo !== 0;
    return (Bo = 0), s;
  }
  function Fi() {
    var s = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Tn === null ? (Xn.memoizedState = Tn = s) : (Tn = Tn.next = s), Tn;
  }
  function Br() {
    if (si === null) {
      var s = Xn.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = si.next;
    var l = Tn === null ? Xn.memoizedState : Tn.next;
    if (l !== null) (Tn = l), (si = s);
    else {
      if (s === null) throw Error(t(310));
      (si = s),
        (s = {
          memoizedState: si.memoizedState,
          baseState: si.baseState,
          baseQueue: si.baseQueue,
          queue: si.queue,
          next: null,
        }),
        Tn === null ? (Xn.memoizedState = Tn = s) : (Tn = Tn.next = s);
    }
    return Tn;
  }
  function rl(s, l) {
    return typeof l == 'function' ? l(s) : l;
  }
  function uu(s) {
    var l = Br(),
      p = l.queue;
    if (p === null) throw Error(t(311));
    p.lastRenderedReducer = s;
    var _ = si,
      w = _.baseQueue,
      R = p.pending;
    if (R !== null) {
      if (w !== null) {
        var O = w.next;
        (w.next = R.next), (R.next = O);
      }
      (_.baseQueue = w = R), (p.pending = null);
    }
    if (w !== null) {
      (R = w.next), (_ = _.baseState);
      var $ = (O = null),
        ae = null,
        Te = R;
      do {
        var $e = Te.lane;
        if (($s & $e) === $e)
          ae !== null &&
            (ae = ae.next =
              {
                lane: 0,
                action: Te.action,
                hasEagerState: Te.hasEagerState,
                eagerState: Te.eagerState,
                next: null,
              }),
            (_ = Te.hasEagerState ? Te.eagerState : s(_, Te.action));
        else {
          var nt = {
            lane: $e,
            action: Te.action,
            hasEagerState: Te.hasEagerState,
            eagerState: Te.eagerState,
            next: null,
          };
          ae === null ? (($ = ae = nt), (O = _)) : (ae = ae.next = nt),
            (Xn.lanes |= $e),
            (pu |= $e);
        }
        Te = Te.next;
      } while (Te !== null && Te !== R);
      ae === null ? (O = _) : (ae.next = $),
        Cr(_, l.memoizedState) || (mn = !0),
        (l.memoizedState = _),
        (l.baseState = O),
        (l.baseQueue = ae),
        (p.lastRenderedState = _);
    }
    if (((s = p.interleaved), s !== null)) {
      w = s;
      do (R = w.lane), (Xn.lanes |= R), (pu |= R), (w = w.next);
      while (w !== s);
    } else w === null && (p.lanes = 0);
    return [l.memoizedState, p.dispatch];
  }
  function eo(s) {
    var l = Br(),
      p = l.queue;
    if (p === null) throw Error(t(311));
    p.lastRenderedReducer = s;
    var _ = p.dispatch,
      w = p.pending,
      R = l.memoizedState;
    if (w !== null) {
      p.pending = null;
      var O = (w = w.next);
      do (R = s(R, O.action)), (O = O.next);
      while (O !== w);
      Cr(R, l.memoizedState) || (mn = !0),
        (l.memoizedState = R),
        l.baseQueue === null && (l.baseState = R),
        (p.lastRenderedState = R);
    }
    return [R, _];
  }
  function bd() {}
  function Id(s, l) {
    var p = Xn,
      _ = Br(),
      w = l(),
      R = !Cr(_.memoizedState, w);
    if (
      (R && ((_.memoizedState = w), (mn = !0)),
      (_ = _.queue),
      Dd(gp.bind(null, p, _, s), [s]),
      _.getSnapshot !== l || R || (Tn !== null && Tn.memoizedState.tag & 1))
    ) {
      if (((p.flags |= 2048), ds(9, cu.bind(null, p, _, w, l), void 0, null), Wi === null))
        throw Error(t(349));
      $s & 30 || Kc(p, l, w);
    }
    return w;
  }
  function Kc(s, l, p) {
    (s.flags |= 16384),
      (s = { getSnapshot: l, value: p }),
      (l = Xn.updateQueue),
      l === null
        ? ((l = { lastEffect: null, stores: null }), (Xn.updateQueue = l), (l.stores = [s]))
        : ((p = l.stores), p === null ? (l.stores = [s]) : p.push(s));
  }
  function cu(s, l, p, _) {
    (l.value = p), (l.getSnapshot = _), vp(l) && Bd(s);
  }
  function gp(s, l, p) {
    return p(function () {
      vp(l) && Bd(s);
    });
  }
  function vp(s) {
    var l = s.getSnapshot;
    s = s.value;
    try {
      var p = l();
      return !Cr(s, p);
    } catch {
      return !0;
    }
  }
  function Bd(s) {
    var l = us(s, 1);
    l !== null && so(l, s, 1, -1);
  }
  function Pd(s) {
    var l = Fi();
    return (
      typeof s == 'function' && (s = s()),
      (l.memoizedState = l.baseState = s),
      (s = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: rl,
        lastRenderedState: s,
      }),
      (l.queue = s),
      (s = s.dispatch = ya.bind(null, Xn, s)),
      [l.memoizedState, s]
    );
  }
  function ds(s, l, p, _) {
    return (
      (s = { tag: s, create: l, destroy: p, deps: _, next: null }),
      (l = Xn.updateQueue),
      l === null
        ? ((l = { lastEffect: null, stores: null }),
          (Xn.updateQueue = l),
          (l.lastEffect = s.next = s))
        : ((p = l.lastEffect),
          p === null
            ? (l.lastEffect = s.next = s)
            : ((_ = p.next), (p.next = s), (s.next = _), (l.lastEffect = s))),
      s
    );
  }
  function yp() {
    return Br().memoizedState;
  }
  function Ts(s, l, p, _) {
    var w = Fi();
    (Xn.flags |= s), (w.memoizedState = ds(1 | l, p, void 0, _ === void 0 ? null : _));
  }
  function fu(s, l, p, _) {
    var w = Br();
    _ = _ === void 0 ? null : _;
    var R = void 0;
    if (si !== null) {
      var O = si.memoizedState;
      if (((R = O.destroy), _ !== null && au(_, O.deps))) {
        w.memoizedState = ds(l, p, R, _);
        return;
      }
    }
    (Xn.flags |= s), (w.memoizedState = ds(1 | l, p, R, _));
  }
  function ir(s, l) {
    return Ts(8390656, 8, s, l);
  }
  function Dd(s, l) {
    return fu(2048, 8, s, l);
  }
  function Ld(s, l) {
    return fu(4, 2, s, l);
  }
  function _p(s, l) {
    return fu(4, 4, s, l);
  }
  function xp(s, l) {
    if (typeof l == 'function')
      return (
        (s = s()),
        l(s),
        function () {
          l(null);
        }
      );
    if (l != null)
      return (
        (s = s()),
        (l.current = s),
        function () {
          l.current = null;
        }
      );
  }
  function Fd(s, l, p) {
    return (p = p != null ? p.concat([s]) : null), fu(4, 4, xp.bind(null, l, s), p);
  }
  function jc() {}
  function Ap(s, l) {
    var p = Br();
    l = l === void 0 ? null : l;
    var _ = p.memoizedState;
    return _ !== null && l !== null && au(l, _[1]) ? _[0] : ((p.memoizedState = [s, l]), s);
  }
  function Pr(s, l) {
    var p = Br();
    l = l === void 0 ? null : l;
    var _ = p.memoizedState;
    return _ !== null && l !== null && au(l, _[1])
      ? _[0]
      : ((s = s()), (p.memoizedState = [s, l]), s);
  }
  function Zc(s, l, p) {
    return $s & 21
      ? (Cr(p, l) || ((p = Yt()), (Xn.lanes |= p), (pu |= p), (s.baseState = !0)), l)
      : (s.baseState && ((s.baseState = !1), (mn = !0)), (s.memoizedState = p));
  }
  function Av(s, l) {
    var p = xn;
    (xn = p !== 0 && 4 > p ? p : 4), s(!0);
    var _ = va.transition;
    va.transition = {};
    try {
      s(!1), l();
    } finally {
      (xn = p), (va.transition = _);
    }
  }
  function to() {
    return Br().memoizedState;
  }
  function Qc(s, l, p) {
    var _ = ll(s);
    if (((p = { lane: _, action: p, hasEagerState: !1, eagerState: null, next: null }), du(s)))
      qc(l, p);
    else if (((p = su(s, l, p, _)), p !== null)) {
      var w = Lr();
      so(p, s, _, w), $c(p, l, _);
    }
  }
  function ya(s, l, p) {
    var _ = ll(s),
      w = { lane: _, action: p, hasEagerState: !1, eagerState: null, next: null };
    if (du(s)) qc(l, w);
    else {
      var R = s.alternate;
      if (
        s.lanes === 0 &&
        (R === null || R.lanes === 0) &&
        ((R = l.lastRenderedReducer), R !== null)
      )
        try {
          var O = l.lastRenderedState,
            $ = R(O, p);
          if (((w.hasEagerState = !0), (w.eagerState = $), Cr($, O))) {
            var ae = l.interleaved;
            ae === null ? ((w.next = w), Td(l)) : ((w.next = ae.next), (ae.next = w)),
              (l.interleaved = w);
            return;
          }
        } catch {
        } finally {
        }
      (p = su(s, l, w, _)), p !== null && ((w = Lr()), so(p, s, _, w), $c(p, l, _));
    }
  }
  function du(s) {
    var l = s.alternate;
    return s === Xn || (l !== null && l === Xn);
  }
  function qc(s, l) {
    Vi = fs = !0;
    var p = s.pending;
    p === null ? (l.next = l) : ((l.next = p.next), (p.next = l)), (s.pending = l);
  }
  function $c(s, l, p) {
    if (p & 4194240) {
      var _ = l.lanes;
      (_ &= s.pendingLanes), (p |= _), (l.lanes = p), ai(s, p);
    }
  }
  var ef = {
      readContext: br,
      useCallback: Li,
      useContext: Li,
      useEffect: Li,
      useImperativeHandle: Li,
      useInsertionEffect: Li,
      useLayoutEffect: Li,
      useMemo: Li,
      useReducer: Li,
      useRef: Li,
      useState: Li,
      useDebugValue: Li,
      useDeferredValue: Li,
      useTransition: Li,
      useMutableSource: Li,
      useSyncExternalStore: Li,
      useId: Li,
      unstable_isNewReconciler: !1,
    },
    Sp = {
      readContext: br,
      useCallback: function (s, l) {
        return (Fi().memoizedState = [s, l === void 0 ? null : l]), s;
      },
      useContext: br,
      useEffect: ir,
      useImperativeHandle: function (s, l, p) {
        return (p = p != null ? p.concat([s]) : null), Ts(4194308, 4, xp.bind(null, l, s), p);
      },
      useLayoutEffect: function (s, l) {
        return Ts(4194308, 4, s, l);
      },
      useInsertionEffect: function (s, l) {
        return Ts(4, 2, s, l);
      },
      useMemo: function (s, l) {
        var p = Fi();
        return (l = l === void 0 ? null : l), (s = s()), (p.memoizedState = [s, l]), s;
      },
      useReducer: function (s, l, p) {
        var _ = Fi();
        return (
          (l = p !== void 0 ? p(l) : l),
          (_.memoizedState = _.baseState = l),
          (s = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: l,
          }),
          (_.queue = s),
          (s = s.dispatch = Qc.bind(null, Xn, s)),
          [_.memoizedState, s]
        );
      },
      useRef: function (s) {
        var l = Fi();
        return (s = { current: s }), (l.memoizedState = s);
      },
      useState: Pd,
      useDebugValue: jc,
      useDeferredValue: function (s) {
        return (Fi().memoizedState = s);
      },
      useTransition: function () {
        var s = Pd(!1),
          l = s[0];
        return (s = Av.bind(null, s[1])), (Fi().memoizedState = s), [l, s];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (s, l, p) {
        var _ = Xn,
          w = Fi();
        if (Jn) {
          if (p === void 0) throw Error(t(407));
          p = p();
        } else {
          if (((p = l()), Wi === null)) throw Error(t(349));
          $s & 30 || Kc(_, l, p);
        }
        w.memoizedState = p;
        var R = { value: p, getSnapshot: l };
        return (
          (w.queue = R),
          ir(gp.bind(null, _, R, s), [s]),
          (_.flags |= 2048),
          ds(9, cu.bind(null, _, R, p, l), void 0, null),
          p
        );
      },
      useId: function () {
        var s = Fi(),
          l = Wi.identifierPrefix;
        if (Jn) {
          var p = Xr,
            _ = ct;
          (p = (_ & ~(1 << (32 - gt(_) - 1))).toString(32) + p),
            (l = ':' + l + 'R' + p),
            (p = Bo++),
            0 < p && (l += 'H' + p.toString(32)),
            (l += ':');
        } else (p = pr++), (l = ':' + l + 'r' + p.toString(32) + ':');
        return (s.memoizedState = l);
      },
      unstable_isNewReconciler: !1,
    },
    Mp = {
      readContext: br,
      useCallback: Ap,
      useContext: br,
      useEffect: Dd,
      useImperativeHandle: Fd,
      useInsertionEffect: Ld,
      useLayoutEffect: _p,
      useMemo: Pr,
      useReducer: uu,
      useRef: yp,
      useState: function () {
        return uu(rl);
      },
      useDebugValue: jc,
      useDeferredValue: function (s) {
        var l = Br();
        return Zc(l, si.memoizedState, s);
      },
      useTransition: function () {
        var s = uu(rl)[0],
          l = Br().memoizedState;
        return [s, l];
      },
      useMutableSource: bd,
      useSyncExternalStore: Id,
      useId: to,
      unstable_isNewReconciler: !1,
    },
    Ep = {
      readContext: br,
      useCallback: Ap,
      useContext: br,
      useEffect: Dd,
      useImperativeHandle: Fd,
      useInsertionEffect: Ld,
      useLayoutEffect: _p,
      useMemo: Pr,
      useReducer: eo,
      useRef: yp,
      useState: function () {
        return eo(rl);
      },
      useDebugValue: jc,
      useDeferredValue: function (s) {
        var l = Br();
        return si === null ? (l.memoizedState = s) : Zc(l, si.memoizedState, s);
      },
      useTransition: function () {
        var s = eo(rl)[0],
          l = Br().memoizedState;
        return [s, l];
      },
      useMutableSource: bd,
      useSyncExternalStore: Id,
      useId: to,
      unstable_isNewReconciler: !1,
    };
  function Yr(s, l) {
    if (s && s.defaultProps) {
      (l = te({}, l)), (s = s.defaultProps);
      for (var p in s) l[p] === void 0 && (l[p] = s[p]);
      return l;
    }
    return l;
  }
  function hu(s, l, p, _) {
    (l = s.memoizedState),
      (p = p(_, l)),
      (p = p == null ? l : te({}, l, p)),
      (s.memoizedState = p),
      s.lanes === 0 && (s.updateQueue.baseState = p);
  }
  var tf = {
    isMounted: function (s) {
      return (s = s._reactInternals) ? W(s) === s : !1;
    },
    enqueueSetState: function (s, l, p) {
      s = s._reactInternals;
      var _ = Lr(),
        w = ll(s),
        R = On(_, w);
      (R.payload = l),
        p != null && (R.callback = p),
        (l = Zn(s, R, w)),
        l !== null && (so(l, s, w, _), Gi(l, s, w));
    },
    enqueueReplaceState: function (s, l, p) {
      s = s._reactInternals;
      var _ = Lr(),
        w = ll(s),
        R = On(_, w);
      (R.tag = 1),
        (R.payload = l),
        p != null && (R.callback = p),
        (l = Zn(s, R, w)),
        l !== null && (so(l, s, w, _), Gi(l, s, w));
    },
    enqueueForceUpdate: function (s, l) {
      s = s._reactInternals;
      var p = Lr(),
        _ = ll(s),
        w = On(p, _);
      (w.tag = 2),
        l != null && (w.callback = l),
        (l = Zn(s, w, _)),
        l !== null && (so(l, s, _, p), Gi(l, s, _));
    },
  };
  function wp(s, l, p, _, w, R, O) {
    return (
      (s = s.stateNode),
      typeof s.shouldComponentUpdate == 'function'
        ? s.shouldComponentUpdate(_, R, O)
        : l.prototype && l.prototype.isPureReactComponent
        ? !$o(p, _) || !$o(w, R)
        : !0
    );
  }
  function c(s, l, p) {
    var _ = !1,
      w = Js,
      R = l.contextType;
    return (
      typeof R == 'object' && R !== null
        ? (R = br(R))
        : ((w = Hi(l) ? Ys : Pi.current),
          (_ = l.contextTypes),
          (R = (_ = _ != null) ? sa(s, w) : Js)),
      (l = new l(p, R)),
      (s.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null),
      (l.updater = tf),
      (s.stateNode = l),
      (l._reactInternals = s),
      _ &&
        ((s = s.stateNode),
        (s.__reactInternalMemoizedUnmaskedChildContext = w),
        (s.__reactInternalMemoizedMaskedChildContext = R)),
      l
    );
  }
  function f(s, l, p, _) {
    (s = l.state),
      typeof l.componentWillReceiveProps == 'function' && l.componentWillReceiveProps(p, _),
      typeof l.UNSAFE_componentWillReceiveProps == 'function' &&
        l.UNSAFE_componentWillReceiveProps(p, _),
      l.state !== s && tf.enqueueReplaceState(l, l.state, null);
  }
  function y(s, l, p, _) {
    var w = s.stateNode;
    (w.props = p), (w.state = s.memoizedState), (w.refs = {}), fn(s);
    var R = l.contextType;
    typeof R == 'object' && R !== null
      ? (w.context = br(R))
      : ((R = Hi(l) ? Ys : Pi.current), (w.context = sa(s, R))),
      (w.state = s.memoizedState),
      (R = l.getDerivedStateFromProps),
      typeof R == 'function' && (hu(s, l, R, p), (w.state = s.memoizedState)),
      typeof l.getDerivedStateFromProps == 'function' ||
        typeof w.getSnapshotBeforeUpdate == 'function' ||
        (typeof w.UNSAFE_componentWillMount != 'function' &&
          typeof w.componentWillMount != 'function') ||
        ((l = w.state),
        typeof w.componentWillMount == 'function' && w.componentWillMount(),
        typeof w.UNSAFE_componentWillMount == 'function' && w.UNSAFE_componentWillMount(),
        l !== w.state && tf.enqueueReplaceState(w, w.state, null),
        ri(s, p, w, _),
        (w.state = s.memoizedState)),
      typeof w.componentDidMount == 'function' && (s.flags |= 4194308);
  }
  function M(s, l) {
    try {
      var p = '',
        _ = l;
      do (p += De(_)), (_ = _.return);
      while (_);
      var w = p;
    } catch (R) {
      w =
        `
Error generating stack: ` +
        R.message +
        `
` +
        R.stack;
    }
    return { value: s, source: l, stack: w, digest: null };
  }
  function T(s, l, p) {
    return { value: s, source: null, stack: p ?? null, digest: l ?? null };
  }
  function P(s, l) {
    try {
      console.error(l.value);
    } catch (p) {
      setTimeout(function () {
        throw p;
      });
    }
  }
  var Z = typeof WeakMap == 'function' ? WeakMap : Map;
  function pe(s, l, p) {
    (p = On(-1, p)), (p.tag = 3), (p.payload = { element: null });
    var _ = l.value;
    return (
      (p.callback = function () {
        Pp || ((Pp = !0), (Bv = _)), P(s, l);
      }),
      p
    );
  }
  function Ne(s, l, p) {
    (p = On(-1, p)), (p.tag = 3);
    var _ = s.type.getDerivedStateFromError;
    if (typeof _ == 'function') {
      var w = l.value;
      (p.payload = function () {
        return _(w);
      }),
        (p.callback = function () {
          P(s, l);
        });
    }
    var R = s.stateNode;
    return (
      R !== null &&
        typeof R.componentDidCatch == 'function' &&
        (p.callback = function () {
          P(s, l), typeof _ != 'function' && (ol === null ? (ol = new Set([this])) : ol.add(this));
          var O = l.stack;
          this.componentDidCatch(l.value, { componentStack: O !== null ? O : '' });
        }),
      p
    );
  }
  function st(s, l, p) {
    var _ = s.pingCache;
    if (_ === null) {
      _ = s.pingCache = new Z();
      var w = new Set();
      _.set(l, w);
    } else (w = _.get(l)), w === void 0 && ((w = new Set()), _.set(l, w));
    w.has(p) || (w.add(p), (s = v1.bind(null, s, l, p)), l.then(s, s));
  }
  function bt(s) {
    do {
      var l;
      if (
        ((l = s.tag === 13) &&
          ((l = s.memoizedState), (l = l !== null ? l.dehydrated !== null : !0)),
        l)
      )
        return s;
      s = s.return;
    } while (s !== null);
    return null;
  }
  function rn(s, l, p, _, w) {
    return s.mode & 1
      ? ((s.flags |= 65536), (s.lanes = w), s)
      : (s === l
          ? (s.flags |= 65536)
          : ((s.flags |= 128),
            (p.flags |= 131072),
            (p.flags &= -52805),
            p.tag === 1 &&
              (p.alternate === null ? (p.tag = 17) : ((l = On(-1, 1)), (l.tag = 2), Zn(p, l, 1))),
            (p.lanes |= 1)),
        s);
  }
  var Xt = B.ReactCurrentOwner,
    mn = !1;
  function Et(s, l, p, _) {
    l.child = s === null ? nu(l, null, p, _) : ua(l, s.child, p, _);
  }
  function Ni(s, l, p, _, w) {
    p = p.render;
    var R = l.ref;
    return (
      bo(l, w),
      (_ = lu(s, l, p, _, R, w)),
      (p = Rd()),
      s !== null && !mn
        ? ((l.updateQueue = s.updateQueue), (l.flags &= -2053), (s.lanes &= ~w), _a(s, l, w))
        : (Jn && p && Ad(l), (l.flags |= 1), Et(s, l, _, w), l.child)
    );
  }
  function Dr(s, l, p, _, w) {
    if (s === null) {
      var R = p.type;
      return typeof R == 'function' &&
        !Ov(R) &&
        R.defaultProps === void 0 &&
        p.compare === null &&
        p.defaultProps === void 0
        ? ((l.tag = 15), (l.type = R), Me(s, l, R, _, w))
        : ((s = Op(p.type, null, _, l, l.mode, w)), (s.ref = l.ref), (s.return = l), (l.child = s));
    }
    if (((R = s.child), !(s.lanes & w))) {
      var O = R.memoizedProps;
      if (((p = p.compare), (p = p !== null ? p : $o), p(O, _) && s.ref === l.ref))
        return _a(s, l, w);
    }
    return (l.flags |= 1), (s = cl(R, _)), (s.ref = l.ref), (s.return = l), (l.child = s);
  }
  function Me(s, l, p, _, w) {
    if (s !== null) {
      var R = s.memoizedProps;
      if ($o(R, _) && s.ref === l.ref)
        if (((mn = !1), (l.pendingProps = _ = R), (s.lanes & w) !== 0))
          s.flags & 131072 && (mn = !0);
        else return (l.lanes = s.lanes), _a(s, l, w);
    }
    return _t(s, l, p, _, w);
  }
  function me(s, l, p) {
    var _ = l.pendingProps,
      w = _.children,
      R = s !== null ? s.memoizedState : null;
    if (_.mode === 'hidden')
      if (!(l.mode & 1))
        (l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
          kn(rf, hs),
          (hs |= p);
      else {
        if (!(p & 1073741824))
          return (
            (s = R !== null ? R.baseLanes | p : p),
            (l.lanes = l.childLanes = 1073741824),
            (l.memoizedState = { baseLanes: s, cachePool: null, transitions: null }),
            (l.updateQueue = null),
            kn(rf, hs),
            (hs |= s),
            null
          );
        (l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
          (_ = R !== null ? R.baseLanes : p),
          kn(rf, hs),
          (hs |= _);
      }
    else
      R !== null ? ((_ = R.baseLanes | p), (l.memoizedState = null)) : (_ = p),
        kn(rf, hs),
        (hs |= _);
    return Et(s, l, w, p), l.child;
  }
  function be(s, l) {
    var p = l.ref;
    ((s === null && p !== null) || (s !== null && s.ref !== p)) &&
      ((l.flags |= 512), (l.flags |= 2097152));
  }
  function _t(s, l, p, _, w) {
    var R = Hi(p) ? Ys : Pi.current;
    return (
      (R = sa(l, R)),
      bo(l, w),
      (p = lu(s, l, p, _, R, w)),
      (_ = Rd()),
      s !== null && !mn
        ? ((l.updateQueue = s.updateQueue), (l.flags &= -2053), (s.lanes &= ~w), _a(s, l, w))
        : (Jn && _ && Ad(l), (l.flags |= 1), Et(s, l, p, w), l.child)
    );
  }
  function Ot(s, l, p, _, w) {
    if (Hi(p)) {
      var R = !0;
      oa(l);
    } else R = !1;
    if ((bo(l, w), l.stateNode === null)) Tp(s, l), c(l, p, _), y(l, p, _, w), (_ = !0);
    else if (s === null) {
      var O = l.stateNode,
        $ = l.memoizedProps;
      O.props = $;
      var ae = O.context,
        Te = p.contextType;
      typeof Te == 'object' && Te !== null
        ? (Te = br(Te))
        : ((Te = Hi(p) ? Ys : Pi.current), (Te = sa(l, Te)));
      var $e = p.getDerivedStateFromProps,
        nt = typeof $e == 'function' || typeof O.getSnapshotBeforeUpdate == 'function';
      nt ||
        (typeof O.UNSAFE_componentWillReceiveProps != 'function' &&
          typeof O.componentWillReceiveProps != 'function') ||
        (($ !== _ || ae !== Te) && f(l, O, _, Te)),
        (Un = !1);
      var Ke = l.memoizedState;
      (O.state = Ke),
        ri(l, _, O, w),
        (ae = l.memoizedState),
        $ !== _ || Ke !== ae || er.current || Un
          ? (typeof $e == 'function' && (hu(l, p, $e, _), (ae = l.memoizedState)),
            ($ = Un || wp(l, p, $, _, Ke, ae, Te))
              ? (nt ||
                  (typeof O.UNSAFE_componentWillMount != 'function' &&
                    typeof O.componentWillMount != 'function') ||
                  (typeof O.componentWillMount == 'function' && O.componentWillMount(),
                  typeof O.UNSAFE_componentWillMount == 'function' &&
                    O.UNSAFE_componentWillMount()),
                typeof O.componentDidMount == 'function' && (l.flags |= 4194308))
              : (typeof O.componentDidMount == 'function' && (l.flags |= 4194308),
                (l.memoizedProps = _),
                (l.memoizedState = ae)),
            (O.props = _),
            (O.state = ae),
            (O.context = Te),
            (_ = $))
          : (typeof O.componentDidMount == 'function' && (l.flags |= 4194308), (_ = !1));
    } else {
      (O = l.stateNode),
        ui(s, l),
        ($ = l.memoizedProps),
        (Te = l.type === l.elementType ? $ : Yr(l.type, $)),
        (O.props = Te),
        (nt = l.pendingProps),
        (Ke = O.context),
        (ae = p.contextType),
        typeof ae == 'object' && ae !== null
          ? (ae = br(ae))
          : ((ae = Hi(p) ? Ys : Pi.current), (ae = sa(l, ae)));
      var Tt = p.getDerivedStateFromProps;
      ($e = typeof Tt == 'function' || typeof O.getSnapshotBeforeUpdate == 'function') ||
        (typeof O.UNSAFE_componentWillReceiveProps != 'function' &&
          typeof O.componentWillReceiveProps != 'function') ||
        (($ !== nt || Ke !== ae) && f(l, O, _, ae)),
        (Un = !1),
        (Ke = l.memoizedState),
        (O.state = Ke),
        ri(l, _, O, w);
      var Lt = l.memoizedState;
      $ !== nt || Ke !== Lt || er.current || Un
        ? (typeof Tt == 'function' && (hu(l, p, Tt, _), (Lt = l.memoizedState)),
          (Te = Un || wp(l, p, Te, _, Ke, Lt, ae) || !1)
            ? ($e ||
                (typeof O.UNSAFE_componentWillUpdate != 'function' &&
                  typeof O.componentWillUpdate != 'function') ||
                (typeof O.componentWillUpdate == 'function' && O.componentWillUpdate(_, Lt, ae),
                typeof O.UNSAFE_componentWillUpdate == 'function' &&
                  O.UNSAFE_componentWillUpdate(_, Lt, ae)),
              typeof O.componentDidUpdate == 'function' && (l.flags |= 4),
              typeof O.getSnapshotBeforeUpdate == 'function' && (l.flags |= 1024))
            : (typeof O.componentDidUpdate != 'function' ||
                ($ === s.memoizedProps && Ke === s.memoizedState) ||
                (l.flags |= 4),
              typeof O.getSnapshotBeforeUpdate != 'function' ||
                ($ === s.memoizedProps && Ke === s.memoizedState) ||
                (l.flags |= 1024),
              (l.memoizedProps = _),
              (l.memoizedState = Lt)),
          (O.props = _),
          (O.state = Lt),
          (O.context = ae),
          (_ = Te))
        : (typeof O.componentDidUpdate != 'function' ||
            ($ === s.memoizedProps && Ke === s.memoizedState) ||
            (l.flags |= 4),
          typeof O.getSnapshotBeforeUpdate != 'function' ||
            ($ === s.memoizedProps && Ke === s.memoizedState) ||
            (l.flags |= 1024),
          (_ = !1));
    }
    return ln(s, l, p, _, R, w);
  }
  function ln(s, l, p, _, w, R) {
    be(s, l);
    var O = (l.flags & 128) !== 0;
    if (!_ && !O) return w && _d(l, p, !1), _a(s, l, R);
    (_ = l.stateNode), (Xt.current = l);
    var $ = O && typeof p.getDerivedStateFromError != 'function' ? null : _.render();
    return (
      (l.flags |= 1),
      s !== null && O
        ? ((l.child = ua(l, s.child, null, R)), (l.child = ua(l, null, $, R)))
        : Et(s, l, $, R),
      (l.memoizedState = _.state),
      w && _d(l, p, !0),
      l.child
    );
  }
  function sn(s) {
    var l = s.stateNode;
    l.pendingContext
      ? yd(s, l.pendingContext, l.pendingContext !== l.context)
      : l.context && yd(s, l.context, !1),
      ou(s, l.containerInfo);
  }
  function En(s, l, p, _, w) {
    return Ro(), $a(w), (l.flags |= 256), Et(s, l, p, _), l.child;
  }
  var hi = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Mn(s) {
    return { baseLanes: s, cachePool: null, transitions: null };
  }
  function no(s, l, p) {
    var _ = l.pendingProps,
      w = Yn.current,
      R = !1,
      O = (l.flags & 128) !== 0,
      $;
    if (
      (($ = O) || ($ = s !== null && s.memoizedState === null ? !1 : (w & 2) !== 0),
      $ ? ((R = !0), (l.flags &= -129)) : (s === null || s.memoizedState !== null) && (w |= 1),
      kn(Yn, w & 1),
      s === null)
    )
      return (
        Jc(l),
        (s = l.memoizedState),
        s !== null && ((s = s.dehydrated), s !== null)
          ? (l.mode & 1
              ? s.data === '$!'
                ? (l.lanes = 8)
                : (l.lanes = 1073741824)
              : (l.lanes = 1),
            null)
          : ((O = _.children),
            (s = _.fallback),
            R
              ? ((_ = l.mode),
                (R = l.child),
                (O = { mode: 'hidden', children: O }),
                !(_ & 1) && R !== null
                  ? ((R.childLanes = 0), (R.pendingProps = O))
                  : (R = kp(O, _, 0, null)),
                (s = yu(s, _, p, null)),
                (R.return = l),
                (s.return = l),
                (R.sibling = s),
                (l.child = R),
                (l.child.memoizedState = Mn(p)),
                (l.memoizedState = hi),
                s)
              : Nd(l, O))
      );
    if (((w = s.memoizedState), w !== null && (($ = w.dehydrated), $ !== null)))
      return s1(s, l, O, _, $, w, p);
    if (R) {
      (R = _.fallback), (O = l.mode), (w = s.child), ($ = w.sibling);
      var ae = { mode: 'hidden', children: _.children };
      return (
        !(O & 1) && l.child !== w
          ? ((_ = l.child), (_.childLanes = 0), (_.pendingProps = ae), (l.deletions = null))
          : ((_ = cl(w, ae)), (_.subtreeFlags = w.subtreeFlags & 14680064)),
        $ !== null ? (R = cl($, R)) : ((R = yu(R, O, p, null)), (R.flags |= 2)),
        (R.return = l),
        (_.return = l),
        (_.sibling = R),
        (l.child = _),
        (_ = R),
        (R = l.child),
        (O = s.child.memoizedState),
        (O =
          O === null
            ? Mn(p)
            : { baseLanes: O.baseLanes | p, cachePool: null, transitions: O.transitions }),
        (R.memoizedState = O),
        (R.childLanes = s.childLanes & ~p),
        (l.memoizedState = hi),
        _
      );
    }
    return (
      (R = s.child),
      (s = R.sibling),
      (_ = cl(R, { mode: 'visible', children: _.children })),
      !(l.mode & 1) && (_.lanes = p),
      (_.return = l),
      (_.sibling = null),
      s !== null &&
        ((p = l.deletions), p === null ? ((l.deletions = [s]), (l.flags |= 16)) : p.push(s)),
      (l.child = _),
      (l.memoizedState = null),
      _
    );
  }
  function Nd(s, l) {
    return (
      (l = kp({ mode: 'visible', children: l }, s.mode, 0, null)), (l.return = s), (s.child = l)
    );
  }
  function Cp(s, l, p, _) {
    return (
      _ !== null && $a(_),
      ua(l, s.child, null, p),
      (s = Nd(l, l.pendingProps.children)),
      (s.flags |= 2),
      (l.memoizedState = null),
      s
    );
  }
  function s1(s, l, p, _, w, R, O) {
    if (p)
      return l.flags & 256
        ? ((l.flags &= -257), (_ = T(Error(t(422)))), Cp(s, l, O, _))
        : l.memoizedState !== null
        ? ((l.child = s.child), (l.flags |= 128), null)
        : ((R = _.fallback),
          (w = l.mode),
          (_ = kp({ mode: 'visible', children: _.children }, w, 0, null)),
          (R = yu(R, w, O, null)),
          (R.flags |= 2),
          (_.return = l),
          (R.return = l),
          (_.sibling = R),
          (l.child = _),
          l.mode & 1 && ua(l, s.child, null, O),
          (l.child.memoizedState = Mn(O)),
          (l.memoizedState = hi),
          R);
    if (!(l.mode & 1)) return Cp(s, l, O, null);
    if (w.data === '$!') {
      if (((_ = w.nextSibling && w.nextSibling.dataset), _)) var $ = _.dgst;
      return (_ = $), (R = Error(t(419))), (_ = T(R, _, void 0)), Cp(s, l, O, _);
    }
    if ((($ = (O & s.childLanes) !== 0), mn || $)) {
      if (((_ = Wi), _ !== null)) {
        switch (O & -O) {
          case 4:
            w = 2;
            break;
          case 16:
            w = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            w = 32;
            break;
          case 536870912:
            w = 268435456;
            break;
          default:
            w = 0;
        }
        (w = w & (_.suspendedLanes | O) ? 0 : w),
          w !== 0 && w !== R.retryLane && ((R.retryLane = w), us(s, w), so(_, s, w, -1));
      }
      return Uv(), (_ = T(Error(t(421)))), Cp(s, l, O, _);
    }
    return w.data === '$?'
      ? ((l.flags |= 128), (l.child = s.child), (l = y1.bind(null, s)), (w._reactRetry = l), null)
      : ((s = R.treeContext),
        (nr = Ws(w.nextSibling)),
        (Di = l),
        (Jn = !0),
        (Jr = null),
        s !== null &&
          ((tr[Ti++] = ct),
          (tr[Ti++] = Xr),
          (tr[Ti++] = la),
          (ct = s.id),
          (Xr = s.overflow),
          (la = l)),
        (l = Nd(l, _.children)),
        (l.flags |= 4096),
        l);
  }
  function D_(s, l, p) {
    s.lanes |= l;
    var _ = s.alternate;
    _ !== null && (_.lanes |= l), ru(s.return, l, p);
  }
  function Sv(s, l, p, _, w) {
    var R = s.memoizedState;
    R === null
      ? (s.memoizedState = {
          isBackwards: l,
          rendering: null,
          renderingStartTime: 0,
          last: _,
          tail: p,
          tailMode: w,
        })
      : ((R.isBackwards = l),
        (R.rendering = null),
        (R.renderingStartTime = 0),
        (R.last = _),
        (R.tail = p),
        (R.tailMode = w));
  }
  function L_(s, l, p) {
    var _ = l.pendingProps,
      w = _.revealOrder,
      R = _.tail;
    if ((Et(s, l, _.children, p), (_ = Yn.current), _ & 2)) (_ = (_ & 1) | 2), (l.flags |= 128);
    else {
      if (s !== null && s.flags & 128)
        e: for (s = l.child; s !== null; ) {
          if (s.tag === 13) s.memoizedState !== null && D_(s, p, l);
          else if (s.tag === 19) D_(s, p, l);
          else if (s.child !== null) {
            (s.child.return = s), (s = s.child);
            continue;
          }
          if (s === l) break e;
          for (; s.sibling === null; ) {
            if (s.return === null || s.return === l) break e;
            s = s.return;
          }
          (s.sibling.return = s.return), (s = s.sibling);
        }
      _ &= 1;
    }
    if ((kn(Yn, _), !(l.mode & 1))) l.memoizedState = null;
    else
      switch (w) {
        case 'forwards':
          for (p = l.child, w = null; p !== null; )
            (s = p.alternate), s !== null && cs(s) === null && (w = p), (p = p.sibling);
          (p = w),
            p === null ? ((w = l.child), (l.child = null)) : ((w = p.sibling), (p.sibling = null)),
            Sv(l, !1, w, p, R);
          break;
        case 'backwards':
          for (p = null, w = l.child, l.child = null; w !== null; ) {
            if (((s = w.alternate), s !== null && cs(s) === null)) {
              l.child = w;
              break;
            }
            (s = w.sibling), (w.sibling = p), (p = w), (w = s);
          }
          Sv(l, !0, p, null, R);
          break;
        case 'together':
          Sv(l, !1, null, null, void 0);
          break;
        default:
          l.memoizedState = null;
      }
    return l.child;
  }
  function Tp(s, l) {
    !(l.mode & 1) && s !== null && ((s.alternate = null), (l.alternate = null), (l.flags |= 2));
  }
  function _a(s, l, p) {
    if ((s !== null && (l.dependencies = s.dependencies), (pu |= l.lanes), !(p & l.childLanes)))
      return null;
    if (s !== null && l.child !== s.child) throw Error(t(153));
    if (l.child !== null) {
      for (s = l.child, p = cl(s, s.pendingProps), l.child = p, p.return = l; s.sibling !== null; )
        (s = s.sibling), (p = p.sibling = cl(s, s.pendingProps)), (p.return = l);
      p.sibling = null;
    }
    return l.child;
  }
  function o1(s, l, p) {
    switch (l.tag) {
      case 3:
        sn(l), Ro();
        break;
      case 5:
        ma(l);
        break;
      case 1:
        Hi(l.type) && oa(l);
        break;
      case 4:
        ou(l, l.stateNode.containerInfo);
        break;
      case 10:
        var _ = l.type._context,
          w = l.memoizedProps.value;
        kn(ca, _._currentValue), (_._currentValue = w);
        break;
      case 13:
        if (((_ = l.memoizedState), _ !== null))
          return _.dehydrated !== null
            ? (kn(Yn, Yn.current & 1), (l.flags |= 128), null)
            : p & l.child.childLanes
            ? no(s, l, p)
            : (kn(Yn, Yn.current & 1), (s = _a(s, l, p)), s !== null ? s.sibling : null);
        kn(Yn, Yn.current & 1);
        break;
      case 19:
        if (((_ = (p & l.childLanes) !== 0), s.flags & 128)) {
          if (_) return L_(s, l, p);
          l.flags |= 128;
        }
        if (
          ((w = l.memoizedState),
          w !== null && ((w.rendering = null), (w.tail = null), (w.lastEffect = null)),
          kn(Yn, Yn.current),
          _)
        )
          break;
        return null;
      case 22:
      case 23:
        return (l.lanes = 0), me(s, l, p);
    }
    return _a(s, l, p);
  }
  var F_, Mv, N_, U_;
  (F_ = function (s, l) {
    for (var p = l.child; p !== null; ) {
      if (p.tag === 5 || p.tag === 6) s.appendChild(p.stateNode);
      else if (p.tag !== 4 && p.child !== null) {
        (p.child.return = p), (p = p.child);
        continue;
      }
      if (p === l) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === l) return;
        p = p.return;
      }
      (p.sibling.return = p.return), (p = p.sibling);
    }
  }),
    (Mv = function () {}),
    (N_ = function (s, l, p, _) {
      var w = s.memoizedProps;
      if (w !== _) {
        (s = l.stateNode), di(Ir.current);
        var R = null;
        switch (p) {
          case 'input':
            (w = j(s, w)), (_ = j(s, _)), (R = []);
            break;
          case 'select':
            (w = te({}, w, { value: void 0 })), (_ = te({}, _, { value: void 0 })), (R = []);
            break;
          case 'textarea':
            (w = H(s, w)), (_ = H(s, _)), (R = []);
            break;
          default:
            typeof w.onClick != 'function' && typeof _.onClick == 'function' && (s.onclick = jl);
        }
        re(p, _);
        var O;
        p = null;
        for (Te in w)
          if (!_.hasOwnProperty(Te) && w.hasOwnProperty(Te) && w[Te] != null)
            if (Te === 'style') {
              var $ = w[Te];
              for (O in $) $.hasOwnProperty(O) && (p || (p = {}), (p[O] = ''));
            } else
              Te !== 'dangerouslySetInnerHTML' &&
                Te !== 'children' &&
                Te !== 'suppressContentEditableWarning' &&
                Te !== 'suppressHydrationWarning' &&
                Te !== 'autoFocus' &&
                (i.hasOwnProperty(Te) ? R || (R = []) : (R = R || []).push(Te, null));
        for (Te in _) {
          var ae = _[Te];
          if (
            (($ = w != null ? w[Te] : void 0),
            _.hasOwnProperty(Te) && ae !== $ && (ae != null || $ != null))
          )
            if (Te === 'style')
              if ($) {
                for (O in $)
                  !$.hasOwnProperty(O) ||
                    (ae && ae.hasOwnProperty(O)) ||
                    (p || (p = {}), (p[O] = ''));
                for (O in ae)
                  ae.hasOwnProperty(O) && $[O] !== ae[O] && (p || (p = {}), (p[O] = ae[O]));
              } else p || (R || (R = []), R.push(Te, p)), (p = ae);
            else
              Te === 'dangerouslySetInnerHTML'
                ? ((ae = ae ? ae.__html : void 0),
                  ($ = $ ? $.__html : void 0),
                  ae != null && $ !== ae && (R = R || []).push(Te, ae))
                : Te === 'children'
                ? (typeof ae != 'string' && typeof ae != 'number') ||
                  (R = R || []).push(Te, '' + ae)
                : Te !== 'suppressContentEditableWarning' &&
                  Te !== 'suppressHydrationWarning' &&
                  (i.hasOwnProperty(Te)
                    ? (ae != null && Te === 'onScroll' && Vn('scroll', s),
                      R || $ === ae || (R = []))
                    : (R = R || []).push(Te, ae));
        }
        p && (R = R || []).push('style', p);
        var Te = R;
        (l.updateQueue = Te) && (l.flags |= 4);
      }
    }),
    (U_ = function (s, l, p, _) {
      p !== _ && (l.flags |= 4);
    });
  function Ud(s, l) {
    if (!Jn)
      switch (s.tailMode) {
        case 'hidden':
          l = s.tail;
          for (var p = null; l !== null; ) l.alternate !== null && (p = l), (l = l.sibling);
          p === null ? (s.tail = null) : (p.sibling = null);
          break;
        case 'collapsed':
          p = s.tail;
          for (var _ = null; p !== null; ) p.alternate !== null && (_ = p), (p = p.sibling);
          _ === null
            ? l || s.tail === null
              ? (s.tail = null)
              : (s.tail.sibling = null)
            : (_.sibling = null);
      }
  }
  function mr(s) {
    var l = s.alternate !== null && s.alternate.child === s.child,
      p = 0,
      _ = 0;
    if (l)
      for (var w = s.child; w !== null; )
        (p |= w.lanes | w.childLanes),
          (_ |= w.subtreeFlags & 14680064),
          (_ |= w.flags & 14680064),
          (w.return = s),
          (w = w.sibling);
    else
      for (w = s.child; w !== null; )
        (p |= w.lanes | w.childLanes),
          (_ |= w.subtreeFlags),
          (_ |= w.flags),
          (w.return = s),
          (w = w.sibling);
    return (s.subtreeFlags |= _), (s.childLanes = p), l;
  }
  function a1(s, l, p) {
    var _ = l.pendingProps;
    switch ((js(l), l.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return mr(l), null;
      case 1:
        return Hi(l.type) && Zl(), mr(l), null;
      case 3:
        return (
          (_ = l.stateNode),
          Io(),
          Wn(er),
          Wn(Pi),
          Cs(),
          _.pendingContext && ((_.context = _.pendingContext), (_.pendingContext = null)),
          (s === null || s.child === null) &&
            (qa(l)
              ? (l.flags |= 4)
              : s === null ||
                (s.memoizedState.isDehydrated && !(l.flags & 256)) ||
                ((l.flags |= 1024), Jr !== null && (Lv(Jr), (Jr = null)))),
          Mv(s, l),
          mr(l),
          null
        );
      case 5:
        nl(l);
        var w = di(qs.current);
        if (((p = l.type), s !== null && l.stateNode != null))
          N_(s, l, p, _, w), s.ref !== l.ref && ((l.flags |= 512), (l.flags |= 2097152));
        else {
          if (!_) {
            if (l.stateNode === null) throw Error(t(166));
            return mr(l), null;
          }
          if (((s = di(Ir.current)), qa(l))) {
            (_ = l.stateNode), (p = l.type);
            var R = l.memoizedProps;
            switch (((_[yi] = l), (_[Qa] = R), (s = (l.mode & 1) !== 0), p)) {
              case 'dialog':
                Vn('cancel', _), Vn('close', _);
                break;
              case 'iframe':
              case 'object':
              case 'embed':
                Vn('load', _);
                break;
              case 'video':
              case 'audio':
                for (w = 0; w < Co.length; w++) Vn(Co[w], _);
                break;
              case 'source':
                Vn('error', _);
                break;
              case 'img':
              case 'image':
              case 'link':
                Vn('error', _), Vn('load', _);
                break;
              case 'details':
                Vn('toggle', _);
                break;
              case 'input':
                It(_, R), Vn('invalid', _);
                break;
              case 'select':
                (_._wrapperState = { wasMultiple: !!R.multiple }), Vn('invalid', _);
                break;
              case 'textarea':
                ve(_, R), Vn('invalid', _);
            }
            re(p, R), (w = null);
            for (var O in R)
              if (R.hasOwnProperty(O)) {
                var $ = R[O];
                O === 'children'
                  ? typeof $ == 'string'
                    ? _.textContent !== $ &&
                      (R.suppressHydrationWarning !== !0 && Kl(_.textContent, $, s),
                      (w = ['children', $]))
                    : typeof $ == 'number' &&
                      _.textContent !== '' + $ &&
                      (R.suppressHydrationWarning !== !0 && Kl(_.textContent, $, s),
                      (w = ['children', '' + $]))
                  : i.hasOwnProperty(O) && $ != null && O === 'onScroll' && Vn('scroll', _);
              }
            switch (p) {
              case 'input':
                Jt(_), rt(_, R, !0);
                break;
              case 'textarea':
                Jt(_), We(_);
                break;
              case 'select':
              case 'option':
                break;
              default:
                typeof R.onClick == 'function' && (_.onclick = jl);
            }
            (_ = w), (l.updateQueue = _), _ !== null && (l.flags |= 4);
          } else {
            (O = w.nodeType === 9 ? w : w.ownerDocument),
              s === 'http://www.w3.org/1999/xhtml' && (s = ze(p)),
              s === 'http://www.w3.org/1999/xhtml'
                ? p === 'script'
                  ? ((s = O.createElement('div')),
                    (s.innerHTML = '<script></script>'),
                    (s = s.removeChild(s.firstChild)))
                  : typeof _.is == 'string'
                  ? (s = O.createElement(p, { is: _.is }))
                  : ((s = O.createElement(p)),
                    p === 'select' &&
                      ((O = s), _.multiple ? (O.multiple = !0) : _.size && (O.size = _.size)))
                : (s = O.createElementNS(s, p)),
              (s[yi] = l),
              (s[Qa] = _),
              F_(s, l, !1, !1),
              (l.stateNode = s);
            e: {
              switch (((O = Re(p, _)), p)) {
                case 'dialog':
                  Vn('cancel', s), Vn('close', s), (w = _);
                  break;
                case 'iframe':
                case 'object':
                case 'embed':
                  Vn('load', s), (w = _);
                  break;
                case 'video':
                case 'audio':
                  for (w = 0; w < Co.length; w++) Vn(Co[w], s);
                  w = _;
                  break;
                case 'source':
                  Vn('error', s), (w = _);
                  break;
                case 'img':
                case 'image':
                case 'link':
                  Vn('error', s), Vn('load', s), (w = _);
                  break;
                case 'details':
                  Vn('toggle', s), (w = _);
                  break;
                case 'input':
                  It(s, _), (w = j(s, _)), Vn('invalid', s);
                  break;
                case 'option':
                  w = _;
                  break;
                case 'select':
                  (s._wrapperState = { wasMultiple: !!_.multiple }),
                    (w = te({}, _, { value: void 0 })),
                    Vn('invalid', s);
                  break;
                case 'textarea':
                  ve(s, _), (w = H(s, _)), Vn('invalid', s);
                  break;
                default:
                  w = _;
              }
              re(p, w), ($ = w);
              for (R in $)
                if ($.hasOwnProperty(R)) {
                  var ae = $[R];
                  R === 'style'
                    ? Rt(s, ae)
                    : R === 'dangerouslySetInnerHTML'
                    ? ((ae = ae ? ae.__html : void 0), ae != null && pt(s, ae))
                    : R === 'children'
                    ? typeof ae == 'string'
                      ? (p !== 'textarea' || ae !== '') && $t(s, ae)
                      : typeof ae == 'number' && $t(s, '' + ae)
                    : R !== 'suppressContentEditableWarning' &&
                      R !== 'suppressHydrationWarning' &&
                      R !== 'autoFocus' &&
                      (i.hasOwnProperty(R)
                        ? ae != null && R === 'onScroll' && Vn('scroll', s)
                        : ae != null && I(s, R, ae, O));
                }
              switch (p) {
                case 'input':
                  Jt(s), rt(s, _, !1);
                  break;
                case 'textarea':
                  Jt(s), We(s);
                  break;
                case 'option':
                  _.value != null && s.setAttribute('value', '' + et(_.value));
                  break;
                case 'select':
                  (s.multiple = !!_.multiple),
                    (R = _.value),
                    R != null
                      ? K(s, !!_.multiple, R, !1)
                      : _.defaultValue != null && K(s, !!_.multiple, _.defaultValue, !0);
                  break;
                default:
                  typeof w.onClick == 'function' && (s.onclick = jl);
              }
              switch (p) {
                case 'button':
                case 'input':
                case 'select':
                case 'textarea':
                  _ = !!_.autoFocus;
                  break e;
                case 'img':
                  _ = !0;
                  break e;
                default:
                  _ = !1;
              }
            }
            _ && (l.flags |= 4);
          }
          l.ref !== null && ((l.flags |= 512), (l.flags |= 2097152));
        }
        return mr(l), null;
      case 6:
        if (s && l.stateNode != null) U_(s, l, s.memoizedProps, _);
        else {
          if (typeof _ != 'string' && l.stateNode === null) throw Error(t(166));
          if (((p = di(qs.current)), di(Ir.current), qa(l))) {
            if (
              ((_ = l.stateNode),
              (p = l.memoizedProps),
              (_[yi] = l),
              (R = _.nodeValue !== p) && ((s = Di), s !== null))
            )
              switch (s.tag) {
                case 3:
                  Kl(_.nodeValue, p, (s.mode & 1) !== 0);
                  break;
                case 5:
                  s.memoizedProps.suppressHydrationWarning !== !0 &&
                    Kl(_.nodeValue, p, (s.mode & 1) !== 0);
              }
            R && (l.flags |= 4);
          } else
            (_ = (p.nodeType === 9 ? p : p.ownerDocument).createTextNode(_)),
              (_[yi] = l),
              (l.stateNode = _);
        }
        return mr(l), null;
      case 13:
        if (
          (Wn(Yn),
          (_ = l.memoizedState),
          s === null || (s.memoizedState !== null && s.memoizedState.dehydrated !== null))
        ) {
          if (Jn && nr !== null && l.mode & 1 && !(l.flags & 128))
            Ed(), Ro(), (l.flags |= 98560), (R = !1);
          else if (((R = qa(l)), _ !== null && _.dehydrated !== null)) {
            if (s === null) {
              if (!R) throw Error(t(318));
              if (((R = l.memoizedState), (R = R !== null ? R.dehydrated : null), !R))
                throw Error(t(317));
              R[yi] = l;
            } else Ro(), !(l.flags & 128) && (l.memoizedState = null), (l.flags |= 4);
            mr(l), (R = !1);
          } else Jr !== null && (Lv(Jr), (Jr = null)), (R = !0);
          if (!R) return l.flags & 65536 ? l : null;
        }
        return l.flags & 128
          ? ((l.lanes = p), l)
          : ((_ = _ !== null),
            _ !== (s !== null && s.memoizedState !== null) &&
              _ &&
              ((l.child.flags |= 8192),
              l.mode & 1 && (s === null || Yn.current & 1 ? Ui === 0 && (Ui = 3) : Uv())),
            l.updateQueue !== null && (l.flags |= 4),
            mr(l),
            null);
      case 4:
        return Io(), Mv(s, l), s === null && Ka(l.stateNode.containerInfo), mr(l), null;
      case 10:
        return iu(l.type._context), mr(l), null;
      case 17:
        return Hi(l.type) && Zl(), mr(l), null;
      case 19:
        if ((Wn(Yn), (R = l.memoizedState), R === null)) return mr(l), null;
        if (((_ = (l.flags & 128) !== 0), (O = R.rendering), O === null))
          if (_) Ud(R, !1);
          else {
            if (Ui !== 0 || (s !== null && s.flags & 128))
              for (s = l.child; s !== null; ) {
                if (((O = cs(s)), O !== null)) {
                  for (
                    l.flags |= 128,
                      Ud(R, !1),
                      _ = O.updateQueue,
                      _ !== null && ((l.updateQueue = _), (l.flags |= 4)),
                      l.subtreeFlags = 0,
                      _ = p,
                      p = l.child;
                    p !== null;

                  )
                    (R = p),
                      (s = _),
                      (R.flags &= 14680066),
                      (O = R.alternate),
                      O === null
                        ? ((R.childLanes = 0),
                          (R.lanes = s),
                          (R.child = null),
                          (R.subtreeFlags = 0),
                          (R.memoizedProps = null),
                          (R.memoizedState = null),
                          (R.updateQueue = null),
                          (R.dependencies = null),
                          (R.stateNode = null))
                        : ((R.childLanes = O.childLanes),
                          (R.lanes = O.lanes),
                          (R.child = O.child),
                          (R.subtreeFlags = 0),
                          (R.deletions = null),
                          (R.memoizedProps = O.memoizedProps),
                          (R.memoizedState = O.memoizedState),
                          (R.updateQueue = O.updateQueue),
                          (R.type = O.type),
                          (s = O.dependencies),
                          (R.dependencies =
                            s === null ? null : { lanes: s.lanes, firstContext: s.firstContext })),
                      (p = p.sibling);
                  return kn(Yn, (Yn.current & 1) | 2), l.child;
                }
                s = s.sibling;
              }
            R.tail !== null &&
              q() > sf &&
              ((l.flags |= 128), (_ = !0), Ud(R, !1), (l.lanes = 4194304));
          }
        else {
          if (!_)
            if (((s = cs(O)), s !== null)) {
              if (
                ((l.flags |= 128),
                (_ = !0),
                (p = s.updateQueue),
                p !== null && ((l.updateQueue = p), (l.flags |= 4)),
                Ud(R, !0),
                R.tail === null && R.tailMode === 'hidden' && !O.alternate && !Jn)
              )
                return mr(l), null;
            } else
              2 * q() - R.renderingStartTime > sf &&
                p !== 1073741824 &&
                ((l.flags |= 128), (_ = !0), Ud(R, !1), (l.lanes = 4194304));
          R.isBackwards
            ? ((O.sibling = l.child), (l.child = O))
            : ((p = R.last), p !== null ? (p.sibling = O) : (l.child = O), (R.last = O));
        }
        return R.tail !== null
          ? ((l = R.tail),
            (R.rendering = l),
            (R.tail = l.sibling),
            (R.renderingStartTime = q()),
            (l.sibling = null),
            (p = Yn.current),
            kn(Yn, _ ? (p & 1) | 2 : p & 1),
            l)
          : (mr(l), null);
      case 22:
      case 23:
        return (
          Nv(),
          (_ = l.memoizedState !== null),
          s !== null && (s.memoizedState !== null) !== _ && (l.flags |= 8192),
          _ && l.mode & 1
            ? hs & 1073741824 && (mr(l), l.subtreeFlags & 6 && (l.flags |= 8192))
            : mr(l),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, l.tag));
  }
  function l1(s, l) {
    switch ((js(l), l.tag)) {
      case 1:
        return (
          Hi(l.type) && Zl(), (s = l.flags), s & 65536 ? ((l.flags = (s & -65537) | 128), l) : null
        );
      case 3:
        return (
          Io(),
          Wn(er),
          Wn(Pi),
          Cs(),
          (s = l.flags),
          s & 65536 && !(s & 128) ? ((l.flags = (s & -65537) | 128), l) : null
        );
      case 5:
        return nl(l), null;
      case 13:
        if ((Wn(Yn), (s = l.memoizedState), s !== null && s.dehydrated !== null)) {
          if (l.alternate === null) throw Error(t(340));
          Ro();
        }
        return (s = l.flags), s & 65536 ? ((l.flags = (s & -65537) | 128), l) : null;
      case 19:
        return Wn(Yn), null;
      case 4:
        return Io(), null;
      case 10:
        return iu(l.type._context), null;
      case 22:
      case 23:
        return Nv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Rp = !1,
    gr = !1,
    u1 = typeof WeakSet == 'function' ? WeakSet : Set,
    Pt = null;
  function nf(s, l) {
    var p = s.ref;
    if (p !== null)
      if (typeof p == 'function')
        try {
          p(null);
        } catch (_) {
          pi(s, l, _);
        }
      else p.current = null;
  }
  function Ev(s, l, p) {
    try {
      p();
    } catch (_) {
      pi(s, l, _);
    }
  }
  var O_ = !1;
  function c1(s, l) {
    if (((Za = kr), (s = ei()), Mi(s))) {
      if ('selectionStart' in s) var p = { start: s.selectionStart, end: s.selectionEnd };
      else
        e: {
          p = ((p = s.ownerDocument) && p.defaultView) || window;
          var _ = p.getSelection && p.getSelection();
          if (_ && _.rangeCount !== 0) {
            p = _.anchorNode;
            var w = _.anchorOffset,
              R = _.focusNode;
            _ = _.focusOffset;
            try {
              p.nodeType, R.nodeType;
            } catch {
              p = null;
              break e;
            }
            var O = 0,
              $ = -1,
              ae = -1,
              Te = 0,
              $e = 0,
              nt = s,
              Ke = null;
            t: for (;;) {
              for (
                var Tt;
                nt !== p || (w !== 0 && nt.nodeType !== 3) || ($ = O + w),
                  nt !== R || (_ !== 0 && nt.nodeType !== 3) || (ae = O + _),
                  nt.nodeType === 3 && (O += nt.nodeValue.length),
                  (Tt = nt.firstChild) !== null;

              )
                (Ke = nt), (nt = Tt);
              for (;;) {
                if (nt === s) break t;
                if (
                  (Ke === p && ++Te === w && ($ = O),
                  Ke === R && ++$e === _ && (ae = O),
                  (Tt = nt.nextSibling) !== null)
                )
                  break;
                (nt = Ke), (Ke = nt.parentNode);
              }
              nt = Tt;
            }
            p = $ === -1 || ae === -1 ? null : { start: $, end: ae };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (dd = { focusedElem: s, selectionRange: p }, kr = !1, Pt = l; Pt !== null; )
      if (((l = Pt), (s = l.child), (l.subtreeFlags & 1028) !== 0 && s !== null))
        (s.return = l), (Pt = s);
      else
        for (; Pt !== null; ) {
          l = Pt;
          try {
            var Lt = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Lt !== null) {
                    var Nt = Lt.memoizedProps,
                      _i = Lt.memoizedState,
                      _e = l.stateNode,
                      he = _e.getSnapshotBeforeUpdate(
                        l.elementType === l.type ? Nt : Yr(l.type, Nt),
                        _i,
                      );
                    _e.__reactInternalSnapshotBeforeUpdate = he;
                  }
                  break;
                case 3:
                  var Se = l.stateNode.containerInfo;
                  Se.nodeType === 1
                    ? (Se.textContent = '')
                    : Se.nodeType === 9 && Se.documentElement && Se.removeChild(Se.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (ot) {
            pi(l, l.return, ot);
          }
          if (((s = l.sibling), s !== null)) {
            (s.return = l.return), (Pt = s);
            break;
          }
          Pt = l.return;
        }
    return (Lt = O_), (O_ = !1), Lt;
  }
  function Od(s, l, p) {
    var _ = l.updateQueue;
    if (((_ = _ !== null ? _.lastEffect : null), _ !== null)) {
      var w = (_ = _.next);
      do {
        if ((w.tag & s) === s) {
          var R = w.destroy;
          (w.destroy = void 0), R !== void 0 && Ev(l, p, R);
        }
        w = w.next;
      } while (w !== _);
    }
  }
  function bp(s, l) {
    if (((l = l.updateQueue), (l = l !== null ? l.lastEffect : null), l !== null)) {
      var p = (l = l.next);
      do {
        if ((p.tag & s) === s) {
          var _ = p.create;
          p.destroy = _();
        }
        p = p.next;
      } while (p !== l);
    }
  }
  function wv(s) {
    var l = s.ref;
    if (l !== null) {
      var p = s.stateNode;
      switch (s.tag) {
        case 5:
          s = p;
          break;
        default:
          s = p;
      }
      typeof l == 'function' ? l(s) : (l.current = s);
    }
  }
  function k_(s) {
    var l = s.alternate;
    l !== null && ((s.alternate = null), k_(l)),
      (s.child = null),
      (s.deletions = null),
      (s.sibling = null),
      s.tag === 5 &&
        ((l = s.stateNode),
        l !== null && (delete l[yi], delete l[Qa], delete l[ra], delete l[kc], delete l[zc])),
      (s.stateNode = null),
      (s.return = null),
      (s.dependencies = null),
      (s.memoizedProps = null),
      (s.memoizedState = null),
      (s.pendingProps = null),
      (s.stateNode = null),
      (s.updateQueue = null);
  }
  function z_(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4;
  }
  function H_(s) {
    e: for (;;) {
      for (; s.sibling === null; ) {
        if (s.return === null || z_(s.return)) return null;
        s = s.return;
      }
      for (
        s.sibling.return = s.return, s = s.sibling;
        s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

      ) {
        if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
        (s.child.return = s), (s = s.child);
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function Cv(s, l, p) {
    var _ = s.tag;
    if (_ === 5 || _ === 6)
      (s = s.stateNode),
        l
          ? p.nodeType === 8
            ? p.parentNode.insertBefore(s, l)
            : p.insertBefore(s, l)
          : (p.nodeType === 8
              ? ((l = p.parentNode), l.insertBefore(s, p))
              : ((l = p), l.appendChild(s)),
            (p = p._reactRootContainer),
            p != null || l.onclick !== null || (l.onclick = jl));
    else if (_ !== 4 && ((s = s.child), s !== null))
      for (Cv(s, l, p), s = s.sibling; s !== null; ) Cv(s, l, p), (s = s.sibling);
  }
  function Tv(s, l, p) {
    var _ = s.tag;
    if (_ === 5 || _ === 6) (s = s.stateNode), l ? p.insertBefore(s, l) : p.appendChild(s);
    else if (_ !== 4 && ((s = s.child), s !== null))
      for (Tv(s, l, p), s = s.sibling; s !== null; ) Tv(s, l, p), (s = s.sibling);
  }
  var rr = null,
    io = !1;
  function sl(s, l, p) {
    for (p = p.child; p !== null; ) G_(s, l, p), (p = p.sibling);
  }
  function G_(s, l, p) {
    if (Xe && typeof Xe.onCommitFiberUnmount == 'function')
      try {
        Xe.onCommitFiberUnmount(ut, p);
      } catch {}
    switch (p.tag) {
      case 5:
        gr || nf(p, l);
      case 6:
        var _ = rr,
          w = io;
        (rr = null),
          sl(s, l, p),
          (rr = _),
          (io = w),
          rr !== null &&
            (io
              ? ((s = rr),
                (p = p.stateNode),
                s.nodeType === 8 ? s.parentNode.removeChild(p) : s.removeChild(p))
              : rr.removeChild(p.stateNode));
        break;
      case 18:
        rr !== null &&
          (io
            ? ((s = rr),
              (p = p.stateNode),
              s.nodeType === 8 ? Oc(s.parentNode, p) : s.nodeType === 1 && Oc(s, p),
              Ul(s))
            : Oc(rr, p.stateNode));
        break;
      case 4:
        (_ = rr),
          (w = io),
          (rr = p.stateNode.containerInfo),
          (io = !0),
          sl(s, l, p),
          (rr = _),
          (io = w);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!gr && ((_ = p.updateQueue), _ !== null && ((_ = _.lastEffect), _ !== null))) {
          w = _ = _.next;
          do {
            var R = w,
              O = R.destroy;
            (R = R.tag), O !== void 0 && (R & 2 || R & 4) && Ev(p, l, O), (w = w.next);
          } while (w !== _);
        }
        sl(s, l, p);
        break;
      case 1:
        if (!gr && (nf(p, l), (_ = p.stateNode), typeof _.componentWillUnmount == 'function'))
          try {
            (_.props = p.memoizedProps), (_.state = p.memoizedState), _.componentWillUnmount();
          } catch ($) {
            pi(p, l, $);
          }
        sl(s, l, p);
        break;
      case 21:
        sl(s, l, p);
        break;
      case 22:
        p.mode & 1
          ? ((gr = (_ = gr) || p.memoizedState !== null), sl(s, l, p), (gr = _))
          : sl(s, l, p);
        break;
      default:
        sl(s, l, p);
    }
  }
  function V_(s) {
    var l = s.updateQueue;
    if (l !== null) {
      s.updateQueue = null;
      var p = s.stateNode;
      p === null && (p = s.stateNode = new u1()),
        l.forEach(function (_) {
          var w = _1.bind(null, s, _);
          p.has(_) || (p.add(_), _.then(w, w));
        });
    }
  }
  function ro(s, l) {
    var p = l.deletions;
    if (p !== null)
      for (var _ = 0; _ < p.length; _++) {
        var w = p[_];
        try {
          var R = s,
            O = l,
            $ = O;
          e: for (; $ !== null; ) {
            switch ($.tag) {
              case 5:
                (rr = $.stateNode), (io = !1);
                break e;
              case 3:
                (rr = $.stateNode.containerInfo), (io = !0);
                break e;
              case 4:
                (rr = $.stateNode.containerInfo), (io = !0);
                break e;
            }
            $ = $.return;
          }
          if (rr === null) throw Error(t(160));
          G_(R, O, w), (rr = null), (io = !1);
          var ae = w.alternate;
          ae !== null && (ae.return = null), (w.return = null);
        } catch (Te) {
          pi(w, l, Te);
        }
      }
    if (l.subtreeFlags & 12854) for (l = l.child; l !== null; ) W_(l, s), (l = l.sibling);
  }
  function W_(s, l) {
    var p = s.alternate,
      _ = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((ro(l, s), Po(s), _ & 4)) {
          try {
            Od(3, s, s.return), bp(3, s);
          } catch (Nt) {
            pi(s, s.return, Nt);
          }
          try {
            Od(5, s, s.return);
          } catch (Nt) {
            pi(s, s.return, Nt);
          }
        }
        break;
      case 1:
        ro(l, s), Po(s), _ & 512 && p !== null && nf(p, p.return);
        break;
      case 5:
        if ((ro(l, s), Po(s), _ & 512 && p !== null && nf(p, p.return), s.flags & 32)) {
          var w = s.stateNode;
          try {
            $t(w, '');
          } catch (Nt) {
            pi(s, s.return, Nt);
          }
        }
        if (_ & 4 && ((w = s.stateNode), w != null)) {
          var R = s.memoizedProps,
            O = p !== null ? p.memoizedProps : R,
            $ = s.type,
            ae = s.updateQueue;
          if (((s.updateQueue = null), ae !== null))
            try {
              $ === 'input' && R.type === 'radio' && R.name != null && qe(w, R), Re($, O);
              var Te = Re($, R);
              for (O = 0; O < ae.length; O += 2) {
                var $e = ae[O],
                  nt = ae[O + 1];
                $e === 'style'
                  ? Rt(w, nt)
                  : $e === 'dangerouslySetInnerHTML'
                  ? pt(w, nt)
                  : $e === 'children'
                  ? $t(w, nt)
                  : I(w, $e, nt, Te);
              }
              switch ($) {
                case 'input':
                  yt(w, R);
                  break;
                case 'textarea':
                  Le(w, R);
                  break;
                case 'select':
                  var Ke = w._wrapperState.wasMultiple;
                  w._wrapperState.wasMultiple = !!R.multiple;
                  var Tt = R.value;
                  Tt != null
                    ? K(w, !!R.multiple, Tt, !1)
                    : Ke !== !!R.multiple &&
                      (R.defaultValue != null
                        ? K(w, !!R.multiple, R.defaultValue, !0)
                        : K(w, !!R.multiple, R.multiple ? [] : '', !1));
              }
              w[Qa] = R;
            } catch (Nt) {
              pi(s, s.return, Nt);
            }
        }
        break;
      case 6:
        if ((ro(l, s), Po(s), _ & 4)) {
          if (s.stateNode === null) throw Error(t(162));
          (w = s.stateNode), (R = s.memoizedProps);
          try {
            w.nodeValue = R;
          } catch (Nt) {
            pi(s, s.return, Nt);
          }
        }
        break;
      case 3:
        if ((ro(l, s), Po(s), _ & 4 && p !== null && p.memoizedState.isDehydrated))
          try {
            Ul(l.containerInfo);
          } catch (Nt) {
            pi(s, s.return, Nt);
          }
        break;
      case 4:
        ro(l, s), Po(s);
        break;
      case 13:
        ro(l, s),
          Po(s),
          (w = s.child),
          w.flags & 8192 &&
            ((R = w.memoizedState !== null),
            (w.stateNode.isHidden = R),
            !R || (w.alternate !== null && w.alternate.memoizedState !== null) || (Iv = q())),
          _ & 4 && V_(s);
        break;
      case 22:
        if (
          (($e = p !== null && p.memoizedState !== null),
          s.mode & 1 ? ((gr = (Te = gr) || $e), ro(l, s), (gr = Te)) : ro(l, s),
          Po(s),
          _ & 8192)
        ) {
          if (((Te = s.memoizedState !== null), (s.stateNode.isHidden = Te) && !$e && s.mode & 1))
            for (Pt = s, $e = s.child; $e !== null; ) {
              for (nt = Pt = $e; Pt !== null; ) {
                switch (((Ke = Pt), (Tt = Ke.child), Ke.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Od(4, Ke, Ke.return);
                    break;
                  case 1:
                    nf(Ke, Ke.return);
                    var Lt = Ke.stateNode;
                    if (typeof Lt.componentWillUnmount == 'function') {
                      (_ = Ke), (p = Ke.return);
                      try {
                        (l = _),
                          (Lt.props = l.memoizedProps),
                          (Lt.state = l.memoizedState),
                          Lt.componentWillUnmount();
                      } catch (Nt) {
                        pi(_, p, Nt);
                      }
                    }
                    break;
                  case 5:
                    nf(Ke, Ke.return);
                    break;
                  case 22:
                    if (Ke.memoizedState !== null) {
                      Y_(nt);
                      continue;
                    }
                }
                Tt !== null ? ((Tt.return = Ke), (Pt = Tt)) : Y_(nt);
              }
              $e = $e.sibling;
            }
          e: for ($e = null, nt = s; ; ) {
            if (nt.tag === 5) {
              if ($e === null) {
                $e = nt;
                try {
                  (w = nt.stateNode),
                    Te
                      ? ((R = w.style),
                        typeof R.setProperty == 'function'
                          ? R.setProperty('display', 'none', 'important')
                          : (R.display = 'none'))
                      : (($ = nt.stateNode),
                        (ae = nt.memoizedProps.style),
                        (O = ae != null && ae.hasOwnProperty('display') ? ae.display : null),
                        ($.style.display = Ft('display', O)));
                } catch (Nt) {
                  pi(s, s.return, Nt);
                }
              }
            } else if (nt.tag === 6) {
              if ($e === null)
                try {
                  nt.stateNode.nodeValue = Te ? '' : nt.memoizedProps;
                } catch (Nt) {
                  pi(s, s.return, Nt);
                }
            } else if (
              ((nt.tag !== 22 && nt.tag !== 23) || nt.memoizedState === null || nt === s) &&
              nt.child !== null
            ) {
              (nt.child.return = nt), (nt = nt.child);
              continue;
            }
            if (nt === s) break e;
            for (; nt.sibling === null; ) {
              if (nt.return === null || nt.return === s) break e;
              $e === nt && ($e = null), (nt = nt.return);
            }
            $e === nt && ($e = null), (nt.sibling.return = nt.return), (nt = nt.sibling);
          }
        }
        break;
      case 19:
        ro(l, s), Po(s), _ & 4 && V_(s);
        break;
      case 21:
        break;
      default:
        ro(l, s), Po(s);
    }
  }
  function Po(s) {
    var l = s.flags;
    if (l & 2) {
      try {
        e: {
          for (var p = s.return; p !== null; ) {
            if (z_(p)) {
              var _ = p;
              break e;
            }
            p = p.return;
          }
          throw Error(t(160));
        }
        switch (_.tag) {
          case 5:
            var w = _.stateNode;
            _.flags & 32 && ($t(w, ''), (_.flags &= -33));
            var R = H_(s);
            Tv(s, R, w);
            break;
          case 3:
          case 4:
            var O = _.stateNode.containerInfo,
              $ = H_(s);
            Cv(s, $, O);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ae) {
        pi(s, s.return, ae);
      }
      s.flags &= -3;
    }
    l & 4096 && (s.flags &= -4097);
  }
  function f1(s, l, p) {
    (Pt = s), X_(s);
  }
  function X_(s, l, p) {
    for (var _ = (s.mode & 1) !== 0; Pt !== null; ) {
      var w = Pt,
        R = w.child;
      if (w.tag === 22 && _) {
        var O = w.memoizedState !== null || Rp;
        if (!O) {
          var $ = w.alternate,
            ae = ($ !== null && $.memoizedState !== null) || gr;
          $ = Rp;
          var Te = gr;
          if (((Rp = O), (gr = ae) && !Te))
            for (Pt = w; Pt !== null; )
              (O = Pt),
                (ae = O.child),
                O.tag === 22 && O.memoizedState !== null
                  ? K_(w)
                  : ae !== null
                  ? ((ae.return = O), (Pt = ae))
                  : K_(w);
          for (; R !== null; ) (Pt = R), X_(R), (R = R.sibling);
          (Pt = w), (Rp = $), (gr = Te);
        }
        J_(s);
      } else w.subtreeFlags & 8772 && R !== null ? ((R.return = w), (Pt = R)) : J_(s);
    }
  }
  function J_(s) {
    for (; Pt !== null; ) {
      var l = Pt;
      if (l.flags & 8772) {
        var p = l.alternate;
        try {
          if (l.flags & 8772)
            switch (l.tag) {
              case 0:
              case 11:
              case 15:
                gr || bp(5, l);
                break;
              case 1:
                var _ = l.stateNode;
                if (l.flags & 4 && !gr)
                  if (p === null) _.componentDidMount();
                  else {
                    var w =
                      l.elementType === l.type ? p.memoizedProps : Yr(l.type, p.memoizedProps);
                    _.componentDidUpdate(w, p.memoizedState, _.__reactInternalSnapshotBeforeUpdate);
                  }
                var R = l.updateQueue;
                R !== null && tl(l, R, _);
                break;
              case 3:
                var O = l.updateQueue;
                if (O !== null) {
                  if (((p = null), l.child !== null))
                    switch (l.child.tag) {
                      case 5:
                        p = l.child.stateNode;
                        break;
                      case 1:
                        p = l.child.stateNode;
                    }
                  tl(l, O, p);
                }
                break;
              case 5:
                var $ = l.stateNode;
                if (p === null && l.flags & 4) {
                  p = $;
                  var ae = l.memoizedProps;
                  switch (l.type) {
                    case 'button':
                    case 'input':
                    case 'select':
                    case 'textarea':
                      ae.autoFocus && p.focus();
                      break;
                    case 'img':
                      ae.src && (p.src = ae.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (l.memoizedState === null) {
                  var Te = l.alternate;
                  if (Te !== null) {
                    var $e = Te.memoizedState;
                    if ($e !== null) {
                      var nt = $e.dehydrated;
                      nt !== null && Ul(nt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          gr || (l.flags & 512 && wv(l));
        } catch (Ke) {
          pi(l, l.return, Ke);
        }
      }
      if (l === s) {
        Pt = null;
        break;
      }
      if (((p = l.sibling), p !== null)) {
        (p.return = l.return), (Pt = p);
        break;
      }
      Pt = l.return;
    }
  }
  function Y_(s) {
    for (; Pt !== null; ) {
      var l = Pt;
      if (l === s) {
        Pt = null;
        break;
      }
      var p = l.sibling;
      if (p !== null) {
        (p.return = l.return), (Pt = p);
        break;
      }
      Pt = l.return;
    }
  }
  function K_(s) {
    for (; Pt !== null; ) {
      var l = Pt;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var p = l.return;
            try {
              bp(4, l);
            } catch (ae) {
              pi(l, p, ae);
            }
            break;
          case 1:
            var _ = l.stateNode;
            if (typeof _.componentDidMount == 'function') {
              var w = l.return;
              try {
                _.componentDidMount();
              } catch (ae) {
                pi(l, w, ae);
              }
            }
            var R = l.return;
            try {
              wv(l);
            } catch (ae) {
              pi(l, R, ae);
            }
            break;
          case 5:
            var O = l.return;
            try {
              wv(l);
            } catch (ae) {
              pi(l, O, ae);
            }
        }
      } catch (ae) {
        pi(l, l.return, ae);
      }
      if (l === s) {
        Pt = null;
        break;
      }
      var $ = l.sibling;
      if ($ !== null) {
        ($.return = l.return), (Pt = $);
        break;
      }
      Pt = l.return;
    }
  }
  var d1 = Math.ceil,
    Ip = B.ReactCurrentDispatcher,
    Rv = B.ReactCurrentOwner,
    Rs = B.ReactCurrentBatchConfig,
    In = 0,
    Wi = null,
    Ri = null,
    sr = 0,
    hs = 0,
    rf = ii(0),
    Ui = 0,
    kd = null,
    pu = 0,
    Bp = 0,
    bv = 0,
    zd = null,
    Kr = null,
    Iv = 0,
    sf = 1 / 0,
    xa = null,
    Pp = !1,
    Bv = null,
    ol = null,
    Dp = !1,
    al = null,
    Lp = 0,
    Hd = 0,
    Pv = null,
    Fp = -1,
    Np = 0;
  function Lr() {
    return In & 6 ? q() : Fp !== -1 ? Fp : (Fp = q());
  }
  function ll(s) {
    return s.mode & 1
      ? In & 2 && sr !== 0
        ? sr & -sr
        : xv.transition !== null
        ? (Np === 0 && (Np = Yt()), Np)
        : ((s = xn), s !== 0 || ((s = window.event), (s = s === void 0 ? 16 : tp(s.type))), s)
      : 1;
  }
  function so(s, l, p, _) {
    if (50 < Hd) throw ((Hd = 0), (Pv = null), Error(t(185)));
    Cn(s, p, _),
      (!(In & 2) || s !== Wi) &&
        (s === Wi && (!(In & 2) && (Bp |= p), Ui === 4 && ul(s, sr)),
        jr(s, _),
        p === 1 && In === 0 && !(l.mode & 1) && ((sf = q() + 500), ql && Es()));
  }
  function jr(s, l) {
    var p = s.callbackNode;
    on(s, l);
    var _ = en(s, s === Wi ? sr : 0);
    if (_ === 0) p !== null && U(p), (s.callbackNode = null), (s.callbackPriority = 0);
    else if (((l = _ & -_), s.callbackPriority !== l)) {
      if ((p != null && U(p), l === 1))
        s.tag === 0 ? mp(Z_.bind(null, s)) : $l(Z_.bind(null, s)),
          _v(function () {
            !(In & 6) && Es();
          }),
          (p = null);
      else {
        switch (ur(_)) {
          case 1:
            p = Ae;
            break;
          case 4:
            p = Fe;
            break;
          case 16:
            p = Ve;
            break;
          case 536870912:
            p = ft;
            break;
          default:
            p = Ve;
        }
        p = rx(p, j_.bind(null, s));
      }
      (s.callbackPriority = l), (s.callbackNode = p);
    }
  }
  function j_(s, l) {
    if (((Fp = -1), (Np = 0), In & 6)) throw Error(t(327));
    var p = s.callbackNode;
    if (of() && s.callbackNode !== p) return null;
    var _ = en(s, s === Wi ? sr : 0);
    if (_ === 0) return null;
    if (_ & 30 || _ & s.expiredLanes || l) l = Up(s, _);
    else {
      l = _;
      var w = In;
      In |= 2;
      var R = q_();
      (Wi !== s || sr !== l) && ((xa = null), (sf = q() + 500), gu(s, l));
      do
        try {
          m1();
          break;
        } catch ($) {
          Q_(s, $);
        }
      while (!0);
      da(), (Ip.current = R), (In = w), Ri !== null ? (l = 0) : ((Wi = null), (sr = 0), (l = Ui));
    }
    if (l !== 0) {
      if ((l === 2 && ((w = pn(s)), w !== 0 && ((_ = w), (l = Dv(s, w)))), l === 1))
        throw ((p = kd), gu(s, 0), ul(s, _), jr(s, q()), p);
      if (l === 6) ul(s, _);
      else {
        if (
          ((w = s.current.alternate),
          !(_ & 30) &&
            !h1(w) &&
            ((l = Up(s, _)),
            l === 2 && ((R = pn(s)), R !== 0 && ((_ = R), (l = Dv(s, R)))),
            l === 1))
        )
          throw ((p = kd), gu(s, 0), ul(s, _), jr(s, q()), p);
        switch (((s.finishedWork = w), (s.finishedLanes = _), l)) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            vu(s, Kr, xa);
            break;
          case 3:
            if ((ul(s, _), (_ & 130023424) === _ && ((l = Iv + 500 - q()), 10 < l))) {
              if (en(s, 0) !== 0) break;
              if (((w = s.suspendedLanes), (w & _) !== _)) {
                Lr(), (s.pingedLanes |= s.suspendedLanes & w);
                break;
              }
              s.timeoutHandle = pd(vu.bind(null, s, Kr, xa), l);
              break;
            }
            vu(s, Kr, xa);
            break;
          case 4:
            if ((ul(s, _), (_ & 4194240) === _)) break;
            for (l = s.eventTimes, w = -1; 0 < _; ) {
              var O = 31 - gt(_);
              (R = 1 << O), (O = l[O]), O > w && (w = O), (_ &= ~R);
            }
            if (
              ((_ = w),
              (_ = q() - _),
              (_ =
                (120 > _
                  ? 120
                  : 480 > _
                  ? 480
                  : 1080 > _
                  ? 1080
                  : 1920 > _
                  ? 1920
                  : 3e3 > _
                  ? 3e3
                  : 4320 > _
                  ? 4320
                  : 1960 * d1(_ / 1960)) - _),
              10 < _)
            ) {
              s.timeoutHandle = pd(vu.bind(null, s, Kr, xa), _);
              break;
            }
            vu(s, Kr, xa);
            break;
          case 5:
            vu(s, Kr, xa);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return jr(s, q()), s.callbackNode === p ? j_.bind(null, s) : null;
  }
  function Dv(s, l) {
    var p = zd;
    return (
      s.current.memoizedState.isDehydrated && (gu(s, l).flags |= 256),
      (s = Up(s, l)),
      s !== 2 && ((l = Kr), (Kr = p), l !== null && Lv(l)),
      s
    );
  }
  function Lv(s) {
    Kr === null ? (Kr = s) : Kr.push.apply(Kr, s);
  }
  function h1(s) {
    for (var l = s; ; ) {
      if (l.flags & 16384) {
        var p = l.updateQueue;
        if (p !== null && ((p = p.stores), p !== null))
          for (var _ = 0; _ < p.length; _++) {
            var w = p[_],
              R = w.getSnapshot;
            w = w.value;
            try {
              if (!Cr(R(), w)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((p = l.child), l.subtreeFlags & 16384 && p !== null)) (p.return = l), (l = p);
      else {
        if (l === s) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === s) return !0;
          l = l.return;
        }
        (l.sibling.return = l.return), (l = l.sibling);
      }
    }
    return !0;
  }
  function ul(s, l) {
    for (
      l &= ~bv, l &= ~Bp, s.suspendedLanes |= l, s.pingedLanes &= ~l, s = s.expirationTimes;
      0 < l;

    ) {
      var p = 31 - gt(l),
        _ = 1 << p;
      (s[p] = -1), (l &= ~_);
    }
  }
  function Z_(s) {
    if (In & 6) throw Error(t(327));
    of();
    var l = en(s, 0);
    if (!(l & 1)) return jr(s, q()), null;
    var p = Up(s, l);
    if (s.tag !== 0 && p === 2) {
      var _ = pn(s);
      _ !== 0 && ((l = _), (p = Dv(s, _)));
    }
    if (p === 1) throw ((p = kd), gu(s, 0), ul(s, l), jr(s, q()), p);
    if (p === 6) throw Error(t(345));
    return (
      (s.finishedWork = s.current.alternate), (s.finishedLanes = l), vu(s, Kr, xa), jr(s, q()), null
    );
  }
  function Fv(s, l) {
    var p = In;
    In |= 1;
    try {
      return s(l);
    } finally {
      (In = p), In === 0 && ((sf = q() + 500), ql && Es());
    }
  }
  function mu(s) {
    al !== null && al.tag === 0 && !(In & 6) && of();
    var l = In;
    In |= 1;
    var p = Rs.transition,
      _ = xn;
    try {
      if (((Rs.transition = null), (xn = 1), s)) return s();
    } finally {
      (xn = _), (Rs.transition = p), (In = l), !(In & 6) && Es();
    }
  }
  function Nv() {
    (hs = rf.current), Wn(rf);
  }
  function gu(s, l) {
    (s.finishedWork = null), (s.finishedLanes = 0);
    var p = s.timeoutHandle;
    if ((p !== -1 && ((s.timeoutHandle = -1), md(p)), Ri !== null))
      for (p = Ri.return; p !== null; ) {
        var _ = p;
        switch ((js(_), _.tag)) {
          case 1:
            (_ = _.type.childContextTypes), _ != null && Zl();
            break;
          case 3:
            Io(), Wn(er), Wn(Pi), Cs();
            break;
          case 5:
            nl(_);
            break;
          case 4:
            Io();
            break;
          case 13:
            Wn(Yn);
            break;
          case 19:
            Wn(Yn);
            break;
          case 10:
            iu(_.type._context);
            break;
          case 22:
          case 23:
            Nv();
        }
        p = p.return;
      }
    if (
      ((Wi = s),
      (Ri = s = cl(s.current, null)),
      (sr = hs = l),
      (Ui = 0),
      (kd = null),
      (bv = Bp = pu = 0),
      (Kr = zd = null),
      Qs !== null)
    ) {
      for (l = 0; l < Qs.length; l++)
        if (((p = Qs[l]), (_ = p.interleaved), _ !== null)) {
          p.interleaved = null;
          var w = _.next,
            R = p.pending;
          if (R !== null) {
            var O = R.next;
            (R.next = w), (_.next = O);
          }
          p.pending = _;
        }
      Qs = null;
    }
    return s;
  }
  function Q_(s, l) {
    do {
      var p = Ri;
      try {
        if ((da(), (ga.current = ef), fs)) {
          for (var _ = Xn.memoizedState; _ !== null; ) {
            var w = _.queue;
            w !== null && (w.pending = null), (_ = _.next);
          }
          fs = !1;
        }
        if (
          (($s = 0),
          (Tn = si = Xn = null),
          (Vi = !1),
          (Bo = 0),
          (Rv.current = null),
          p === null || p.return === null)
        ) {
          (Ui = 1), (kd = l), (Ri = null);
          break;
        }
        e: {
          var R = s,
            O = p.return,
            $ = p,
            ae = l;
          if (
            ((l = sr),
            ($.flags |= 32768),
            ae !== null && typeof ae == 'object' && typeof ae.then == 'function')
          ) {
            var Te = ae,
              $e = $,
              nt = $e.tag;
            if (!($e.mode & 1) && (nt === 0 || nt === 11 || nt === 15)) {
              var Ke = $e.alternate;
              Ke
                ? (($e.updateQueue = Ke.updateQueue),
                  ($e.memoizedState = Ke.memoizedState),
                  ($e.lanes = Ke.lanes))
                : (($e.updateQueue = null), ($e.memoizedState = null));
            }
            var Tt = bt(O);
            if (Tt !== null) {
              (Tt.flags &= -257),
                rn(Tt, O, $, R, l),
                Tt.mode & 1 && st(R, Te, l),
                (l = Tt),
                (ae = Te);
              var Lt = l.updateQueue;
              if (Lt === null) {
                var Nt = new Set();
                Nt.add(ae), (l.updateQueue = Nt);
              } else Lt.add(ae);
              break e;
            } else {
              if (!(l & 1)) {
                st(R, Te, l), Uv();
                break e;
              }
              ae = Error(t(426));
            }
          } else if (Jn && $.mode & 1) {
            var _i = bt(O);
            if (_i !== null) {
              !(_i.flags & 65536) && (_i.flags |= 256), rn(_i, O, $, R, l), $a(M(ae, $));
              break e;
            }
          }
          (R = ae = M(ae, $)), Ui !== 4 && (Ui = 2), zd === null ? (zd = [R]) : zd.push(R), (R = O);
          do {
            switch (R.tag) {
              case 3:
                (R.flags |= 65536), (l &= -l), (R.lanes |= l);
                var _e = pe(R, ae, l);
                ha(R, _e);
                break e;
              case 1:
                $ = ae;
                var he = R.type,
                  Se = R.stateNode;
                if (
                  !(R.flags & 128) &&
                  (typeof he.getDerivedStateFromError == 'function' ||
                    (Se !== null &&
                      typeof Se.componentDidCatch == 'function' &&
                      (ol === null || !ol.has(Se))))
                ) {
                  (R.flags |= 65536), (l &= -l), (R.lanes |= l);
                  var ot = Ne(R, $, l);
                  ha(R, ot);
                  break e;
                }
            }
            R = R.return;
          } while (R !== null);
        }
        ex(p);
      } catch (zt) {
        (l = zt), Ri === p && p !== null && (Ri = p = p.return);
        continue;
      }
      break;
    } while (!0);
  }
  function q_() {
    var s = Ip.current;
    return (Ip.current = ef), s === null ? ef : s;
  }
  function Uv() {
    (Ui === 0 || Ui === 3 || Ui === 2) && (Ui = 4),
      Wi === null || (!(pu & 268435455) && !(Bp & 268435455)) || ul(Wi, sr);
  }
  function Up(s, l) {
    var p = In;
    In |= 2;
    var _ = q_();
    (Wi !== s || sr !== l) && ((xa = null), gu(s, l));
    do
      try {
        p1();
        break;
      } catch (w) {
        Q_(s, w);
      }
    while (!0);
    if ((da(), (In = p), (Ip.current = _), Ri !== null)) throw Error(t(261));
    return (Wi = null), (sr = 0), Ui;
  }
  function p1() {
    for (; Ri !== null; ) $_(Ri);
  }
  function m1() {
    for (; Ri !== null && !Q(); ) $_(Ri);
  }
  function $_(s) {
    var l = ix(s.alternate, s, hs);
    (s.memoizedProps = s.pendingProps), l === null ? ex(s) : (Ri = l), (Rv.current = null);
  }
  function ex(s) {
    var l = s;
    do {
      var p = l.alternate;
      if (((s = l.return), l.flags & 32768)) {
        if (((p = l1(p, l)), p !== null)) {
          (p.flags &= 32767), (Ri = p);
          return;
        }
        if (s !== null) (s.flags |= 32768), (s.subtreeFlags = 0), (s.deletions = null);
        else {
          (Ui = 6), (Ri = null);
          return;
        }
      } else if (((p = a1(p, l, hs)), p !== null)) {
        Ri = p;
        return;
      }
      if (((l = l.sibling), l !== null)) {
        Ri = l;
        return;
      }
      Ri = l = s;
    } while (l !== null);
    Ui === 0 && (Ui = 5);
  }
  function vu(s, l, p) {
    var _ = xn,
      w = Rs.transition;
    try {
      (Rs.transition = null), (xn = 1), g1(s, l, p, _);
    } finally {
      (Rs.transition = w), (xn = _);
    }
    return null;
  }
  function g1(s, l, p, _) {
    do of();
    while (al !== null);
    if (In & 6) throw Error(t(327));
    p = s.finishedWork;
    var w = s.finishedLanes;
    if (p === null) return null;
    if (((s.finishedWork = null), (s.finishedLanes = 0), p === s.current)) throw Error(t(177));
    (s.callbackNode = null), (s.callbackPriority = 0);
    var R = p.lanes | p.childLanes;
    if (
      (Gn(s, R),
      s === Wi && ((Ri = Wi = null), (sr = 0)),
      (!(p.subtreeFlags & 2064) && !(p.flags & 2064)) ||
        Dp ||
        ((Dp = !0),
        rx(Ve, function () {
          return of(), null;
        })),
      (R = (p.flags & 15990) !== 0),
      p.subtreeFlags & 15990 || R)
    ) {
      (R = Rs.transition), (Rs.transition = null);
      var O = xn;
      xn = 1;
      var $ = In;
      (In |= 4),
        (Rv.current = null),
        c1(s, p),
        W_(p, s),
        Ei(dd),
        (kr = !!Za),
        (dd = Za = null),
        (s.current = p),
        f1(p),
        ee(),
        (In = $),
        (xn = O),
        (Rs.transition = R);
    } else s.current = p;
    if (
      (Dp && ((Dp = !1), (al = s), (Lp = w)),
      (R = s.pendingLanes),
      R === 0 && (ol = null),
      mt(p.stateNode),
      jr(s, q()),
      l !== null)
    )
      for (_ = s.onRecoverableError, p = 0; p < l.length; p++)
        (w = l[p]), _(w.value, { componentStack: w.stack, digest: w.digest });
    if (Pp) throw ((Pp = !1), (s = Bv), (Bv = null), s);
    return (
      Lp & 1 && s.tag !== 0 && of(),
      (R = s.pendingLanes),
      R & 1 ? (s === Pv ? Hd++ : ((Hd = 0), (Pv = s))) : (Hd = 0),
      Es(),
      null
    );
  }
  function of() {
    if (al !== null) {
      var s = ur(Lp),
        l = Rs.transition,
        p = xn;
      try {
        if (((Rs.transition = null), (xn = 16 > s ? 16 : s), al === null)) var _ = !1;
        else {
          if (((s = al), (al = null), (Lp = 0), In & 6)) throw Error(t(331));
          var w = In;
          for (In |= 4, Pt = s.current; Pt !== null; ) {
            var R = Pt,
              O = R.child;
            if (Pt.flags & 16) {
              var $ = R.deletions;
              if ($ !== null) {
                for (var ae = 0; ae < $.length; ae++) {
                  var Te = $[ae];
                  for (Pt = Te; Pt !== null; ) {
                    var $e = Pt;
                    switch ($e.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Od(8, $e, R);
                    }
                    var nt = $e.child;
                    if (nt !== null) (nt.return = $e), (Pt = nt);
                    else
                      for (; Pt !== null; ) {
                        $e = Pt;
                        var Ke = $e.sibling,
                          Tt = $e.return;
                        if ((k_($e), $e === Te)) {
                          Pt = null;
                          break;
                        }
                        if (Ke !== null) {
                          (Ke.return = Tt), (Pt = Ke);
                          break;
                        }
                        Pt = Tt;
                      }
                  }
                }
                var Lt = R.alternate;
                if (Lt !== null) {
                  var Nt = Lt.child;
                  if (Nt !== null) {
                    Lt.child = null;
                    do {
                      var _i = Nt.sibling;
                      (Nt.sibling = null), (Nt = _i);
                    } while (Nt !== null);
                  }
                }
                Pt = R;
              }
            }
            if (R.subtreeFlags & 2064 && O !== null) (O.return = R), (Pt = O);
            else
              e: for (; Pt !== null; ) {
                if (((R = Pt), R.flags & 2048))
                  switch (R.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Od(9, R, R.return);
                  }
                var _e = R.sibling;
                if (_e !== null) {
                  (_e.return = R.return), (Pt = _e);
                  break e;
                }
                Pt = R.return;
              }
          }
          var he = s.current;
          for (Pt = he; Pt !== null; ) {
            O = Pt;
            var Se = O.child;
            if (O.subtreeFlags & 2064 && Se !== null) (Se.return = O), (Pt = Se);
            else
              e: for (O = he; Pt !== null; ) {
                if ((($ = Pt), $.flags & 2048))
                  try {
                    switch ($.tag) {
                      case 0:
                      case 11:
                      case 15:
                        bp(9, $);
                    }
                  } catch (zt) {
                    pi($, $.return, zt);
                  }
                if ($ === O) {
                  Pt = null;
                  break e;
                }
                var ot = $.sibling;
                if (ot !== null) {
                  (ot.return = $.return), (Pt = ot);
                  break e;
                }
                Pt = $.return;
              }
          }
          if (((In = w), Es(), Xe && typeof Xe.onPostCommitFiberRoot == 'function'))
            try {
              Xe.onPostCommitFiberRoot(ut, s);
            } catch {}
          _ = !0;
        }
        return _;
      } finally {
        (xn = p), (Rs.transition = l);
      }
    }
    return !1;
  }
  function tx(s, l, p) {
    (l = M(p, l)),
      (l = pe(s, l, 1)),
      (s = Zn(s, l, 1)),
      (l = Lr()),
      s !== null && (Cn(s, 1, l), jr(s, l));
  }
  function pi(s, l, p) {
    if (s.tag === 3) tx(s, s, p);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          tx(l, s, p);
          break;
        } else if (l.tag === 1) {
          var _ = l.stateNode;
          if (
            typeof l.type.getDerivedStateFromError == 'function' ||
            (typeof _.componentDidCatch == 'function' && (ol === null || !ol.has(_)))
          ) {
            (s = M(p, s)),
              (s = Ne(l, s, 1)),
              (l = Zn(l, s, 1)),
              (s = Lr()),
              l !== null && (Cn(l, 1, s), jr(l, s));
            break;
          }
        }
        l = l.return;
      }
  }
  function v1(s, l, p) {
    var _ = s.pingCache;
    _ !== null && _.delete(l),
      (l = Lr()),
      (s.pingedLanes |= s.suspendedLanes & p),
      Wi === s &&
        (sr & p) === p &&
        (Ui === 4 || (Ui === 3 && (sr & 130023424) === sr && 500 > q() - Iv)
          ? gu(s, 0)
          : (bv |= p)),
      jr(s, l);
  }
  function nx(s, l) {
    l === 0 && (s.mode & 1 ? ((l = cn), (cn <<= 1), !(cn & 130023424) && (cn = 4194304)) : (l = 1));
    var p = Lr();
    (s = us(s, l)), s !== null && (Cn(s, l, p), jr(s, p));
  }
  function y1(s) {
    var l = s.memoizedState,
      p = 0;
    l !== null && (p = l.retryLane), nx(s, p);
  }
  function _1(s, l) {
    var p = 0;
    switch (s.tag) {
      case 13:
        var _ = s.stateNode,
          w = s.memoizedState;
        w !== null && (p = w.retryLane);
        break;
      case 19:
        _ = s.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    _ !== null && _.delete(l), nx(s, p);
  }
  var ix;
  ix = function (s, l, p) {
    if (s !== null)
      if (s.memoizedProps !== l.pendingProps || er.current) mn = !0;
      else {
        if (!(s.lanes & p) && !(l.flags & 128)) return (mn = !1), o1(s, l, p);
        mn = !!(s.flags & 131072);
      }
    else (mn = !1), Jn && l.flags & 1048576 && xd(l, Wc, l.index);
    switch (((l.lanes = 0), l.tag)) {
      case 2:
        var _ = l.type;
        Tp(s, l), (s = l.pendingProps);
        var w = sa(l, Pi.current);
        bo(l, p), (w = lu(null, l, _, s, w, p));
        var R = Rd();
        return (
          (l.flags |= 1),
          typeof w == 'object' &&
          w !== null &&
          typeof w.render == 'function' &&
          w.$$typeof === void 0
            ? ((l.tag = 1),
              (l.memoizedState = null),
              (l.updateQueue = null),
              Hi(_) ? ((R = !0), oa(l)) : (R = !1),
              (l.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null),
              fn(l),
              (w.updater = tf),
              (l.stateNode = w),
              (w._reactInternals = l),
              y(l, _, s, p),
              (l = ln(null, l, _, !0, R, p)))
            : ((l.tag = 0), Jn && R && Ad(l), Et(null, l, w, p), (l = l.child)),
          l
        );
      case 16:
        _ = l.elementType;
        e: {
          switch (
            (Tp(s, l),
            (s = l.pendingProps),
            (w = _._init),
            (_ = w(_._payload)),
            (l.type = _),
            (w = l.tag = A1(_)),
            (s = Yr(_, s)),
            w)
          ) {
            case 0:
              l = _t(null, l, _, s, p);
              break e;
            case 1:
              l = Ot(null, l, _, s, p);
              break e;
            case 11:
              l = Ni(null, l, _, s, p);
              break e;
            case 14:
              l = Dr(null, l, _, Yr(_.type, s), p);
              break e;
          }
          throw Error(t(306, _, ''));
        }
        return l;
      case 0:
        return (
          (_ = l.type),
          (w = l.pendingProps),
          (w = l.elementType === _ ? w : Yr(_, w)),
          _t(s, l, _, w, p)
        );
      case 1:
        return (
          (_ = l.type),
          (w = l.pendingProps),
          (w = l.elementType === _ ? w : Yr(_, w)),
          Ot(s, l, _, w, p)
        );
      case 3:
        e: {
          if ((sn(l), s === null)) throw Error(t(387));
          (_ = l.pendingProps), (R = l.memoizedState), (w = R.element), ui(s, l), ri(l, _, null, p);
          var O = l.memoizedState;
          if (((_ = O.element), R.isDehydrated))
            if (
              ((R = {
                element: _,
                isDehydrated: !1,
                cache: O.cache,
                pendingSuspenseBoundaries: O.pendingSuspenseBoundaries,
                transitions: O.transitions,
              }),
              (l.updateQueue.baseState = R),
              (l.memoizedState = R),
              l.flags & 256)
            ) {
              (w = M(Error(t(423)), l)), (l = En(s, l, _, p, w));
              break e;
            } else if (_ !== w) {
              (w = M(Error(t(424)), l)), (l = En(s, l, _, p, w));
              break e;
            } else
              for (
                nr = Ws(l.stateNode.containerInfo.firstChild),
                  Di = l,
                  Jn = !0,
                  Jr = null,
                  p = nu(l, null, _, p),
                  l.child = p;
                p;

              )
                (p.flags = (p.flags & -3) | 4096), (p = p.sibling);
          else {
            if ((Ro(), _ === w)) {
              l = _a(s, l, p);
              break e;
            }
            Et(s, l, _, p);
          }
          l = l.child;
        }
        return l;
      case 5:
        return (
          ma(l),
          s === null && Jc(l),
          (_ = l.type),
          (w = l.pendingProps),
          (R = s !== null ? s.memoizedProps : null),
          (O = w.children),
          hd(_, w) ? (O = null) : R !== null && hd(_, R) && (l.flags |= 32),
          be(s, l),
          Et(s, l, O, p),
          l.child
        );
      case 6:
        return s === null && Jc(l), null;
      case 13:
        return no(s, l, p);
      case 4:
        return (
          ou(l, l.stateNode.containerInfo),
          (_ = l.pendingProps),
          s === null ? (l.child = ua(l, null, _, p)) : Et(s, l, _, p),
          l.child
        );
      case 11:
        return (
          (_ = l.type),
          (w = l.pendingProps),
          (w = l.elementType === _ ? w : Yr(_, w)),
          Ni(s, l, _, w, p)
        );
      case 7:
        return Et(s, l, l.pendingProps, p), l.child;
      case 8:
        return Et(s, l, l.pendingProps.children, p), l.child;
      case 12:
        return Et(s, l, l.pendingProps.children, p), l.child;
      case 10:
        e: {
          if (
            ((_ = l.type._context),
            (w = l.pendingProps),
            (R = l.memoizedProps),
            (O = w.value),
            kn(ca, _._currentValue),
            (_._currentValue = O),
            R !== null)
          )
            if (Cr(R.value, O)) {
              if (R.children === w.children && !er.current) {
                l = _a(s, l, p);
                break e;
              }
            } else
              for (R = l.child, R !== null && (R.return = l); R !== null; ) {
                var $ = R.dependencies;
                if ($ !== null) {
                  O = R.child;
                  for (var ae = $.firstContext; ae !== null; ) {
                    if (ae.context === _) {
                      if (R.tag === 1) {
                        (ae = On(-1, p & -p)), (ae.tag = 2);
                        var Te = R.updateQueue;
                        if (Te !== null) {
                          Te = Te.shared;
                          var $e = Te.pending;
                          $e === null ? (ae.next = ae) : ((ae.next = $e.next), ($e.next = ae)),
                            (Te.pending = ae);
                        }
                      }
                      (R.lanes |= p),
                        (ae = R.alternate),
                        ae !== null && (ae.lanes |= p),
                        ru(R.return, p, l),
                        ($.lanes |= p);
                      break;
                    }
                    ae = ae.next;
                  }
                } else if (R.tag === 10) O = R.type === l.type ? null : R.child;
                else if (R.tag === 18) {
                  if (((O = R.return), O === null)) throw Error(t(341));
                  (O.lanes |= p),
                    ($ = O.alternate),
                    $ !== null && ($.lanes |= p),
                    ru(O, p, l),
                    (O = R.sibling);
                } else O = R.child;
                if (O !== null) O.return = R;
                else
                  for (O = R; O !== null; ) {
                    if (O === l) {
                      O = null;
                      break;
                    }
                    if (((R = O.sibling), R !== null)) {
                      (R.return = O.return), (O = R);
                      break;
                    }
                    O = O.return;
                  }
                R = O;
              }
          Et(s, l, w.children, p), (l = l.child);
        }
        return l;
      case 9:
        return (
          (w = l.type),
          (_ = l.pendingProps.children),
          bo(l, p),
          (w = br(w)),
          (_ = _(w)),
          (l.flags |= 1),
          Et(s, l, _, p),
          l.child
        );
      case 14:
        return (_ = l.type), (w = Yr(_, l.pendingProps)), (w = Yr(_.type, w)), Dr(s, l, _, w, p);
      case 15:
        return Me(s, l, l.type, l.pendingProps, p);
      case 17:
        return (
          (_ = l.type),
          (w = l.pendingProps),
          (w = l.elementType === _ ? w : Yr(_, w)),
          Tp(s, l),
          (l.tag = 1),
          Hi(_) ? ((s = !0), oa(l)) : (s = !1),
          bo(l, p),
          c(l, _, w),
          y(l, _, w, p),
          ln(null, l, _, !0, s, p)
        );
      case 19:
        return L_(s, l, p);
      case 22:
        return me(s, l, p);
    }
    throw Error(t(156, l.tag));
  };
  function rx(s, l) {
    return Qe(s, l);
  }
  function x1(s, l, p, _) {
    (this.tag = s),
      (this.key = p),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = l),
      (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
      (this.mode = _),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function bs(s, l, p, _) {
    return new x1(s, l, p, _);
  }
  function Ov(s) {
    return (s = s.prototype), !(!s || !s.isReactComponent);
  }
  function A1(s) {
    if (typeof s == 'function') return Ov(s) ? 1 : 0;
    if (s != null) {
      if (((s = s.$$typeof), s === oe)) return 11;
      if (s === xe) return 14;
    }
    return 2;
  }
  function cl(s, l) {
    var p = s.alternate;
    return (
      p === null
        ? ((p = bs(s.tag, l, s.key, s.mode)),
          (p.elementType = s.elementType),
          (p.type = s.type),
          (p.stateNode = s.stateNode),
          (p.alternate = s),
          (s.alternate = p))
        : ((p.pendingProps = l),
          (p.type = s.type),
          (p.flags = 0),
          (p.subtreeFlags = 0),
          (p.deletions = null)),
      (p.flags = s.flags & 14680064),
      (p.childLanes = s.childLanes),
      (p.lanes = s.lanes),
      (p.child = s.child),
      (p.memoizedProps = s.memoizedProps),
      (p.memoizedState = s.memoizedState),
      (p.updateQueue = s.updateQueue),
      (l = s.dependencies),
      (p.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }),
      (p.sibling = s.sibling),
      (p.index = s.index),
      (p.ref = s.ref),
      p
    );
  }
  function Op(s, l, p, _, w, R) {
    var O = 2;
    if (((_ = s), typeof s == 'function')) Ov(s) && (O = 1);
    else if (typeof s == 'string') O = 5;
    else
      e: switch (s) {
        case G:
          return yu(p.children, w, R, l);
        case k:
          (O = 8), (w |= 8);
          break;
        case L:
          return (s = bs(12, p, l, w | 2)), (s.elementType = L), (s.lanes = R), s;
        case ie:
          return (s = bs(13, p, l, w)), (s.elementType = ie), (s.lanes = R), s;
        case ce:
          return (s = bs(19, p, l, w)), (s.elementType = ce), (s.lanes = R), s;
        case Ce:
          return kp(p, w, R, l);
        default:
          if (typeof s == 'object' && s !== null)
            switch (s.$$typeof) {
              case D:
                O = 10;
                break e;
              case V:
                O = 9;
                break e;
              case oe:
                O = 11;
                break e;
              case xe:
                O = 14;
                break e;
              case de:
                (O = 16), (_ = null);
                break e;
            }
          throw Error(t(130, s == null ? s : typeof s, ''));
      }
    return (l = bs(O, p, l, w)), (l.elementType = s), (l.type = _), (l.lanes = R), l;
  }
  function yu(s, l, p, _) {
    return (s = bs(7, s, _, l)), (s.lanes = p), s;
  }
  function kp(s, l, p, _) {
    return (
      (s = bs(22, s, _, l)),
      (s.elementType = Ce),
      (s.lanes = p),
      (s.stateNode = { isHidden: !1 }),
      s
    );
  }
  function kv(s, l, p) {
    return (s = bs(6, s, null, l)), (s.lanes = p), s;
  }
  function zv(s, l, p) {
    return (
      (l = bs(4, s.children !== null ? s.children : [], s.key, l)),
      (l.lanes = p),
      (l.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation,
      }),
      l
    );
  }
  function S1(s, l, p, _, w) {
    (this.tag = l),
      (this.containerInfo = s),
      (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Kn(0)),
      (this.expirationTimes = Kn(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Kn(0)),
      (this.identifierPrefix = _),
      (this.onRecoverableError = w),
      (this.mutableSourceEagerHydrationData = null);
  }
  function Hv(s, l, p, _, w, R, O, $, ae) {
    return (
      (s = new S1(s, l, p, $, ae)),
      l === 1 ? ((l = 1), R === !0 && (l |= 8)) : (l = 0),
      (R = bs(3, null, null, l)),
      (s.current = R),
      (R.stateNode = s),
      (R.memoizedState = {
        element: _,
        isDehydrated: p,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      fn(R),
      s
    );
  }
  function M1(s, l, p) {
    var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: N,
      key: _ == null ? null : '' + _,
      children: s,
      containerInfo: l,
      implementation: p,
    };
  }
  function sx(s) {
    if (!s) return Js;
    s = s._reactInternals;
    e: {
      if (W(s) !== s || s.tag !== 1) throw Error(t(170));
      var l = s;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (Hi(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(t(171));
    }
    if (s.tag === 1) {
      var p = s.type;
      if (Hi(p)) return Ql(s, p, l);
    }
    return l;
  }
  function ox(s, l, p, _, w, R, O, $, ae) {
    return (
      (s = Hv(p, _, !0, s, w, R, O, $, ae)),
      (s.context = sx(null)),
      (p = s.current),
      (_ = Lr()),
      (w = ll(p)),
      (R = On(_, w)),
      (R.callback = l ?? null),
      Zn(p, R, w),
      (s.current.lanes = w),
      Cn(s, w, _),
      jr(s, _),
      s
    );
  }
  function zp(s, l, p, _) {
    var w = l.current,
      R = Lr(),
      O = ll(w);
    return (
      (p = sx(p)),
      l.context === null ? (l.context = p) : (l.pendingContext = p),
      (l = On(R, O)),
      (l.payload = { element: s }),
      (_ = _ === void 0 ? null : _),
      _ !== null && (l.callback = _),
      (s = Zn(w, l, O)),
      s !== null && (so(s, w, O, R), Gi(s, w, O)),
      O
    );
  }
  function Hp(s) {
    if (((s = s.current), !s.child)) return null;
    switch (s.child.tag) {
      case 5:
        return s.child.stateNode;
      default:
        return s.child.stateNode;
    }
  }
  function ax(s, l) {
    if (((s = s.memoizedState), s !== null && s.dehydrated !== null)) {
      var p = s.retryLane;
      s.retryLane = p !== 0 && p < l ? p : l;
    }
  }
  function Gv(s, l) {
    ax(s, l), (s = s.alternate) && ax(s, l);
  }
  var lx =
    typeof reportError == 'function'
      ? reportError
      : function (s) {
          console.error(s);
        };
  function Vv(s) {
    this._internalRoot = s;
  }
  (Gp.prototype.render = Vv.prototype.render =
    function (s) {
      var l = this._internalRoot;
      if (l === null) throw Error(t(409));
      zp(s, l, null, null);
    }),
    (Gp.prototype.unmount = Vv.prototype.unmount =
      function () {
        var s = this._internalRoot;
        if (s !== null) {
          this._internalRoot = null;
          var l = s.containerInfo;
          mu(function () {
            zp(null, s, null, null);
          }),
            (l[Rr] = null);
        }
      });
  function Gp(s) {
    this._internalRoot = s;
  }
  Gp.prototype.unstable_scheduleHydration = function (s) {
    if (s) {
      var l = uc();
      s = { blockedOn: null, target: s, priority: l };
      for (var p = 0; p < xo.length && l !== 0 && l < xo[p].priority; p++);
      xo.splice(p, 0, s), p === 0 && dc(s);
    }
  };
  function Wv(s) {
    return !(!s || (s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11));
  }
  function Vp(s) {
    return !(
      !s ||
      (s.nodeType !== 1 &&
        s.nodeType !== 9 &&
        s.nodeType !== 11 &&
        (s.nodeType !== 8 || s.nodeValue !== ' react-mount-point-unstable '))
    );
  }
  function ux() {}
  function E1(s, l, p, _, w) {
    if (w) {
      if (typeof _ == 'function') {
        var R = _;
        _ = function () {
          var Te = Hp(O);
          R.call(Te);
        };
      }
      var O = ox(l, _, s, 0, null, !1, !1, '', ux);
      return (
        (s._reactRootContainer = O),
        (s[Rr] = O.current),
        Ka(s.nodeType === 8 ? s.parentNode : s),
        mu(),
        O
      );
    }
    for (; (w = s.lastChild); ) s.removeChild(w);
    if (typeof _ == 'function') {
      var $ = _;
      _ = function () {
        var Te = Hp(ae);
        $.call(Te);
      };
    }
    var ae = Hv(s, 0, !1, null, null, !1, !1, '', ux);
    return (
      (s._reactRootContainer = ae),
      (s[Rr] = ae.current),
      Ka(s.nodeType === 8 ? s.parentNode : s),
      mu(function () {
        zp(l, ae, p, _);
      }),
      ae
    );
  }
  function Wp(s, l, p, _, w) {
    var R = p._reactRootContainer;
    if (R) {
      var O = R;
      if (typeof w == 'function') {
        var $ = w;
        w = function () {
          var ae = Hp(O);
          $.call(ae);
        };
      }
      zp(l, O, s, w);
    } else O = E1(p, l, s, w, _);
    return Hp(O);
  }
  (Ll = function (s) {
    switch (s.tag) {
      case 3:
        var l = s.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var p = Wt(l.pendingLanes);
          p !== 0 && (ai(l, p | 1), jr(l, q()), !(In & 6) && ((sf = q() + 500), Es()));
        }
        break;
      case 13:
        mu(function () {
          var _ = us(s, 1);
          if (_ !== null) {
            var w = Lr();
            so(_, s, 1, w);
          }
        }),
          Gv(s, 1);
    }
  }),
    (jf = function (s) {
      if (s.tag === 13) {
        var l = us(s, 134217728);
        if (l !== null) {
          var p = Lr();
          so(l, s, 134217728, p);
        }
        Gv(s, 134217728);
      }
    }),
    (ep = function (s) {
      if (s.tag === 13) {
        var l = ll(s),
          p = us(s, l);
        if (p !== null) {
          var _ = Lr();
          so(p, s, l, _);
        }
        Gv(s, l);
      }
    }),
    (uc = function () {
      return xn;
    }),
    (cc = function (s, l) {
      var p = xn;
      try {
        return (xn = s), l();
      } finally {
        xn = p;
      }
    }),
    (ye = function (s, l, p) {
      switch (l) {
        case 'input':
          if ((yt(s, p), (l = p.name), p.type === 'radio' && l != null)) {
            for (p = s; p.parentNode; ) p = p.parentNode;
            for (
              p = p.querySelectorAll('input[name=' + JSON.stringify('' + l) + '][type="radio"]'),
                l = 0;
              l < p.length;
              l++
            ) {
              var _ = p[l];
              if (_ !== s && _.form === s.form) {
                var w = Hc(_);
                if (!w) throw Error(t(90));
                Ye(_), yt(_, w);
              }
            }
          }
          break;
        case 'textarea':
          Le(s, p);
          break;
        case 'select':
          (l = p.value), l != null && K(s, !!p.multiple, l, !1);
      }
    }),
    (_n = Fv),
    (Nn = mu);
  var w1 = { usingClientEntryPoint: !1, Events: [Xs, li, Hc, dt, Gt, Fv] },
    Gd = {
      findFiberByHostInstance: To,
      bundleType: 0,
      version: '18.3.1',
      rendererPackageName: 'react-dom',
    },
    C1 = {
      bundleType: Gd.bundleType,
      version: Gd.version,
      rendererPackageName: Gd.rendererPackageName,
      rendererConfig: Gd.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: B.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (s) {
        return (s = Pe(s)), s === null ? null : s.stateNode;
      },
      findFiberByHostInstance: Gd.findFiberByHostInstance,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: '18.3.1-next-f1338f8080-20240426',
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var Xp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Xp.isDisabled && Xp.supportsFiber)
      try {
        (ut = Xp.inject(C1)), (Xe = Xp);
      } catch {}
  }
  return (
    (Zr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = w1),
    (Zr.createPortal = function (s, l) {
      var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Wv(l)) throw Error(t(200));
      return M1(s, l, null, p);
    }),
    (Zr.createRoot = function (s, l) {
      if (!Wv(s)) throw Error(t(299));
      var p = !1,
        _ = '',
        w = lx;
      return (
        l != null &&
          (l.unstable_strictMode === !0 && (p = !0),
          l.identifierPrefix !== void 0 && (_ = l.identifierPrefix),
          l.onRecoverableError !== void 0 && (w = l.onRecoverableError)),
        (l = Hv(s, 1, !1, null, null, p, !1, _, w)),
        (s[Rr] = l.current),
        Ka(s.nodeType === 8 ? s.parentNode : s),
        new Vv(l)
      );
    }),
    (Zr.findDOMNode = function (s) {
      if (s == null) return null;
      if (s.nodeType === 1) return s;
      var l = s._reactInternals;
      if (l === void 0)
        throw typeof s.render == 'function'
          ? Error(t(188))
          : ((s = Object.keys(s).join(',')), Error(t(268, s)));
      return (s = Pe(l)), (s = s === null ? null : s.stateNode), s;
    }),
    (Zr.flushSync = function (s) {
      return mu(s);
    }),
    (Zr.hydrate = function (s, l, p) {
      if (!Vp(l)) throw Error(t(200));
      return Wp(null, s, l, !0, p);
    }),
    (Zr.hydrateRoot = function (s, l, p) {
      if (!Wv(s)) throw Error(t(405));
      var _ = (p != null && p.hydratedSources) || null,
        w = !1,
        R = '',
        O = lx;
      if (
        (p != null &&
          (p.unstable_strictMode === !0 && (w = !0),
          p.identifierPrefix !== void 0 && (R = p.identifierPrefix),
          p.onRecoverableError !== void 0 && (O = p.onRecoverableError)),
        (l = ox(l, null, s, 1, p ?? null, w, !1, R, O)),
        (s[Rr] = l.current),
        Ka(s),
        _)
      )
        for (s = 0; s < _.length; s++)
          (p = _[s]),
            (w = p._getVersion),
            (w = w(p._source)),
            l.mutableSourceEagerHydrationData == null
              ? (l.mutableSourceEagerHydrationData = [p, w])
              : l.mutableSourceEagerHydrationData.push(p, w);
      return new Gp(l);
    }),
    (Zr.render = function (s, l, p) {
      if (!Vp(l)) throw Error(t(200));
      return Wp(null, s, l, !1, p);
    }),
    (Zr.unmountComponentAtNode = function (s) {
      if (!Vp(s)) throw Error(t(40));
      return s._reactRootContainer
        ? (mu(function () {
            Wp(null, null, s, !1, function () {
              (s._reactRootContainer = null), (s[Rr] = null);
            });
          }),
          !0)
        : !1;
    }),
    (Zr.unstable_batchedUpdates = Fv),
    (Zr.unstable_renderSubtreeIntoContainer = function (s, l, p, _) {
      if (!Vp(p)) throw Error(t(200));
      if (s == null || s._reactInternals === void 0) throw Error(t(38));
      return Wp(s, l, p, !1, _);
    }),
    (Zr.version = '18.3.1-next-f1338f8080-20240426'),
    Zr
  );
}
var vx;
function F1() {
  if (vx) return Yv.exports;
  vx = 1;
  function r() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r);
      } catch (e) {
        console.error(e);
      }
  }
  return r(), (Yv.exports = L1()), Yv.exports;
}
var yx;
function N1() {
  if (yx) return Jp;
  yx = 1;
  var r = F1();
  return (Jp.createRoot = r.createRoot), (Jp.hydrateRoot = r.hydrateRoot), Jp;
}
var U1 = N1();
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Dh = '173',
  Du = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Lu = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  RS = 0,
  ry = 1,
  bS = 2,
  O1 = 3,
  IS = 0,
  Ug = 1,
  ch = 2,
  co = 3,
  Uo = 0,
  Or = 1,
  gs = 2,
  Do = 0,
  Ju = 1,
  sy = 2,
  oy = 3,
  ay = 4,
  BS = 5,
  Ml = 100,
  PS = 101,
  DS = 102,
  LS = 103,
  FS = 104,
  NS = 200,
  US = 201,
  OS = 202,
  kS = 203,
  jm = 204,
  Zm = 205,
  zS = 206,
  HS = 207,
  GS = 208,
  VS = 209,
  WS = 210,
  XS = 211,
  JS = 212,
  YS = 213,
  KS = 214,
  Qm = 0,
  qm = 1,
  $m = 2,
  Qu = 3,
  eg = 4,
  tg = 5,
  ng = 6,
  ig = 7,
  Lh = 0,
  jS = 1,
  ZS = 2,
  Lo = 0,
  QS = 1,
  qS = 2,
  $S = 3,
  Ty = 4,
  eM = 5,
  tM = 6,
  nM = 7,
  ly = 'attached',
  iM = 'detached',
  Cl = 300,
  Oo = 301,
  Tl = 302,
  Nf = 303,
  xh = 304,
  Xf = 306,
  Rl = 1e3,
  Ai = 1001,
  Uf = 1002,
  Ki = 1003,
  Og = 1004,
  k1 = 1004,
  Ou = 1005,
  z1 = 1005,
  Fn = 1006,
  Pf = 1007,
  H1 = 1007,
  Ds = 1008,
  uy = 1008,
  ns = 1009,
  kg = 1010,
  zg = 1011,
  Of = 1012,
  Fh = 1013,
  ko = 1014,
  fi = 1015,
  Yi = 1016,
  Hg = 1017,
  Gg = 1018,
  qu = 1020,
  Ry = 35902,
  by = 1021,
  Iy = 1022,
  Si = 1023,
  By = 1024,
  Py = 1025,
  Yu = 1026,
  $u = 1027,
  Nh = 1028,
  Uh = 1029,
  Dy = 1030,
  Vg = 1031,
  G1 = 1032,
  Wg = 1033,
  fh = 33776,
  dh = 33777,
  hh = 33778,
  ph = 33779,
  rg = 35840,
  sg = 35841,
  og = 35842,
  ag = 35843,
  lg = 36196,
  ug = 37492,
  cg = 37496,
  fg = 37808,
  dg = 37809,
  hg = 37810,
  pg = 37811,
  mg = 37812,
  gg = 37813,
  vg = 37814,
  yg = 37815,
  _g = 37816,
  xg = 37817,
  Ag = 37818,
  Sg = 37819,
  Mg = 37820,
  Eg = 37821,
  mh = 36492,
  wg = 36494,
  Cg = 36495,
  Ly = 36283,
  Tg = 36284,
  Rg = 36285,
  bg = 36286,
  rM = 2200,
  sM = 2201,
  oM = 2202,
  kf = 2300,
  zf = 2301,
  Xm = 2302,
  ku = 2400,
  zu = 2401,
  Ah = 2402,
  Xg = 2500,
  Fy = 2501,
  aM = 0,
  Ny = 1,
  Ig = 2,
  lM = 3200,
  uM = 3201,
  V1 = 3202,
  W1 = 3203,
  Il = 0,
  cM = 1,
  ba = '',
  xr = 'srgb',
  zo = 'srgb-linear',
  Sh = 'linear',
  zn = 'srgb',
  X1 = 0,
  Fu = 7680,
  J1 = 7681,
  Y1 = 7682,
  K1 = 7683,
  j1 = 34055,
  Z1 = 34056,
  Q1 = 5386,
  q1 = 512,
  $1 = 513,
  ew = 514,
  tw = 515,
  nw = 516,
  iw = 517,
  rw = 518,
  cy = 519,
  fM = 512,
  dM = 513,
  hM = 514,
  Uy = 515,
  pM = 516,
  mM = 517,
  gM = 518,
  vM = 519,
  Mh = 35044,
  sw = 35048,
  ow = 35040,
  aw = 35045,
  lw = 35049,
  uw = 35041,
  cw = 35046,
  fw = 35050,
  dw = 35042,
  hw = '100',
  fy = '300 es',
  ho = 2e3,
  Eh = 2001,
  pw = { COMPUTE: 'compute', RENDER: 'render' };
let Ho = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const i = n[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, a = i.length; o < a; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const vr = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
];
let _x = 1234567;
const Ku = Math.PI / 180,
  Hf = 180 / Math.PI;
function vs() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    vr[r & 255] +
    vr[(r >> 8) & 255] +
    vr[(r >> 16) & 255] +
    vr[(r >> 24) & 255] +
    '-' +
    vr[e & 255] +
    vr[(e >> 8) & 255] +
    '-' +
    vr[((e >> 16) & 15) | 64] +
    vr[(e >> 24) & 255] +
    '-' +
    vr[(t & 63) | 128] +
    vr[(t >> 8) & 255] +
    '-' +
    vr[(t >> 16) & 255] +
    vr[(t >> 24) & 255] +
    vr[n & 255] +
    vr[(n >> 8) & 255] +
    vr[(n >> 16) & 255] +
    vr[(n >> 24) & 255]
  ).toLowerCase();
}
function un(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function Oy(r, e) {
  return ((r % e) + e) % e;
}
function mw(r, e, t, n, i) {
  return n + ((r - e) * (i - n)) / (t - e);
}
function gw(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function gh(r, e, t) {
  return (1 - t) * r + t * e;
}
function vw(r, e, t, n) {
  return gh(r, e, 1 - Math.exp(-t * n));
}
function yw(r, e = 1) {
  return e - Math.abs(Oy(r, e * 2) - e);
}
function _w(r, e, t) {
  return r <= e ? 0 : r >= t ? 1 : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function xw(r, e, t) {
  return r <= e ? 0 : r >= t ? 1 : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function Aw(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function Sw(r, e) {
  return r + Math.random() * (e - r);
}
function Mw(r) {
  return r * (0.5 - Math.random());
}
function Ew(r) {
  r !== void 0 && (_x = r);
  let e = (_x += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function ww(r) {
  return r * Ku;
}
function Cw(r) {
  return r * Hf;
}
function Tw(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function Rw(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function bw(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function Iw(r, e, t, n, i) {
  const o = Math.cos,
    a = Math.sin,
    u = o(t / 2),
    d = a(t / 2),
    h = o((e + n) / 2),
    m = a((e + n) / 2),
    g = o((e - n) / 2),
    v = a((e - n) / 2),
    x = o((n - e) / 2),
    A = a((n - e) / 2);
  switch (i) {
    case 'XYX':
      r.set(u * m, d * g, d * v, u * h);
      break;
    case 'YZY':
      r.set(d * v, u * m, d * g, u * h);
      break;
    case 'ZXZ':
      r.set(d * g, d * v, u * m, u * h);
      break;
    case 'XZX':
      r.set(u * m, d * A, d * x, u * h);
      break;
    case 'YXY':
      r.set(d * x, u * m, d * A, u * h);
      break;
    case 'ZYZ':
      r.set(d * A, d * x, u * m, u * h);
      break;
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + i,
      );
  }
}
function Ur(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error('Invalid component type.');
  }
}
function gn(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error('Invalid component type.');
  }
}
const yM = {
  DEG2RAD: Ku,
  RAD2DEG: Hf,
  generateUUID: vs,
  clamp: un,
  euclideanModulo: Oy,
  mapLinear: mw,
  inverseLerp: gw,
  lerp: gh,
  damp: vw,
  pingpong: yw,
  smoothstep: _w,
  smootherstep: xw,
  randInt: Aw,
  randFloat: Sw,
  randFloatSpread: Mw,
  seededRandom: Ew,
  degToRad: ww,
  radToDeg: Cw,
  isPowerOfTwo: Tw,
  ceilPowerOfTwo: Rw,
  floorPowerOfTwo: bw,
  setQuaternionFromProperEuler: Iw,
  normalize: gn,
  denormalize: Ur,
};
class Ge {
  constructor(e = 0, t = 0) {
    (Ge.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (this.x = i[0] * t + i[3] * n + i[6]), (this.y = i[1] * t + i[4] * n + i[7]), this;
  }
  min(e) {
    return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
  }
  max(e) {
    return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
  }
  clamp(e, t) {
    return (this.x = un(this.x, e.x, t.x)), (this.y = un(this.y, e.y, t.y)), this;
  }
  clampScalar(e, t) {
    return (this.x = un(this.x, e, t)), (this.y = un(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(un(n, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(un(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      o = this.x - e.x,
      a = this.y - e.y;
    return (this.x = o * n - a * i + e.x), (this.y = o * i + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class dn {
  constructor(e, t, n, i, o, a, u, d, h) {
    (dn.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, o, a, u, d, h);
  }
  set(e, t, n, i, o, a, u, d, h) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[1] = i),
      (m[2] = u),
      (m[3] = t),
      (m[4] = o),
      (m[5] = d),
      (m[6] = n),
      (m[7] = a),
      (m[8] = h),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      o = this.elements,
      a = n[0],
      u = n[3],
      d = n[6],
      h = n[1],
      m = n[4],
      g = n[7],
      v = n[2],
      x = n[5],
      A = n[8],
      C = i[0],
      E = i[3],
      S = i[6],
      b = i[1],
      I = i[4],
      B = i[7],
      z = i[2],
      N = i[5],
      G = i[8];
    return (
      (o[0] = a * C + u * b + d * z),
      (o[3] = a * E + u * I + d * N),
      (o[6] = a * S + u * B + d * G),
      (o[1] = h * C + m * b + g * z),
      (o[4] = h * E + m * I + g * N),
      (o[7] = h * S + m * B + g * G),
      (o[2] = v * C + x * b + A * z),
      (o[5] = v * E + x * I + A * N),
      (o[8] = v * S + x * B + A * G),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      u = e[5],
      d = e[6],
      h = e[7],
      m = e[8];
    return t * a * m - t * u * h - n * o * m + n * u * d + i * o * h - i * a * d;
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      u = e[5],
      d = e[6],
      h = e[7],
      m = e[8],
      g = m * a - u * h,
      v = u * d - m * o,
      x = h * o - a * d,
      A = t * g + n * v + i * x;
    if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const C = 1 / A;
    return (
      (e[0] = g * C),
      (e[1] = (i * h - m * n) * C),
      (e[2] = (u * n - i * a) * C),
      (e[3] = v * C),
      (e[4] = (m * t - i * d) * C),
      (e[5] = (i * o - u * t) * C),
      (e[6] = x * C),
      (e[7] = (n * d - h * t) * C),
      (e[8] = (a * t - n * o) * C),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, o, a, u) {
    const d = Math.cos(o),
      h = Math.sin(o);
    return (
      this.set(
        n * d,
        n * h,
        -n * (d * a + h * u) + a + e,
        -i * h,
        i * d,
        -i * (-h * a + d * u) + u + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Zv.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Zv.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Zv.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Zv = new dn();
function _M(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
const Bw = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function bf(r, e) {
  return new Bw[r](e);
}
function wh(r) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', r);
}
function xM() {
  const r = wh('canvas');
  return (r.style.display = 'block'), r;
}
const xx = {};
function Cf(r) {
  r in xx || ((xx[r] = !0), console.warn(r));
}
function Pw(r, e, t) {
  return new Promise(function (n, i) {
    function o() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          i();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(o, t);
          break;
        default:
          n();
      }
    }
    setTimeout(o, t);
  });
}
function Dw(r) {
  const e = r.elements;
  (e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]);
}
function Lw(r) {
  const e = r.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const Ax = new dn().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  Sx = new dn().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function Fw() {
  const r = {
      enabled: !0,
      workingColorSpace: zo,
      spaces: {},
      convert: function (i, o, a) {
        return (
          this.enabled === !1 ||
            o === a ||
            !o ||
            !a ||
            (this.spaces[o].transfer === zn && ((i.r = Da(i.r)), (i.g = Da(i.g)), (i.b = Da(i.b))),
            this.spaces[o].primaries !== this.spaces[a].primaries &&
              (i.applyMatrix3(this.spaces[o].toXYZ), i.applyMatrix3(this.spaces[a].fromXYZ)),
            this.spaces[a].transfer === zn && ((i.r = Df(i.r)), (i.g = Df(i.g)), (i.b = Df(i.b)))),
          i
        );
      },
      fromWorkingColorSpace: function (i, o) {
        return this.convert(i, this.workingColorSpace, o);
      },
      toWorkingColorSpace: function (i, o) {
        return this.convert(i, o, this.workingColorSpace);
      },
      getPrimaries: function (i) {
        return this.spaces[i].primaries;
      },
      getTransfer: function (i) {
        return i === ba ? Sh : this.spaces[i].transfer;
      },
      getLuminanceCoefficients: function (i, o = this.workingColorSpace) {
        return i.fromArray(this.spaces[o].luminanceCoefficients);
      },
      define: function (i) {
        Object.assign(this.spaces, i);
      },
      _getMatrix: function (i, o, a) {
        return i.copy(this.spaces[o].toXYZ).multiply(this.spaces[a].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (i) {
        return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (i = this.workingColorSpace) {
        return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    n = [0.3127, 0.329];
  return (
    r.define({
      [zo]: {
        primaries: e,
        whitePoint: n,
        transfer: Sh,
        toXYZ: Ax,
        fromXYZ: Sx,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: xr },
        outputColorSpaceConfig: { drawingBufferColorSpace: xr },
      },
      [xr]: {
        primaries: e,
        whitePoint: n,
        transfer: zn,
        toXYZ: Ax,
        fromXYZ: Sx,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: xr },
      },
    }),
    r
  );
}
const bn = Fw();
function Da(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Df(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let af;
class AM {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      af === void 0 && (af = wh('canvas')), (af.width = e.width), (af.height = e.height);
      const n = af.getContext('2d');
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
        (t = af);
    }
    return t.toDataURL('image/png');
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
    ) {
      const t = wh('canvas');
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext('2d');
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let a = 0; a < o.length; a++) o[a] = Da(o[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Da(t[n] / 255) * 255))
          : (t[n] = Da(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.',
        ),
        e
      );
  }
}
let Nw = 0;
class Hu {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, 'id', { value: Nw++ }),
      (this.uuid = vs()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: '' },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let a = 0, u = i.length; a < u; a++)
          i[a].isDataTexture ? o.push(Qv(i[a].image)) : o.push(Qv(i[a]));
      } else o = Qv(i);
      n.url = o;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Qv(r) {
  return (typeof HTMLImageElement < 'u' && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && r instanceof ImageBitmap)
    ? AM.getDataURL(r)
    : r.data
    ? { data: Array.from(r.data), width: r.width, height: r.height, type: r.data.constructor.name }
    : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let Uw = 0;
class Ln extends Ho {
  constructor(
    e = Ln.DEFAULT_IMAGE,
    t = Ln.DEFAULT_MAPPING,
    n = Ai,
    i = Ai,
    o = Fn,
    a = Ds,
    u = Si,
    d = ns,
    h = Ln.DEFAULT_ANISOTROPY,
    m = ba,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: Uw++ }),
      (this.uuid = vs()),
      (this.name = ''),
      (this.source = new Hu(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = a),
      (this.anisotropy = h),
      (this.format = u),
      (this.internalFormat = null),
      (this.type = d),
      (this.offset = new Ge(0, 0)),
      (this.repeat = new Ge(1, 1)),
      (this.center = new Ge(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new dn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = m),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  transformUv(e) {
    if (this.mapping !== Cl) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Rl:
          e.x = e.x - Math.floor(e.x);
          break;
        case Ai:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Uf:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Rl:
          e.y = e.y - Math.floor(e.y);
          break;
        case Ai:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Uf:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ln.DEFAULT_IMAGE = null;
Ln.DEFAULT_MAPPING = Cl;
Ln.DEFAULT_ANISOTROPY = 1;
class Bn {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (Bn.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = n), (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== void 0 ? e.w : 1), this
    );
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      o = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * o),
      (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * o),
      (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * o),
      (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * o),
      this
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, o;
    const d = e.elements,
      h = d[0],
      m = d[4],
      g = d[8],
      v = d[1],
      x = d[5],
      A = d[9],
      C = d[2],
      E = d[6],
      S = d[10];
    if (Math.abs(m - v) < 0.01 && Math.abs(g - C) < 0.01 && Math.abs(A - E) < 0.01) {
      if (
        Math.abs(m + v) < 0.1 &&
        Math.abs(g + C) < 0.1 &&
        Math.abs(A + E) < 0.1 &&
        Math.abs(h + x + S - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const I = (h + 1) / 2,
        B = (x + 1) / 2,
        z = (S + 1) / 2,
        N = (m + v) / 4,
        G = (g + C) / 4,
        k = (A + E) / 4;
      return (
        I > B && I > z
          ? I < 0.01
            ? ((n = 0), (i = 0.707106781), (o = 0.707106781))
            : ((n = Math.sqrt(I)), (i = N / n), (o = G / n))
          : B > z
          ? B < 0.01
            ? ((n = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(B)), (n = N / i), (o = k / i))
          : z < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(z)), (n = G / o), (i = k / o)),
        this.set(n, i, o, t),
        this
      );
    }
    let b = Math.sqrt((E - A) * (E - A) + (g - C) * (g - C) + (v - m) * (v - m));
    return (
      Math.abs(b) < 0.001 && (b = 1),
      (this.x = (E - A) / b),
      (this.y = (g - C) / b),
      (this.z = (v - m) / b),
      (this.w = Math.acos((h + x + S - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), (this.w = t[15]), this;
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = un(this.x, e.x, t.x)),
      (this.y = un(this.y, e.y, t.y)),
      (this.z = un(this.z, e.z, t.z)),
      (this.w = un(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = un(this.x, e, t)),
      (this.y = un(this.y, e, t)),
      (this.z = un(this.z, e, t)),
      (this.w = un(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(un(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Jg extends Ho {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Bn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Bn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Fn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n,
    );
    const o = new Ln(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace,
    );
    (o.flipY = !1),
      (o.generateMipmaps = n.generateMipmaps),
      (o.internalFormat = n.internalFormat),
      (this.textures = []);
    const a = n.count;
    for (let u = 0; u < a; u++)
      (this.textures[u] = o.clone()),
        (this.textures[u].isRenderTargetTexture = !0),
        (this.textures[u].renderTarget = this);
    (this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, o = this.textures.length; i < o; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = n);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let n = 0, i = e.textures.length; n < i; n++)
      (this.textures[n] = e.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0),
        (this.textures[n].renderTarget = this);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Hu(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
class Ls extends Jg {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), (this.isWebGLRenderTarget = !0);
  }
}
class Oh extends Ln {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Ki),
      (this.minFilter = Ki),
      (this.wrapR = Ai),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Ow extends Ls {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Oh(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Yg extends Ln {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = Ki),
      (this.minFilter = Ki),
      (this.wrapR = Ai),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class kw extends Ls {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Yg(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class ji {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = n), (this._w = i);
  }
  static slerpFlat(e, t, n, i, o, a, u) {
    let d = n[i + 0],
      h = n[i + 1],
      m = n[i + 2],
      g = n[i + 3];
    const v = o[a + 0],
      x = o[a + 1],
      A = o[a + 2],
      C = o[a + 3];
    if (u === 0) {
      (e[t + 0] = d), (e[t + 1] = h), (e[t + 2] = m), (e[t + 3] = g);
      return;
    }
    if (u === 1) {
      (e[t + 0] = v), (e[t + 1] = x), (e[t + 2] = A), (e[t + 3] = C);
      return;
    }
    if (g !== C || d !== v || h !== x || m !== A) {
      let E = 1 - u;
      const S = d * v + h * x + m * A + g * C,
        b = S >= 0 ? 1 : -1,
        I = 1 - S * S;
      if (I > Number.EPSILON) {
        const z = Math.sqrt(I),
          N = Math.atan2(z, S * b);
        (E = Math.sin(E * N) / z), (u = Math.sin(u * N) / z);
      }
      const B = u * b;
      if (
        ((d = d * E + v * B),
        (h = h * E + x * B),
        (m = m * E + A * B),
        (g = g * E + C * B),
        E === 1 - u)
      ) {
        const z = 1 / Math.sqrt(d * d + h * h + m * m + g * g);
        (d *= z), (h *= z), (m *= z), (g *= z);
      }
    }
    (e[t] = d), (e[t + 1] = h), (e[t + 2] = m), (e[t + 3] = g);
  }
  static multiplyQuaternionsFlat(e, t, n, i, o, a) {
    const u = n[i],
      d = n[i + 1],
      h = n[i + 2],
      m = n[i + 3],
      g = o[a],
      v = o[a + 1],
      x = o[a + 2],
      A = o[a + 3];
    return (
      (e[t] = u * A + m * g + d * x - h * v),
      (e[t + 1] = d * A + m * v + h * g - u * x),
      (e[t + 2] = h * A + m * x + u * v - d * g),
      (e[t + 3] = m * A - u * g - d * v - h * x),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e), (this._y = t), (this._z = n), (this._w = i), this._onChangeCallback(), this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const n = e._x,
      i = e._y,
      o = e._z,
      a = e._order,
      u = Math.cos,
      d = Math.sin,
      h = u(n / 2),
      m = u(i / 2),
      g = u(o / 2),
      v = d(n / 2),
      x = d(i / 2),
      A = d(o / 2);
    switch (a) {
      case 'XYZ':
        (this._x = v * m * g + h * x * A),
          (this._y = h * x * g - v * m * A),
          (this._z = h * m * A + v * x * g),
          (this._w = h * m * g - v * x * A);
        break;
      case 'YXZ':
        (this._x = v * m * g + h * x * A),
          (this._y = h * x * g - v * m * A),
          (this._z = h * m * A - v * x * g),
          (this._w = h * m * g + v * x * A);
        break;
      case 'ZXY':
        (this._x = v * m * g - h * x * A),
          (this._y = h * x * g + v * m * A),
          (this._z = h * m * A + v * x * g),
          (this._w = h * m * g - v * x * A);
        break;
      case 'ZYX':
        (this._x = v * m * g - h * x * A),
          (this._y = h * x * g + v * m * A),
          (this._z = h * m * A - v * x * g),
          (this._w = h * m * g + v * x * A);
        break;
      case 'YZX':
        (this._x = v * m * g + h * x * A),
          (this._y = h * x * g + v * m * A),
          (this._z = h * m * A - v * x * g),
          (this._w = h * m * g - v * x * A);
        break;
      case 'XZY':
        (this._x = v * m * g - h * x * A),
          (this._y = h * x * g - v * m * A),
          (this._z = h * m * A + v * x * g),
          (this._w = h * m * g + v * x * A);
        break;
      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + a);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      o = t[8],
      a = t[1],
      u = t[5],
      d = t[9],
      h = t[2],
      m = t[6],
      g = t[10],
      v = n + u + g;
    if (v > 0) {
      const x = 0.5 / Math.sqrt(v + 1);
      (this._w = 0.25 / x),
        (this._x = (m - d) * x),
        (this._y = (o - h) * x),
        (this._z = (a - i) * x);
    } else if (n > u && n > g) {
      const x = 2 * Math.sqrt(1 + n - u - g);
      (this._w = (m - d) / x),
        (this._x = 0.25 * x),
        (this._y = (i + a) / x),
        (this._z = (o + h) / x);
    } else if (u > g) {
      const x = 2 * Math.sqrt(1 + u - n - g);
      (this._w = (o - h) / x),
        (this._x = (i + a) / x),
        (this._y = 0.25 * x),
        (this._z = (d + m) / x);
    } else {
      const x = 2 * Math.sqrt(1 + g - n - u);
      (this._w = (a - i) / x),
        (this._x = (o + h) / x),
        (this._y = (d + m) / x),
        (this._z = 0.25 * x);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(un(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      o = e._z,
      a = e._w,
      u = t._x,
      d = t._y,
      h = t._z,
      m = t._w;
    return (
      (this._x = n * m + a * u + i * h - o * d),
      (this._y = i * m + a * d + o * u - n * h),
      (this._z = o * m + a * h + n * d - i * u),
      (this._w = a * m - n * u - i * d - o * h),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      o = this._z,
      a = this._w;
    let u = a * e._w + n * e._x + i * e._y + o * e._z;
    if (
      (u < 0
        ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (u = -u))
        : this.copy(e),
      u >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = i), (this._z = o), this;
    const d = 1 - u * u;
    if (d <= Number.EPSILON) {
      const x = 1 - t;
      return (
        (this._w = x * a + t * this._w),
        (this._x = x * n + t * this._x),
        (this._y = x * i + t * this._y),
        (this._z = x * o + t * this._z),
        this.normalize(),
        this
      );
    }
    const h = Math.sqrt(d),
      m = Math.atan2(h, u),
      g = Math.sin((1 - t) * m) / h,
      v = Math.sin(t * m) / h;
    return (
      (this._w = a * g + this._w * v),
      (this._x = n * g + this._x * v),
      (this._y = i * g + this._y * v),
      (this._z = o * g + this._z * v),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      o = Math.sqrt(n);
    return this.set(i * Math.sin(e), i * Math.cos(e), o * Math.sin(t), o * Math.cos(t));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class J {
  constructor(e = 0, t = 0, n = 0) {
    (J.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), (this.x = e), (this.y = t), (this.z = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Mx.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Mx.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * n + o[6] * i),
      (this.y = o[1] * t + o[4] * n + o[7] * i),
      (this.z = o[2] * t + o[5] * n + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      o = e.elements,
      a = 1 / (o[3] * t + o[7] * n + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * n + o[8] * i + o[12]) * a),
      (this.y = (o[1] * t + o[5] * n + o[9] * i + o[13]) * a),
      (this.z = (o[2] * t + o[6] * n + o[10] * i + o[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      o = e.x,
      a = e.y,
      u = e.z,
      d = e.w,
      h = 2 * (a * i - u * n),
      m = 2 * (u * t - o * i),
      g = 2 * (o * n - a * t);
    return (
      (this.x = t + d * h + a * g - u * m),
      (this.y = n + d * m + u * h - o * g),
      (this.z = i + d * g + o * m - a * h),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * n + o[8] * i),
      (this.y = o[1] * t + o[5] * n + o[9] * i),
      (this.z = o[2] * t + o[6] * n + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = un(this.x, e.x, t.x)),
      (this.y = un(this.y, e.y, t.y)),
      (this.z = un(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = un(this.x, e, t)), (this.y = un(this.y, e, t)), (this.z = un(this.z, e, t)), this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(un(n, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      o = e.z,
      a = t.x,
      u = t.y,
      d = t.z;
    return (this.x = i * d - o * u), (this.y = o * a - n * d), (this.z = n * u - i * a), this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return qv.copy(this).projectOnVector(e), this.sub(qv);
  }
  reflect(e) {
    return this.sub(qv.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(un(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (this.x = i * Math.sin(n)), (this.y = Math.cos(t) * e), (this.z = i * Math.cos(n)), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      n = Math.sqrt(1 - t * t);
    return (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const qv = new J(),
  Mx = new ji();
class Ar {
  constructor(e = new J(1 / 0, 1 / 0, 1 / 0), t = new J(-1 / 0, -1 / 0, -1 / 0)) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(oo.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(oo.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = oo.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const o = n.getAttribute('position');
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, u = o.count; a < u; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, oo) : oo.fromBufferAttribute(o, a),
            oo.applyMatrix4(e.matrixWorld),
            this.expandByPoint(oo);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(), Yp.copy(e.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(), Yp.copy(n.boundingBox)),
          Yp.applyMatrix4(e.matrixWorld),
          this.union(Yp);
    }
    const i = e.children;
    for (let o = 0, a = i.length; o < a; o++) this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, oo), oo.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Wd),
      Kp.subVectors(this.max, Wd),
      lf.subVectors(e.a, Wd),
      uf.subVectors(e.b, Wd),
      cf.subVectors(e.c, Wd),
      dl.subVectors(uf, lf),
      hl.subVectors(cf, uf),
      _u.subVectors(lf, cf);
    let t = [
      0,
      -dl.z,
      dl.y,
      0,
      -hl.z,
      hl.y,
      0,
      -_u.z,
      _u.y,
      dl.z,
      0,
      -dl.x,
      hl.z,
      0,
      -hl.x,
      _u.z,
      0,
      -_u.x,
      -dl.y,
      dl.x,
      0,
      -hl.y,
      hl.x,
      0,
      -_u.y,
      _u.x,
      0,
    ];
    return !$v(t, lf, uf, cf, Kp) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !$v(t, lf, uf, cf, Kp))
      ? !1
      : (jp.crossVectors(dl, hl), (t = [jp.x, jp.y, jp.z]), $v(t, lf, uf, cf, Kp));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, oo).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center), (e.radius = this.getSize(oo).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Aa[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Aa[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Aa[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Aa[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Aa[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Aa[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Aa[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Aa[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Aa),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Aa = [new J(), new J(), new J(), new J(), new J(), new J(), new J(), new J()],
  oo = new J(),
  Yp = new Ar(),
  lf = new J(),
  uf = new J(),
  cf = new J(),
  dl = new J(),
  hl = new J(),
  _u = new J(),
  Wd = new J(),
  Kp = new J(),
  jp = new J(),
  xu = new J();
function $v(r, e, t, n, i) {
  for (let o = 0, a = r.length - 3; o <= a; o += 3) {
    xu.fromArray(r, o);
    const u = i.x * Math.abs(xu.x) + i.y * Math.abs(xu.y) + i.z * Math.abs(xu.z),
      d = e.dot(xu),
      h = t.dot(xu),
      m = n.dot(xu);
    if (Math.max(-Math.max(d, h, m), Math.min(d, h, m)) > u) return !1;
  }
  return !0;
}
const zw = new Ar(),
  Xd = new J(),
  e0 = new J();
class or {
  constructor(e = new J(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : zw.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let o = 0, a = e.length; o < a; o++) i = Math.max(i, n.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Xd.subVectors(e, this.center);
    const t = Xd.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Xd, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (e0.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Xd.copy(e.center).add(e0)),
            this.expandByPoint(Xd.copy(e.center).sub(e0))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Sa = new J(),
  t0 = new J(),
  Zp = new J(),
  pl = new J(),
  n0 = new J(),
  Qp = new J(),
  i0 = new J();
class sc {
  constructor(e = new J(), t = new J(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Sa)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Sa.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Sa.copy(this.origin).addScaledVector(this.direction, t), Sa.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    t0.copy(e).add(t).multiplyScalar(0.5),
      Zp.copy(t).sub(e).normalize(),
      pl.copy(this.origin).sub(t0);
    const o = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(Zp),
      u = pl.dot(this.direction),
      d = -pl.dot(Zp),
      h = pl.lengthSq(),
      m = Math.abs(1 - a * a);
    let g, v, x, A;
    if (m > 0)
      if (((g = a * d - u), (v = a * u - d), (A = o * m), g >= 0))
        if (v >= -A)
          if (v <= A) {
            const C = 1 / m;
            (g *= C), (v *= C), (x = g * (g + a * v + 2 * u) + v * (a * g + v + 2 * d) + h);
          } else (v = o), (g = Math.max(0, -(a * v + u))), (x = -g * g + v * (v + 2 * d) + h);
        else (v = -o), (g = Math.max(0, -(a * v + u))), (x = -g * g + v * (v + 2 * d) + h);
      else
        v <= -A
          ? ((g = Math.max(0, -(-a * o + u))),
            (v = g > 0 ? -o : Math.min(Math.max(-o, -d), o)),
            (x = -g * g + v * (v + 2 * d) + h))
          : v <= A
          ? ((g = 0), (v = Math.min(Math.max(-o, -d), o)), (x = v * (v + 2 * d) + h))
          : ((g = Math.max(0, -(a * o + u))),
            (v = g > 0 ? o : Math.min(Math.max(-o, -d), o)),
            (x = -g * g + v * (v + 2 * d) + h));
    else (v = a > 0 ? -o : o), (g = Math.max(0, -(a * v + u))), (x = -g * g + v * (v + 2 * d) + h);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, g),
      i && i.copy(t0).addScaledVector(Zp, v),
      x
    );
  }
  intersectSphere(e, t) {
    Sa.subVectors(e.center, this.origin);
    const n = Sa.dot(this.direction),
      i = Sa.dot(Sa) - n * n,
      o = e.radius * e.radius;
    if (i > o) return null;
    const a = Math.sqrt(o - i),
      u = n - a,
      d = n + a;
    return d < 0 ? null : u < 0 ? this.at(d, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, o, a, u, d;
    const h = 1 / this.direction.x,
      m = 1 / this.direction.y,
      g = 1 / this.direction.z,
      v = this.origin;
    return (
      h >= 0
        ? ((n = (e.min.x - v.x) * h), (i = (e.max.x - v.x) * h))
        : ((n = (e.max.x - v.x) * h), (i = (e.min.x - v.x) * h)),
      m >= 0
        ? ((o = (e.min.y - v.y) * m), (a = (e.max.y - v.y) * m))
        : ((o = (e.max.y - v.y) * m), (a = (e.min.y - v.y) * m)),
      n > a ||
      o > i ||
      ((o > n || isNaN(n)) && (n = o),
      (a < i || isNaN(i)) && (i = a),
      g >= 0
        ? ((u = (e.min.z - v.z) * g), (d = (e.max.z - v.z) * g))
        : ((u = (e.max.z - v.z) * g), (d = (e.min.z - v.z) * g)),
      n > d || u > i) ||
      ((u > n || n !== n) && (n = u), (d < i || i !== i) && (i = d), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Sa) !== null;
  }
  intersectTriangle(e, t, n, i, o) {
    n0.subVectors(t, e), Qp.subVectors(n, e), i0.crossVectors(n0, Qp);
    let a = this.direction.dot(i0),
      u;
    if (a > 0) {
      if (i) return null;
      u = 1;
    } else if (a < 0) (u = -1), (a = -a);
    else return null;
    pl.subVectors(this.origin, e);
    const d = u * this.direction.dot(Qp.crossVectors(pl, Qp));
    if (d < 0) return null;
    const h = u * this.direction.dot(n0.cross(pl));
    if (h < 0 || d + h > a) return null;
    const m = -u * pl.dot(i0);
    return m < 0 ? null : this.at(m / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qt {
  constructor(e, t, n, i, o, a, u, d, h, m, g, v, x, A, C, E) {
    (Qt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, o, a, u, d, h, m, g, v, x, A, C, E);
  }
  set(e, t, n, i, o, a, u, d, h, m, g, v, x, A, C, E) {
    const S = this.elements;
    return (
      (S[0] = e),
      (S[4] = t),
      (S[8] = n),
      (S[12] = i),
      (S[1] = o),
      (S[5] = a),
      (S[9] = u),
      (S[13] = d),
      (S[2] = h),
      (S[6] = m),
      (S[10] = g),
      (S[14] = v),
      (S[3] = x),
      (S[7] = A),
      (S[11] = C),
      (S[15] = E),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Qt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / ff.setFromMatrixColumn(e, 0).length(),
      o = 1 / ff.setFromMatrixColumn(e, 1).length(),
      a = 1 / ff.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * o),
      (t[5] = n[5] * o),
      (t[6] = n[6] * o),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      o = e.z,
      a = Math.cos(n),
      u = Math.sin(n),
      d = Math.cos(i),
      h = Math.sin(i),
      m = Math.cos(o),
      g = Math.sin(o);
    if (e.order === 'XYZ') {
      const v = a * m,
        x = a * g,
        A = u * m,
        C = u * g;
      (t[0] = d * m),
        (t[4] = -d * g),
        (t[8] = h),
        (t[1] = x + A * h),
        (t[5] = v - C * h),
        (t[9] = -u * d),
        (t[2] = C - v * h),
        (t[6] = A + x * h),
        (t[10] = a * d);
    } else if (e.order === 'YXZ') {
      const v = d * m,
        x = d * g,
        A = h * m,
        C = h * g;
      (t[0] = v + C * u),
        (t[4] = A * u - x),
        (t[8] = a * h),
        (t[1] = a * g),
        (t[5] = a * m),
        (t[9] = -u),
        (t[2] = x * u - A),
        (t[6] = C + v * u),
        (t[10] = a * d);
    } else if (e.order === 'ZXY') {
      const v = d * m,
        x = d * g,
        A = h * m,
        C = h * g;
      (t[0] = v - C * u),
        (t[4] = -a * g),
        (t[8] = A + x * u),
        (t[1] = x + A * u),
        (t[5] = a * m),
        (t[9] = C - v * u),
        (t[2] = -a * h),
        (t[6] = u),
        (t[10] = a * d);
    } else if (e.order === 'ZYX') {
      const v = a * m,
        x = a * g,
        A = u * m,
        C = u * g;
      (t[0] = d * m),
        (t[4] = A * h - x),
        (t[8] = v * h + C),
        (t[1] = d * g),
        (t[5] = C * h + v),
        (t[9] = x * h - A),
        (t[2] = -h),
        (t[6] = u * d),
        (t[10] = a * d);
    } else if (e.order === 'YZX') {
      const v = a * d,
        x = a * h,
        A = u * d,
        C = u * h;
      (t[0] = d * m),
        (t[4] = C - v * g),
        (t[8] = A * g + x),
        (t[1] = g),
        (t[5] = a * m),
        (t[9] = -u * m),
        (t[2] = -h * m),
        (t[6] = x * g + A),
        (t[10] = v - C * g);
    } else if (e.order === 'XZY') {
      const v = a * d,
        x = a * h,
        A = u * d,
        C = u * h;
      (t[0] = d * m),
        (t[4] = -g),
        (t[8] = h * m),
        (t[1] = v * g + C),
        (t[5] = a * m),
        (t[9] = x * g - A),
        (t[2] = A * g - x),
        (t[6] = u * m),
        (t[10] = C * g + v);
    }
    return (
      (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Hw, e, Gw);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      ps.subVectors(e, t),
      ps.lengthSq() === 0 && (ps.z = 1),
      ps.normalize(),
      ml.crossVectors(n, ps),
      ml.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (ps.x += 1e-4) : (ps.z += 1e-4),
        ps.normalize(),
        ml.crossVectors(n, ps)),
      ml.normalize(),
      qp.crossVectors(ps, ml),
      (i[0] = ml.x),
      (i[4] = qp.x),
      (i[8] = ps.x),
      (i[1] = ml.y),
      (i[5] = qp.y),
      (i[9] = ps.y),
      (i[2] = ml.z),
      (i[6] = qp.z),
      (i[10] = ps.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      o = this.elements,
      a = n[0],
      u = n[4],
      d = n[8],
      h = n[12],
      m = n[1],
      g = n[5],
      v = n[9],
      x = n[13],
      A = n[2],
      C = n[6],
      E = n[10],
      S = n[14],
      b = n[3],
      I = n[7],
      B = n[11],
      z = n[15],
      N = i[0],
      G = i[4],
      k = i[8],
      L = i[12],
      D = i[1],
      V = i[5],
      oe = i[9],
      ie = i[13],
      ce = i[2],
      xe = i[6],
      de = i[10],
      Ce = i[14],
      X = i[3],
      fe = i[7],
      te = i[11],
      Y = i[15];
    return (
      (o[0] = a * N + u * D + d * ce + h * X),
      (o[4] = a * G + u * V + d * xe + h * fe),
      (o[8] = a * k + u * oe + d * de + h * te),
      (o[12] = a * L + u * ie + d * Ce + h * Y),
      (o[1] = m * N + g * D + v * ce + x * X),
      (o[5] = m * G + g * V + v * xe + x * fe),
      (o[9] = m * k + g * oe + v * de + x * te),
      (o[13] = m * L + g * ie + v * Ce + x * Y),
      (o[2] = A * N + C * D + E * ce + S * X),
      (o[6] = A * G + C * V + E * xe + S * fe),
      (o[10] = A * k + C * oe + E * de + S * te),
      (o[14] = A * L + C * ie + E * Ce + S * Y),
      (o[3] = b * N + I * D + B * ce + z * X),
      (o[7] = b * G + I * V + B * xe + z * fe),
      (o[11] = b * k + I * oe + B * de + z * te),
      (o[15] = b * L + I * ie + B * Ce + z * Y),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      o = e[12],
      a = e[1],
      u = e[5],
      d = e[9],
      h = e[13],
      m = e[2],
      g = e[6],
      v = e[10],
      x = e[14],
      A = e[3],
      C = e[7],
      E = e[11],
      S = e[15];
    return (
      A * (+o * d * g - i * h * g - o * u * v + n * h * v + i * u * x - n * d * x) +
      C * (+t * d * x - t * h * v + o * a * v - i * a * x + i * h * m - o * d * m) +
      E * (+t * h * g - t * u * x - o * a * g + n * a * x + o * u * m - n * h * m) +
      S * (-i * u * m - t * d * g + t * u * v + i * a * g - n * a * v + n * d * m)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      o = e[3],
      a = e[4],
      u = e[5],
      d = e[6],
      h = e[7],
      m = e[8],
      g = e[9],
      v = e[10],
      x = e[11],
      A = e[12],
      C = e[13],
      E = e[14],
      S = e[15],
      b = g * E * h - C * v * h + C * d * x - u * E * x - g * d * S + u * v * S,
      I = A * v * h - m * E * h - A * d * x + a * E * x + m * d * S - a * v * S,
      B = m * C * h - A * g * h + A * u * x - a * C * x - m * u * S + a * g * S,
      z = A * g * d - m * C * d - A * u * v + a * C * v + m * u * E - a * g * E,
      N = t * b + n * I + i * B + o * z;
    if (N === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const G = 1 / N;
    return (
      (e[0] = b * G),
      (e[1] = (C * v * o - g * E * o - C * i * x + n * E * x + g * i * S - n * v * S) * G),
      (e[2] = (u * E * o - C * d * o + C * i * h - n * E * h - u * i * S + n * d * S) * G),
      (e[3] = (g * d * o - u * v * o - g * i * h + n * v * h + u * i * x - n * d * x) * G),
      (e[4] = I * G),
      (e[5] = (m * E * o - A * v * o + A * i * x - t * E * x - m * i * S + t * v * S) * G),
      (e[6] = (A * d * o - a * E * o - A * i * h + t * E * h + a * i * S - t * d * S) * G),
      (e[7] = (a * v * o - m * d * o + m * i * h - t * v * h - a * i * x + t * d * x) * G),
      (e[8] = B * G),
      (e[9] = (A * g * o - m * C * o - A * n * x + t * C * x + m * n * S - t * g * S) * G),
      (e[10] = (a * C * o - A * u * o + A * n * h - t * C * h - a * n * S + t * u * S) * G),
      (e[11] = (m * u * o - a * g * o - m * n * h + t * g * h + a * n * x - t * u * x) * G),
      (e[12] = z * G),
      (e[13] = (m * C * i - A * g * i + A * n * v - t * C * v - m * n * E + t * g * E) * G),
      (e[14] = (A * u * i - a * C * i - A * n * d + t * C * d + a * n * E - t * u * E) * G),
      (e[15] = (a * g * i - m * u * i + m * n * d - t * g * d - a * n * v + t * u * v) * G),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      o = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= o),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= o),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= o),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      o = 1 - n,
      a = e.x,
      u = e.y,
      d = e.z,
      h = o * a,
      m = o * u;
    return (
      this.set(
        h * a + n,
        h * u - i * d,
        h * d + i * u,
        0,
        h * u + i * d,
        m * u + n,
        m * d - i * a,
        0,
        h * d - i * u,
        m * d + i * a,
        o * d * d + n,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, o, a) {
    return this.set(1, n, o, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      o = t._x,
      a = t._y,
      u = t._z,
      d = t._w,
      h = o + o,
      m = a + a,
      g = u + u,
      v = o * h,
      x = o * m,
      A = o * g,
      C = a * m,
      E = a * g,
      S = u * g,
      b = d * h,
      I = d * m,
      B = d * g,
      z = n.x,
      N = n.y,
      G = n.z;
    return (
      (i[0] = (1 - (C + S)) * z),
      (i[1] = (x + B) * z),
      (i[2] = (A - I) * z),
      (i[3] = 0),
      (i[4] = (x - B) * N),
      (i[5] = (1 - (v + S)) * N),
      (i[6] = (E + b) * N),
      (i[7] = 0),
      (i[8] = (A + I) * G),
      (i[9] = (E - b) * G),
      (i[10] = (1 - (v + C)) * G),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let o = ff.set(i[0], i[1], i[2]).length();
    const a = ff.set(i[4], i[5], i[6]).length(),
      u = ff.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), (e.x = i[12]), (e.y = i[13]), (e.z = i[14]), ao.copy(this);
    const h = 1 / o,
      m = 1 / a,
      g = 1 / u;
    return (
      (ao.elements[0] *= h),
      (ao.elements[1] *= h),
      (ao.elements[2] *= h),
      (ao.elements[4] *= m),
      (ao.elements[5] *= m),
      (ao.elements[6] *= m),
      (ao.elements[8] *= g),
      (ao.elements[9] *= g),
      (ao.elements[10] *= g),
      t.setFromRotationMatrix(ao),
      (n.x = o),
      (n.y = a),
      (n.z = u),
      this
    );
  }
  makePerspective(e, t, n, i, o, a, u = ho) {
    const d = this.elements,
      h = (2 * o) / (t - e),
      m = (2 * o) / (n - i),
      g = (t + e) / (t - e),
      v = (n + i) / (n - i);
    let x, A;
    if (u === ho) (x = -(a + o) / (a - o)), (A = (-2 * a * o) / (a - o));
    else if (u === Eh) (x = -a / (a - o)), (A = (-a * o) / (a - o));
    else throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + u);
    return (
      (d[0] = h),
      (d[4] = 0),
      (d[8] = g),
      (d[12] = 0),
      (d[1] = 0),
      (d[5] = m),
      (d[9] = v),
      (d[13] = 0),
      (d[2] = 0),
      (d[6] = 0),
      (d[10] = x),
      (d[14] = A),
      (d[3] = 0),
      (d[7] = 0),
      (d[11] = -1),
      (d[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, o, a, u = ho) {
    const d = this.elements,
      h = 1 / (t - e),
      m = 1 / (n - i),
      g = 1 / (a - o),
      v = (t + e) * h,
      x = (n + i) * m;
    let A, C;
    if (u === ho) (A = (a + o) * g), (C = -2 * g);
    else if (u === Eh) (A = o * g), (C = -1 * g);
    else throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + u);
    return (
      (d[0] = 2 * h),
      (d[4] = 0),
      (d[8] = 0),
      (d[12] = -v),
      (d[1] = 0),
      (d[5] = 2 * m),
      (d[9] = 0),
      (d[13] = -x),
      (d[2] = 0),
      (d[6] = 0),
      (d[10] = C),
      (d[14] = -A),
      (d[3] = 0),
      (d[7] = 0),
      (d[11] = 0),
      (d[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const ff = new J(),
  ao = new Qt(),
  Hw = new J(0, 0, 0),
  Gw = new J(1, 1, 1),
  ml = new J(),
  qp = new J(),
  ps = new J(),
  Ex = new Qt(),
  wx = new ji();
class ys {
  constructor(e = 0, t = 0, n = 0, i = ys.DEFAULT_ORDER) {
    (this.isEuler = !0), (this._x = e), (this._y = t), (this._z = n), (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e), (this._y = t), (this._z = n), (this._order = i), this._onChangeCallback(), this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      o = i[0],
      a = i[4],
      u = i[8],
      d = i[1],
      h = i[5],
      m = i[9],
      g = i[2],
      v = i[6],
      x = i[10];
    switch (t) {
      case 'XYZ':
        (this._y = Math.asin(un(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-m, x)), (this._z = Math.atan2(-a, o)))
            : ((this._x = Math.atan2(v, h)), (this._z = 0));
        break;
      case 'YXZ':
        (this._x = Math.asin(-un(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._y = Math.atan2(u, x)), (this._z = Math.atan2(d, h)))
            : ((this._y = Math.atan2(-g, o)), (this._z = 0));
        break;
      case 'ZXY':
        (this._x = Math.asin(un(v, -1, 1))),
          Math.abs(v) < 0.9999999
            ? ((this._y = Math.atan2(-g, x)), (this._z = Math.atan2(-a, h)))
            : ((this._y = 0), (this._z = Math.atan2(d, o)));
        break;
      case 'ZYX':
        (this._y = Math.asin(-un(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._x = Math.atan2(v, x)), (this._z = Math.atan2(d, o)))
            : ((this._x = 0), (this._z = Math.atan2(-a, h)));
        break;
      case 'YZX':
        (this._z = Math.asin(un(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(-m, h)), (this._y = Math.atan2(-g, o)))
            : ((this._x = 0), (this._y = Math.atan2(u, x)));
        break;
      case 'XZY':
        (this._z = Math.asin(-un(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(v, h)), (this._y = Math.atan2(u, o)))
            : ((this._x = Math.atan2(-m, x)), (this._y = 0));
        break;
      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t);
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return Ex.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ex, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return wx.setFromEuler(this), this.setFromQuaternion(wx, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ys.DEFAULT_ORDER = 'XYZ';
class ju {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Vw = 0;
const Cx = new J(),
  df = new ji(),
  Ma = new Qt(),
  $p = new J(),
  Jd = new J(),
  Ww = new J(),
  Xw = new ji(),
  Tx = new J(1, 0, 0),
  Rx = new J(0, 1, 0),
  bx = new J(0, 0, 1),
  Ix = { type: 'added' },
  Jw = { type: 'removed' },
  hf = { type: 'childadded', child: null },
  r0 = { type: 'childremoved', child: null };
class wn extends Ho {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: Vw++ }),
      (this.uuid = vs()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = wn.DEFAULT_UP.clone());
    const e = new J(),
      t = new ys(),
      n = new ji(),
      i = new J(1, 1, 1);
    function o() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(o),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Qt() },
        normalMatrix: { value: new dn() },
      }),
      (this.matrix = new Qt()),
      (this.matrixWorld = new Qt()),
      (this.matrixAutoUpdate = wn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new ju()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return df.setFromAxisAngle(e, t), this.quaternion.multiply(df), this;
  }
  rotateOnWorldAxis(e, t) {
    return df.setFromAxisAngle(e, t), this.quaternion.premultiply(df), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Tx, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Rx, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(bx, e);
  }
  translateOnAxis(e, t) {
    return (
      Cx.copy(e).applyQuaternion(this.quaternion), this.position.add(Cx.multiplyScalar(t)), this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Tx, e);
  }
  translateY(e) {
    return this.translateOnAxis(Rx, e);
  }
  translateZ(e) {
    return this.translateOnAxis(bx, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ma.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? $p.copy(e) : $p.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Jd.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight ? Ma.lookAt(Jd, $p, this.up) : Ma.lookAt($p, Jd, this.up),
      this.quaternion.setFromRotationMatrix(Ma),
      i &&
        (Ma.extractRotation(i.matrixWorld),
        df.setFromRotationMatrix(Ma),
        this.quaternion.premultiply(df.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Ix),
            (hf.child = e),
            this.dispatchEvent(hf),
            (hf.child = null))
          : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', e),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(Jw),
        (r0.child = e),
        this.dispatchEvent(r0),
        (r0.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ma.copy(this.matrixWorld).invert(),
      e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ma.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ma),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(Ix),
      (hf.child = e),
      this.dispatchEvent(hf),
      (hf.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty('id', e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty('name', e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let o = 0, a = i.length; o < a; o++) i[o].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jd, e, Ww), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jd, Xw, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
      t === !0)
    ) {
      const i = this.children;
      for (let o = 0, a = i.length; o < a; o++) i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string',
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = { version: 4.6, type: 'Object', generator: 'Object3D.toJSON' }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = 'InstancedMesh'),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = 'BatchedMesh'),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((u) => ({
          boxInitialized: u.boxInitialized,
          boxMin: u.box.min.toArray(),
          boxMax: u.box.max.toArray(),
          sphereInitialized: u.sphereInitialized,
          sphereRadius: u.sphere.radius,
          sphereCenter: u.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = { min: i.boundingBox.min.toArray(), max: i.boundingBox.max.toArray() }));
    function o(u, d) {
      return u[d.uuid] === void 0 && (u[d.uuid] = d.toJSON(e)), d.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const d = u.shapes;
        if (Array.isArray(d))
          for (let h = 0, m = d.length; h < m; h++) {
            const g = d[h];
            o(e.shapes, g);
          }
        else o(e.shapes, d);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const u = [];
        for (let d = 0, h = this.material.length; d < h; d++)
          u.push(o(e.materials, this.material[d]));
        i.material = u;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let u = 0; u < this.children.length; u++)
        i.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const d = this.animations[u];
        i.animations.push(o(e.animations, d));
      }
    }
    if (t) {
      const u = a(e.geometries),
        d = a(e.materials),
        h = a(e.textures),
        m = a(e.images),
        g = a(e.shapes),
        v = a(e.skeletons),
        x = a(e.animations),
        A = a(e.nodes);
      u.length > 0 && (n.geometries = u),
        d.length > 0 && (n.materials = d),
        h.length > 0 && (n.textures = h),
        m.length > 0 && (n.images = m),
        g.length > 0 && (n.shapes = g),
        v.length > 0 && (n.skeletons = v),
        x.length > 0 && (n.animations = x),
        A.length > 0 && (n.nodes = A);
    }
    return (n.object = i), n;
    function a(u) {
      const d = [];
      for (const h in u) {
        const m = u[h];
        delete m.metadata, d.push(m);
      }
      return d;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
wn.DEFAULT_UP = new J(0, 1, 0);
wn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const lo = new J(),
  Ea = new J(),
  s0 = new J(),
  wa = new J(),
  pf = new J(),
  mf = new J(),
  Bx = new J(),
  o0 = new J(),
  a0 = new J(),
  l0 = new J(),
  u0 = new Bn(),
  c0 = new Bn(),
  f0 = new Bn();
class es {
  constructor(e = new J(), t = new J(), n = new J()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), lo.subVectors(e, t), i.cross(lo);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, o) {
    lo.subVectors(i, t), Ea.subVectors(n, t), s0.subVectors(e, t);
    const a = lo.dot(lo),
      u = lo.dot(Ea),
      d = lo.dot(s0),
      h = Ea.dot(Ea),
      m = Ea.dot(s0),
      g = a * h - u * u;
    if (g === 0) return o.set(0, 0, 0), null;
    const v = 1 / g,
      x = (h * d - u * m) * v,
      A = (a * m - u * d) * v;
    return o.set(1 - x - A, A, x);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, wa) === null
      ? !1
      : wa.x >= 0 && wa.y >= 0 && wa.x + wa.y <= 1;
  }
  static getInterpolation(e, t, n, i, o, a, u, d) {
    return this.getBarycoord(e, t, n, i, wa) === null
      ? ((d.x = 0), (d.y = 0), 'z' in d && (d.z = 0), 'w' in d && (d.w = 0), null)
      : (d.setScalar(0),
        d.addScaledVector(o, wa.x),
        d.addScaledVector(a, wa.y),
        d.addScaledVector(u, wa.z),
        d);
  }
  static getInterpolatedAttribute(e, t, n, i, o, a) {
    return (
      u0.setScalar(0),
      c0.setScalar(0),
      f0.setScalar(0),
      u0.fromBufferAttribute(e, t),
      c0.fromBufferAttribute(e, n),
      f0.fromBufferAttribute(e, i),
      a.setScalar(0),
      a.addScaledVector(u0, o.x),
      a.addScaledVector(c0, o.y),
      a.addScaledVector(f0, o.z),
      a
    );
  }
  static isFrontFacing(e, t, n, i) {
    return lo.subVectors(n, t), Ea.subVectors(e, t), lo.cross(Ea).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      lo.subVectors(this.c, this.b), Ea.subVectors(this.a, this.b), lo.cross(Ea).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return es.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return es.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, n, i, o) {
    return es.getInterpolation(e, this.a, this.b, this.c, t, n, i, o);
  }
  containsPoint(e) {
    return es.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return es.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      o = this.c;
    let a, u;
    pf.subVectors(i, n), mf.subVectors(o, n), o0.subVectors(e, n);
    const d = pf.dot(o0),
      h = mf.dot(o0);
    if (d <= 0 && h <= 0) return t.copy(n);
    a0.subVectors(e, i);
    const m = pf.dot(a0),
      g = mf.dot(a0);
    if (m >= 0 && g <= m) return t.copy(i);
    const v = d * g - m * h;
    if (v <= 0 && d >= 0 && m <= 0) return (a = d / (d - m)), t.copy(n).addScaledVector(pf, a);
    l0.subVectors(e, o);
    const x = pf.dot(l0),
      A = mf.dot(l0);
    if (A >= 0 && x <= A) return t.copy(o);
    const C = x * h - d * A;
    if (C <= 0 && h >= 0 && A <= 0) return (u = h / (h - A)), t.copy(n).addScaledVector(mf, u);
    const E = m * A - x * g;
    if (E <= 0 && g - m >= 0 && x - A >= 0)
      return (
        Bx.subVectors(o, i), (u = (g - m) / (g - m + (x - A))), t.copy(i).addScaledVector(Bx, u)
      );
    const S = 1 / (E + C + v);
    return (a = C * S), (u = v * S), t.copy(n).addScaledVector(pf, a).addScaledVector(mf, u);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const SM = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  gl = { h: 0, s: 0, l: 0 },
  em = { h: 0, s: 0, l: 0 };
function d0(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
  );
}
class At {
  constructor(e, t, n) {
    return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == 'number'
        ? this.setHex(i)
        : typeof i == 'string' && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = xr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      bn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = bn.workingColorSpace) {
    return (this.r = e), (this.g = t), (this.b = n), bn.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = bn.workingColorSpace) {
    if (((e = Oy(e, 1)), (t = un(t, 0, 1)), (n = un(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const o = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - o;
      (this.r = d0(a, o, e + 1 / 3)), (this.g = d0(a, o, e)), (this.b = d0(a, o, e - 1 / 3));
    }
    return bn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = xr) {
    function n(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const a = i[1],
        u = i[2];
      switch (a) {
        case 'rgb':
        case 'rgba':
          if ((o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u)))
            return (
              n(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                t,
              )
            );
          if ((o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u)))
            return (
              n(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                t,
              )
            );
          break;
        case 'hsl':
        case 'hsla':
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                u,
              ))
          )
            return (
              n(o[4]),
              this.setHSL(parseFloat(o[1]) / 360, parseFloat(o[2]) / 100, parseFloat(o[3]) / 100, t)
            );
          break;
        default:
          console.warn('THREE.Color: Unknown color model ' + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t,
        );
      if (a === 6) return this.setHex(parseInt(o, 16), t);
      console.warn('THREE.Color: Invalid hex color ' + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = xr) {
    const n = SM[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn('THREE.Color: Unknown color ' + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Da(e.r)), (this.g = Da(e.g)), (this.b = Da(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Df(e.r)), (this.g = Df(e.g)), (this.b = Df(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = xr) {
    return (
      bn.fromWorkingColorSpace(yr.copy(this), e),
      Math.round(un(yr.r * 255, 0, 255)) * 65536 +
        Math.round(un(yr.g * 255, 0, 255)) * 256 +
        Math.round(un(yr.b * 255, 0, 255))
    );
  }
  getHexString(e = xr) {
    return ('000000' + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = bn.workingColorSpace) {
    bn.fromWorkingColorSpace(yr.copy(this), t);
    const n = yr.r,
      i = yr.g,
      o = yr.b,
      a = Math.max(n, i, o),
      u = Math.min(n, i, o);
    let d, h;
    const m = (u + a) / 2;
    if (u === a) (d = 0), (h = 0);
    else {
      const g = a - u;
      switch (((h = m <= 0.5 ? g / (a + u) : g / (2 - a - u)), a)) {
        case n:
          d = (i - o) / g + (i < o ? 6 : 0);
          break;
        case i:
          d = (o - n) / g + 2;
          break;
        case o:
          d = (n - i) / g + 4;
          break;
      }
      d /= 6;
    }
    return (e.h = d), (e.s = h), (e.l = m), e;
  }
  getRGB(e, t = bn.workingColorSpace) {
    return bn.fromWorkingColorSpace(yr.copy(this), t), (e.r = yr.r), (e.g = yr.g), (e.b = yr.b), e;
  }
  getStyle(e = xr) {
    bn.fromWorkingColorSpace(yr.copy(this), e);
    const t = yr.r,
      n = yr.g,
      i = yr.b;
    return e !== xr
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(gl), this.setHSL(gl.h + e, gl.s + t, gl.l + n);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(gl), e.getHSL(em);
    const n = gh(gl.h, em.h, t),
      i = gh(gl.s, em.s, t),
      o = gh(gl.l, em.l, t);
    return this.setHSL(n, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * t + o[3] * n + o[6] * i),
      (this.g = o[1] * t + o[4] * n + o[7] * i),
      (this.b = o[2] * t + o[5] * n + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const yr = new At();
At.NAMES = SM;
let Yw = 0;
class Oi extends Ho {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: Yw++ }),
      (this.uuid = vs()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = Ju),
      (this.side = Uo),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = jm),
      (this.blendDst = Zm),
      (this.blendEquation = Ml),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new At(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Qu),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = cy),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Fu),
      (this.stencilZFail = Fu),
      (this.stencilZPass = Fu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    t && (e = { textures: {}, images: {} });
    const n = { metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' } };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== '' && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
      this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid), (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ju && (n.blending = this.blending),
      this.side !== Uo && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== jm && (n.blendSrc = this.blendSrc),
      this.blendDst !== Zm && (n.blendDst = this.blendDst),
      this.blendEquation !== Ml && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== Qu && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== cy && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Fu && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== Fu && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Fu && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' && (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' && (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(o) {
      const a = [];
      for (const u in o) {
        const d = o[u];
        delete d.metadata, a.push(d);
      }
      return a;
    }
    if (t) {
      const o = i(e.textures),
        a = i(e.images);
      o.length > 0 && (n.textures = o), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let o = 0; o !== i; ++o) n[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn('Material: onBuild() has been removed.');
  }
}
class ts extends Oi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Lh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ia = Kw();
function Kw() {
  const r = new ArrayBuffer(4),
    e = new Float32Array(r),
    t = new Uint32Array(r),
    n = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let d = 0; d < 256; ++d) {
    const h = d - 127;
    h < -27
      ? ((n[d] = 0), (n[d | 256] = 32768), (i[d] = 24), (i[d | 256] = 24))
      : h < -14
      ? ((n[d] = 1024 >> (-h - 14)),
        (n[d | 256] = (1024 >> (-h - 14)) | 32768),
        (i[d] = -h - 1),
        (i[d | 256] = -h - 1))
      : h <= 15
      ? ((n[d] = (h + 15) << 10),
        (n[d | 256] = ((h + 15) << 10) | 32768),
        (i[d] = 13),
        (i[d | 256] = 13))
      : h < 128
      ? ((n[d] = 31744), (n[d | 256] = 64512), (i[d] = 24), (i[d | 256] = 24))
      : ((n[d] = 31744), (n[d | 256] = 64512), (i[d] = 13), (i[d | 256] = 13));
  }
  const o = new Uint32Array(2048),
    a = new Uint32Array(64),
    u = new Uint32Array(64);
  for (let d = 1; d < 1024; ++d) {
    let h = d << 13,
      m = 0;
    for (; !(h & 8388608); ) (h <<= 1), (m -= 8388608);
    (h &= -8388609), (m += 947912704), (o[d] = h | m);
  }
  for (let d = 1024; d < 2048; ++d) o[d] = 939524096 + ((d - 1024) << 13);
  for (let d = 1; d < 31; ++d) a[d] = d << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let d = 33; d < 63; ++d) a[d] = 2147483648 + ((d - 32) << 23);
  a[63] = 3347054592;
  for (let d = 1; d < 64; ++d) d !== 32 && (u[d] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: a,
    offsetTable: u,
  };
}
function qr(r) {
  Math.abs(r) > 65504 && console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
    (r = un(r, -65504, 65504)),
    (Ia.floatView[0] = r);
  const e = Ia.uint32View[0],
    t = (e >> 23) & 511;
  return Ia.baseTable[t] + ((e & 8388607) >> Ia.shiftTable[t]);
}
function ah(r) {
  const e = r >> 10;
  return (
    (Ia.uint32View[0] = Ia.mantissaTable[Ia.offsetTable[e] + (r & 1023)] + Ia.exponentTable[e]),
    Ia.floatView[0]
  );
}
const Gu = { toHalfFloat: qr, fromHalfFloat: ah },
  bi = new J(),
  tm = new Ge();
let jw = 0;
class Pn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, 'id', { value: jw++ }),
      (this.name = ''),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Mh),
      (this.updateRanges = []),
      (this.gpuType = fi),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++) this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        tm.fromBufferAttribute(this, t), tm.applyMatrix3(e), this.setXY(t, tm.x, tm.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        bi.fromBufferAttribute(this, t), bi.applyMatrix3(e), this.setXYZ(t, bi.x, bi.y, bi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      bi.fromBufferAttribute(this, t), bi.applyMatrix4(e), this.setXYZ(t, bi.x, bi.y, bi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      bi.fromBufferAttribute(this, t), bi.applyNormalMatrix(e), this.setXYZ(t, bi.x, bi.y, bi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      bi.fromBufferAttribute(this, t), bi.transformDirection(e), this.setXYZ(t, bi.x, bi.y, bi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Ur(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = gn(n, this.array)), (this.array[e * this.itemSize + t] = n), this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize] = t), this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 1] = t), this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 2] = t), this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 3] = t), this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gn(t, this.array)), (n = gn(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)), (n = gn(n, this.array)), (i = gn(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)),
        (n = gn(n, this.array)),
        (i = gn(i, this.array)),
        (o = gn(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return this.name !== '' && (e.name = this.name), this.usage !== Mh && (e.usage = this.usage), e;
  }
}
class Zw extends Pn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class Qw extends Pn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class qw extends Pn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class $w extends Pn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class ky extends Pn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class eC extends Pn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class zy extends Pn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class tC extends Pn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = ah(this.array[e * this.itemSize]);
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize] = qr(t)), this
    );
  }
  getY(e) {
    let t = ah(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 1] = qr(t)), this
    );
  }
  getZ(e) {
    let t = ah(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 2] = qr(t)), this
    );
  }
  getW(e) {
    let t = ah(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)), (this.array[e * this.itemSize + 3] = qr(t)), this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gn(t, this.array)), (n = gn(n, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)), (n = gn(n, this.array)), (i = gn(i, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      (this.array[e + 2] = qr(i)),
      this
    );
  }
  setXYZW(e, t, n, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)),
        (n = gn(n, this.array)),
        (i = gn(i, this.array)),
        (o = gn(o, this.array))),
      (this.array[e + 0] = qr(t)),
      (this.array[e + 1] = qr(n)),
      (this.array[e + 2] = qr(i)),
      (this.array[e + 3] = qr(o)),
      this
    );
  }
}
class kt extends Pn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let nC = 0;
const Is = new Qt(),
  h0 = new wn(),
  gf = new J(),
  ms = new Ar(),
  Yd = new Ar(),
  Ji = new J();
class hn extends Ho {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: nC++ }),
      (this.uuid = vs()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? (this.index = new (_M(e) ? zy : ky)(e, 1)) : (this.index = e), this;
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const o = new dn().getNormalMatrix(e);
      n.applyNormalMatrix(o), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Is.makeRotationFromQuaternion(e), this.applyMatrix4(Is), this;
  }
  rotateX(e) {
    return Is.makeRotationX(e), this.applyMatrix4(Is), this;
  }
  rotateY(e) {
    return Is.makeRotationY(e), this.applyMatrix4(Is), this;
  }
  rotateZ(e) {
    return Is.makeRotationZ(e), this.applyMatrix4(Is), this;
  }
  translate(e, t, n) {
    return Is.makeTranslation(e, t, n), this.applyMatrix4(Is), this;
  }
  scale(e, t, n) {
    return Is.makeScale(e, t, n), this.applyMatrix4(Is), this;
  }
  lookAt(e) {
    return h0.lookAt(e), h0.updateMatrix(), this.applyMatrix4(h0.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(gf).negate(),
      this.translate(gf.x, gf.y, gf.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute('position');
    if (t === void 0) {
      const n = [];
      for (let i = 0, o = e.length; i < o; i++) {
        const a = e[i];
        n.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute('position', new kt(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let i = 0; i < n; i++) {
        const o = e[i];
        t.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > t.count &&
        console.warn(
          'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.',
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ar());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this,
      ),
        this.boundingBox.set(new J(-1 / 0, -1 / 0, -1 / 0), new J(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const o = t[n];
          ms.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Ji.addVectors(this.boundingBox.min, ms.min),
                this.boundingBox.expandByPoint(Ji),
                Ji.addVectors(this.boundingBox.max, ms.max),
                this.boundingBox.expandByPoint(Ji))
              : (this.boundingBox.expandByPoint(ms.min), this.boundingBox.expandByPoint(ms.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new or());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this,
      ),
        this.boundingSphere.set(new J(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((ms.setFromBufferAttribute(e), t))
        for (let o = 0, a = t.length; o < a; o++) {
          const u = t[o];
          Yd.setFromBufferAttribute(u),
            this.morphTargetsRelative
              ? (Ji.addVectors(ms.min, Yd.min),
                ms.expandByPoint(Ji),
                Ji.addVectors(ms.max, Yd.max),
                ms.expandByPoint(Ji))
              : (ms.expandByPoint(Yd.min), ms.expandByPoint(Yd.max));
        }
      ms.getCenter(n);
      let i = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Ji.fromBufferAttribute(e, o), (i = Math.max(i, n.distanceToSquared(Ji)));
      if (t)
        for (let o = 0, a = t.length; o < a; o++) {
          const u = t[o],
            d = this.morphTargetsRelative;
          for (let h = 0, m = u.count; h < m; h++)
            Ji.fromBufferAttribute(u, h),
              d && (gf.fromBufferAttribute(e, h), Ji.add(gf)),
              (i = Math.max(i, n.distanceToSquared(Ji)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
      );
      return;
    }
    const n = t.position,
      i = t.normal,
      o = t.uv;
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new Pn(new Float32Array(4 * n.count), 4));
    const a = this.getAttribute('tangent'),
      u = [],
      d = [];
    for (let k = 0; k < n.count; k++) (u[k] = new J()), (d[k] = new J());
    const h = new J(),
      m = new J(),
      g = new J(),
      v = new Ge(),
      x = new Ge(),
      A = new Ge(),
      C = new J(),
      E = new J();
    function S(k, L, D) {
      h.fromBufferAttribute(n, k),
        m.fromBufferAttribute(n, L),
        g.fromBufferAttribute(n, D),
        v.fromBufferAttribute(o, k),
        x.fromBufferAttribute(o, L),
        A.fromBufferAttribute(o, D),
        m.sub(h),
        g.sub(h),
        x.sub(v),
        A.sub(v);
      const V = 1 / (x.x * A.y - A.x * x.y);
      isFinite(V) &&
        (C.copy(m).multiplyScalar(A.y).addScaledVector(g, -x.y).multiplyScalar(V),
        E.copy(g).multiplyScalar(x.x).addScaledVector(m, -A.x).multiplyScalar(V),
        u[k].add(C),
        u[L].add(C),
        u[D].add(C),
        d[k].add(E),
        d[L].add(E),
        d[D].add(E));
    }
    let b = this.groups;
    b.length === 0 && (b = [{ start: 0, count: e.count }]);
    for (let k = 0, L = b.length; k < L; ++k) {
      const D = b[k],
        V = D.start,
        oe = D.count;
      for (let ie = V, ce = V + oe; ie < ce; ie += 3)
        S(e.getX(ie + 0), e.getX(ie + 1), e.getX(ie + 2));
    }
    const I = new J(),
      B = new J(),
      z = new J(),
      N = new J();
    function G(k) {
      z.fromBufferAttribute(i, k), N.copy(z);
      const L = u[k];
      I.copy(L), I.sub(z.multiplyScalar(z.dot(L))).normalize(), B.crossVectors(N, L);
      const V = B.dot(d[k]) < 0 ? -1 : 1;
      a.setXYZW(k, I.x, I.y, I.z, V);
    }
    for (let k = 0, L = b.length; k < L; ++k) {
      const D = b[k],
        V = D.start,
        oe = D.count;
      for (let ie = V, ce = V + oe; ie < ce; ie += 3)
        G(e.getX(ie + 0)), G(e.getX(ie + 1)), G(e.getX(ie + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute('position');
    if (t !== void 0) {
      let n = this.getAttribute('normal');
      if (n === void 0)
        (n = new Pn(new Float32Array(t.count * 3), 3)), this.setAttribute('normal', n);
      else for (let v = 0, x = n.count; v < x; v++) n.setXYZ(v, 0, 0, 0);
      const i = new J(),
        o = new J(),
        a = new J(),
        u = new J(),
        d = new J(),
        h = new J(),
        m = new J(),
        g = new J();
      if (e)
        for (let v = 0, x = e.count; v < x; v += 3) {
          const A = e.getX(v + 0),
            C = e.getX(v + 1),
            E = e.getX(v + 2);
          i.fromBufferAttribute(t, A),
            o.fromBufferAttribute(t, C),
            a.fromBufferAttribute(t, E),
            m.subVectors(a, o),
            g.subVectors(i, o),
            m.cross(g),
            u.fromBufferAttribute(n, A),
            d.fromBufferAttribute(n, C),
            h.fromBufferAttribute(n, E),
            u.add(m),
            d.add(m),
            h.add(m),
            n.setXYZ(A, u.x, u.y, u.z),
            n.setXYZ(C, d.x, d.y, d.z),
            n.setXYZ(E, h.x, h.y, h.z);
        }
      else
        for (let v = 0, x = t.count; v < x; v += 3)
          i.fromBufferAttribute(t, v + 0),
            o.fromBufferAttribute(t, v + 1),
            a.fromBufferAttribute(t, v + 2),
            m.subVectors(a, o),
            g.subVectors(i, o),
            m.cross(g),
            n.setXYZ(v + 0, m.x, m.y, m.z),
            n.setXYZ(v + 1, m.x, m.y, m.z),
            n.setXYZ(v + 2, m.x, m.y, m.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Ji.fromBufferAttribute(e, t), Ji.normalize(), e.setXYZ(t, Ji.x, Ji.y, Ji.z);
  }
  toNonIndexed() {
    function e(u, d) {
      const h = u.array,
        m = u.itemSize,
        g = u.normalized,
        v = new h.constructor(d.length * m);
      let x = 0,
        A = 0;
      for (let C = 0, E = d.length; C < E; C++) {
        u.isInterleavedBufferAttribute ? (x = d[C] * u.data.stride + u.offset) : (x = d[C] * m);
        for (let S = 0; S < m; S++) v[A++] = h[x++];
      }
      return new Pn(v, m, g);
    }
    if (this.index === null)
      return (
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'),
        this
      );
    const t = new hn(),
      n = this.index.array,
      i = this.attributes;
    for (const u in i) {
      const d = i[u],
        h = e(d, n);
      t.setAttribute(u, h);
    }
    const o = this.morphAttributes;
    for (const u in o) {
      const d = [],
        h = o[u];
      for (let m = 0, g = h.length; m < g; m++) {
        const v = h[m],
          x = e(v, n);
        d.push(x);
      }
      t.morphAttributes[u] = d;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let u = 0, d = a.length; u < d; u++) {
      const h = a[u];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== '' && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const d = this.parameters;
      for (const h in d) d[h] !== void 0 && (e[h] = d[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const d in n) {
      const h = n[d];
      e.data.attributes[d] = h.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const d in this.morphAttributes) {
      const h = this.morphAttributes[d],
        m = [];
      for (let g = 0, v = h.length; g < v; g++) {
        const x = h[g];
        m.push(x.toJSON(e.data));
      }
      m.length > 0 && ((i[d] = m), (o = !0));
    }
    o && ((e.data.morphAttributes = i), (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const u = this.boundingSphere;
    return (
      u !== null && (e.data.boundingSphere = { center: u.center.toArray(), radius: u.radius }), e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const h in i) {
      const m = i[h];
      this.setAttribute(h, m.clone(t));
    }
    const o = e.morphAttributes;
    for (const h in o) {
      const m = [],
        g = o[h];
      for (let v = 0, x = g.length; v < x; v++) m.push(g[v].clone(t));
      this.morphAttributes[h] = m;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let h = 0, m = a.length; h < m; h++) {
      const g = a[h];
      this.addGroup(g.start, g.count, g.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const d = e.boundingSphere;
    return (
      d !== null && (this.boundingSphere = d.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
const Px = new Qt(),
  Au = new sc(),
  nm = new or(),
  Dx = new J(),
  im = new J(),
  rm = new J(),
  sm = new J(),
  p0 = new J(),
  om = new J(),
  Lx = new J(),
  am = new J();
class oi extends wn {
  constructor(e = new hn(), t = new ts()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), (this.morphTargetDictionary[u] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      o = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const u = this.morphTargetInfluences;
    if (o && u) {
      om.set(0, 0, 0);
      for (let d = 0, h = o.length; d < h; d++) {
        const m = u[d],
          g = o[d];
        m !== 0 &&
          (p0.fromBufferAttribute(g, e),
          a ? om.addScaledVector(p0, m) : om.addScaledVector(p0.sub(t), m));
      }
      t.add(om);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      nm.copy(n.boundingSphere),
      nm.applyMatrix4(o),
      Au.copy(e.ray).recast(e.near),
      !(
        nm.containsPoint(Au.origin) === !1 &&
        (Au.intersectSphere(nm, Dx) === null ||
          Au.origin.distanceToSquared(Dx) > (e.far - e.near) ** 2)
      ) &&
        (Px.copy(o).invert(),
        Au.copy(e.ray).applyMatrix4(Px),
        !(n.boundingBox !== null && Au.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, Au)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const o = this.geometry,
      a = this.material,
      u = o.index,
      d = o.attributes.position,
      h = o.attributes.uv,
      m = o.attributes.uv1,
      g = o.attributes.normal,
      v = o.groups,
      x = o.drawRange;
    if (u !== null)
      if (Array.isArray(a))
        for (let A = 0, C = v.length; A < C; A++) {
          const E = v[A],
            S = a[E.materialIndex],
            b = Math.max(E.start, x.start),
            I = Math.min(u.count, Math.min(E.start + E.count, x.start + x.count));
          for (let B = b, z = I; B < z; B += 3) {
            const N = u.getX(B),
              G = u.getX(B + 1),
              k = u.getX(B + 2);
            (i = lm(this, S, e, n, h, m, g, N, G, k)),
              i &&
                ((i.faceIndex = Math.floor(B / 3)),
                (i.face.materialIndex = E.materialIndex),
                t.push(i));
          }
        }
      else {
        const A = Math.max(0, x.start),
          C = Math.min(u.count, x.start + x.count);
        for (let E = A, S = C; E < S; E += 3) {
          const b = u.getX(E),
            I = u.getX(E + 1),
            B = u.getX(E + 2);
          (i = lm(this, a, e, n, h, m, g, b, I, B)),
            i && ((i.faceIndex = Math.floor(E / 3)), t.push(i));
        }
      }
    else if (d !== void 0)
      if (Array.isArray(a))
        for (let A = 0, C = v.length; A < C; A++) {
          const E = v[A],
            S = a[E.materialIndex],
            b = Math.max(E.start, x.start),
            I = Math.min(d.count, Math.min(E.start + E.count, x.start + x.count));
          for (let B = b, z = I; B < z; B += 3) {
            const N = B,
              G = B + 1,
              k = B + 2;
            (i = lm(this, S, e, n, h, m, g, N, G, k)),
              i &&
                ((i.faceIndex = Math.floor(B / 3)),
                (i.face.materialIndex = E.materialIndex),
                t.push(i));
          }
        }
      else {
        const A = Math.max(0, x.start),
          C = Math.min(d.count, x.start + x.count);
        for (let E = A, S = C; E < S; E += 3) {
          const b = E,
            I = E + 1,
            B = E + 2;
          (i = lm(this, a, e, n, h, m, g, b, I, B)),
            i && ((i.faceIndex = Math.floor(E / 3)), t.push(i));
        }
      }
  }
}
function iC(r, e, t, n, i, o, a, u) {
  let d;
  if (
    (e.side === Or
      ? (d = n.intersectTriangle(a, o, i, !0, u))
      : (d = n.intersectTriangle(i, o, a, e.side === Uo, u)),
    d === null)
  )
    return null;
  am.copy(u), am.applyMatrix4(r.matrixWorld);
  const h = t.ray.origin.distanceTo(am);
  return h < t.near || h > t.far ? null : { distance: h, point: am.clone(), object: r };
}
function lm(r, e, t, n, i, o, a, u, d, h) {
  r.getVertexPosition(u, im), r.getVertexPosition(d, rm), r.getVertexPosition(h, sm);
  const m = iC(r, e, t, n, im, rm, sm, Lx);
  if (m) {
    const g = new J();
    es.getBarycoord(Lx, im, rm, sm, g),
      i && (m.uv = es.getInterpolatedAttribute(i, u, d, h, g, new Ge())),
      o && (m.uv1 = es.getInterpolatedAttribute(o, u, d, h, g, new Ge())),
      a &&
        ((m.normal = es.getInterpolatedAttribute(a, u, d, h, g, new J())),
        m.normal.dot(n.direction) > 0 && m.normal.multiplyScalar(-1));
    const v = { a: u, b: d, c: h, normal: new J(), materialIndex: 0 };
    es.getNormal(im, rm, sm, v.normal), (m.face = v), (m.barycoord = g);
  }
  return m;
}
class oc extends hn {
  constructor(e = 1, t = 1, n = 1, i = 1, o = 1, a = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: o,
        depthSegments: a,
      });
    const u = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (a = Math.floor(a));
    const d = [],
      h = [],
      m = [],
      g = [];
    let v = 0,
      x = 0;
    A('z', 'y', 'x', -1, -1, n, t, e, a, o, 0),
      A('z', 'y', 'x', 1, -1, n, t, -e, a, o, 1),
      A('x', 'z', 'y', 1, 1, e, n, t, i, a, 2),
      A('x', 'z', 'y', 1, -1, e, n, -t, i, a, 3),
      A('x', 'y', 'z', 1, -1, e, t, n, i, o, 4),
      A('x', 'y', 'z', -1, -1, e, t, -n, i, o, 5),
      this.setIndex(d),
      this.setAttribute('position', new kt(h, 3)),
      this.setAttribute('normal', new kt(m, 3)),
      this.setAttribute('uv', new kt(g, 2));
    function A(C, E, S, b, I, B, z, N, G, k, L) {
      const D = B / G,
        V = z / k,
        oe = B / 2,
        ie = z / 2,
        ce = N / 2,
        xe = G + 1,
        de = k + 1;
      let Ce = 0,
        X = 0;
      const fe = new J();
      for (let te = 0; te < de; te++) {
        const Y = te * V - ie;
        for (let ue = 0; ue < xe; ue++) {
          const He = ue * D - oe;
          (fe[C] = He * b),
            (fe[E] = Y * I),
            (fe[S] = ce),
            h.push(fe.x, fe.y, fe.z),
            (fe[C] = 0),
            (fe[E] = 0),
            (fe[S] = N > 0 ? 1 : -1),
            m.push(fe.x, fe.y, fe.z),
            g.push(ue / G),
            g.push(1 - te / k),
            (Ce += 1);
        }
      }
      for (let te = 0; te < k; te++)
        for (let Y = 0; Y < G; Y++) {
          const ue = v + Y + xe * te,
            He = v + Y + xe * (te + 1),
            ge = v + (Y + 1) + xe * (te + 1),
            De = v + (Y + 1) + xe * te;
          d.push(ue, He, De), d.push(He, ge, De), (X += 6);
        }
      u.addGroup(x, X, L), (x += X), (v += Ce);
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new oc(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Gf(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().',
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function Nr(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = Gf(r[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function rC(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function MM(r) {
  const e = r.getRenderTarget();
  return e === null
    ? r.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : bn.workingColorSpace;
}
const EM = { clone: Gf, merge: Nr };
var sC = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  oC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class is extends Oi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = sC),
      (this.fragmentShader = oC),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Gf(e.uniforms)),
      (this.uniformsGroups = rC(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture
        ? (t.uniforms[i] = { type: 't', value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[i] = { type: 'c', value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[i] = { type: 'v2', value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[i] = { type: 'v3', value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[i] = { type: 'v4', value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[i] = { type: 'm3', value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[i] = { type: 'm4', value: a.toArray() })
        : (t.uniforms[i] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class kh extends wn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new Qt()),
      (this.projectionMatrix = new Qt()),
      (this.projectionMatrixInverse = new Qt()),
      (this.coordinateSystem = ho);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const vl = new J(),
  Fx = new Ge(),
  Nx = new Ge();
class gi extends kh {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Hf * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ku * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Hf * 2 * Math.atan(Math.tan(Ku * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, n) {
    vl.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(vl.x, vl.y).multiplyScalar(-e / vl.z),
      vl.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(vl.x, vl.y).multiplyScalar(-e / vl.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, Fx, Nx), t.subVectors(Nx, Fx);
  }
  setViewOffset(e, t, n, i, o, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Ku * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      o = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const d = a.fullWidth,
        h = a.fullHeight;
      (o += (a.offsetX * i) / d),
        (t -= (a.offsetY * n) / h),
        (i *= a.width / d),
        (n *= a.height / h);
    }
    const u = this.filmOffset;
    u !== 0 && (o += (e * u) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(o, o + i, t, t - n, e, this.far, this.coordinateSystem),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const vf = -90,
  yf = 1;
class wM extends wn {
  constructor(e, t, n) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new gi(vf, yf, e, t);
    (i.layers = this.layers), this.add(i);
    const o = new gi(vf, yf, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new gi(vf, yf, e, t);
    (a.layers = this.layers), this.add(a);
    const u = new gi(vf, yf, e, t);
    (u.layers = this.layers), this.add(u);
    const d = new gi(vf, yf, e, t);
    (d.layers = this.layers), this.add(d);
    const h = new gi(vf, yf, e, t);
    (h.layers = this.layers), this.add(h);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, o, a, u, d] = t;
    for (const h of t) this.remove(h);
    if (e === ho)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        u.up.set(0, 1, 0),
        u.lookAt(0, 0, 1),
        d.up.set(0, 1, 0),
        d.lookAt(0, 0, -1);
    else if (e === Eh)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        u.up.set(0, -1, 0),
        u.lookAt(0, 0, 1),
        d.up.set(0, -1, 0),
        d.lookAt(0, 0, -1);
    else
      throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + e);
    for (const h of t) this.add(h), h.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem());
    const [o, a, u, d, h, m] = this.children,
      g = e.getRenderTarget(),
      v = e.getActiveCubeFace(),
      x = e.getActiveMipmapLevel(),
      A = e.xr.enabled;
    e.xr.enabled = !1;
    const C = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0, i),
      e.render(t, o),
      e.setRenderTarget(n, 1, i),
      e.render(t, a),
      e.setRenderTarget(n, 2, i),
      e.render(t, u),
      e.setRenderTarget(n, 3, i),
      e.render(t, d),
      e.setRenderTarget(n, 4, i),
      e.render(t, h),
      (n.texture.generateMipmaps = C),
      e.setRenderTarget(n, 5, i),
      e.render(t, m),
      e.setRenderTarget(g, v, x),
      (e.xr.enabled = A),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class zh extends Ln {
  constructor(e, t, n, i, o, a, u, d, h, m) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Oo),
      super(e, t, n, i, o, a, u, d, h, m),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Hy extends Ls {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    (this.texture = new zh(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Fn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new oc(5, 5, 5),
      o = new is({
        name: 'CubemapFromEquirect',
        uniforms: Gf(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Or,
        blending: Do,
      });
    o.uniforms.tEquirect.value = t;
    const a = new oi(i, o),
      u = t.minFilter;
    return (
      t.minFilter === Ds && (t.minFilter = Fn),
      new wM(1, 10, this).update(e, a),
      (t.minFilter = u),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(o);
  }
}
class Ba extends wn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group');
  }
}
const aC = { type: 'move' };
class Jm {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Ba()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Ba()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new J()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new J())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Ba()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new J()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new J())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: 'connected', data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      o = null,
      a = null;
    const u = this._targetRay,
      d = this._grip,
      h = this._hand;
    if (e && t.session.visibilityState !== 'visible-blurred') {
      if (h && e.hand) {
        a = !0;
        for (const C of e.hand.values()) {
          const E = t.getJointPose(C, n),
            S = this._getHandJoint(h, C);
          E !== null &&
            (S.matrix.fromArray(E.transform.matrix),
            S.matrix.decompose(S.position, S.rotation, S.scale),
            (S.matrixWorldNeedsUpdate = !0),
            (S.jointRadius = E.radius)),
            (S.visible = E !== null);
        }
        const m = h.joints['index-finger-tip'],
          g = h.joints['thumb-tip'],
          v = m.position.distanceTo(g.position),
          x = 0.02,
          A = 0.005;
        h.inputState.pinching && v > x + A
          ? ((h.inputState.pinching = !1),
            this.dispatchEvent({ type: 'pinchend', handedness: e.handedness, target: this }))
          : !h.inputState.pinching &&
            v <= x - A &&
            ((h.inputState.pinching = !0),
            this.dispatchEvent({ type: 'pinchstart', handedness: e.handedness, target: this }));
      } else
        d !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, n)),
          o !== null &&
            (d.matrix.fromArray(o.transform.matrix),
            d.matrix.decompose(d.position, d.rotation, d.scale),
            (d.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((d.hasLinearVelocity = !0), d.linearVelocity.copy(o.linearVelocity))
              : (d.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((d.hasAngularVelocity = !0), d.angularVelocity.copy(o.angularVelocity))
              : (d.hasAngularVelocity = !1)));
      u !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && o !== null && (i = o),
        i !== null &&
          (u.matrix.fromArray(i.transform.matrix),
          u.matrix.decompose(u.position, u.rotation, u.scale),
          (u.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((u.hasLinearVelocity = !0), u.linearVelocity.copy(i.linearVelocity))
            : (u.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((u.hasAngularVelocity = !0), u.angularVelocity.copy(i.angularVelocity))
            : (u.hasAngularVelocity = !1),
          this.dispatchEvent(aC)));
    }
    return (
      u !== null && (u.visible = i !== null),
      d !== null && (d.visible = o !== null),
      h !== null && (h.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new Ba();
      (n.matrixAutoUpdate = !1), (n.visible = !1), (e.joints[t.jointName] = n), e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Kg {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0), (this.name = ''), (this.color = new At(e)), (this.density = t);
  }
  clone() {
    return new Kg(this.color, this.density);
  }
  toJSON() {
    return { type: 'FogExp2', name: this.name, color: this.color.getHex(), density: this.density };
  }
}
class jg {
  constructor(e, t = 1, n = 1e3) {
    (this.isFog = !0), (this.name = ''), (this.color = new At(e)), (this.near = t), (this.far = n);
  }
  clone() {
    return new jg(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: 'Fog',
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Hh extends wn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new ys()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new ys()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class Gh {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Mh),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = vs());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, o = this.stride; i < o; i++) this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = vs()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Fr = new J();
class bl {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Fr.fromBufferAttribute(this, t), Fr.applyMatrix4(e), this.setXYZ(t, Fr.x, Fr.y, Fr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Fr.fromBufferAttribute(this, t), Fr.applyNormalMatrix(e), this.setXYZ(t, Fr.x, Fr.y, Fr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Fr.fromBufferAttribute(this, t), Fr.transformDirection(e), this.setXYZ(t, Fr.x, Fr.y, Fr.z);
    return this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Ur(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return (
      this.normalized && (n = gn(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = n),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Ur(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = gn(t, this.array)), (n = gn(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gn(t, this.array)), (n = gn(n, this.array)), (i = gn(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gn(t, this.array)),
        (n = gn(n, this.array)),
        (i = gn(i, this.array)),
        (o = gn(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.',
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return new Pn(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new bl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.',
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class Gy extends Oi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = 'SpriteMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let _f;
const Kd = new J(),
  xf = new J(),
  Af = new J(),
  Sf = new Ge(),
  jd = new Ge(),
  CM = new Qt(),
  um = new J(),
  Zd = new J(),
  cm = new J(),
  Ux = new Ge(),
  m0 = new Ge(),
  Ox = new Ge();
class TM extends wn {
  constructor(e = new Gy()) {
    if ((super(), (this.isSprite = !0), (this.type = 'Sprite'), _f === void 0)) {
      _f = new hn();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1,
        ]),
        n = new Gh(t, 5);
      _f.setIndex([0, 1, 2, 0, 2, 3]),
        _f.setAttribute('position', new bl(n, 3, 0, !1)),
        _f.setAttribute('uv', new bl(n, 2, 3, !1));
    }
    (this.geometry = _f), (this.material = e), (this.center = new Ge(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      xf.setFromMatrixScale(this.matrixWorld),
      CM.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
      Af.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        xf.multiplyScalar(-Af.z);
    const n = this.material.rotation;
    let i, o;
    n !== 0 && ((o = Math.cos(n)), (i = Math.sin(n)));
    const a = this.center;
    fm(um.set(-0.5, -0.5, 0), Af, a, xf, i, o),
      fm(Zd.set(0.5, -0.5, 0), Af, a, xf, i, o),
      fm(cm.set(0.5, 0.5, 0), Af, a, xf, i, o),
      Ux.set(0, 0),
      m0.set(1, 0),
      Ox.set(1, 1);
    let u = e.ray.intersectTriangle(um, Zd, cm, !1, Kd);
    if (
      u === null &&
      (fm(Zd.set(-0.5, 0.5, 0), Af, a, xf, i, o),
      m0.set(0, 1),
      (u = e.ray.intersectTriangle(um, cm, Zd, !1, Kd)),
      u === null)
    )
      return;
    const d = e.ray.origin.distanceTo(Kd);
    d < e.near ||
      d > e.far ||
      t.push({
        distance: d,
        point: Kd.clone(),
        uv: es.getInterpolation(Kd, um, Zd, cm, Ux, m0, Ox, new Ge()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function fm(r, e, t, n, i, o) {
  Sf.subVectors(r, t).addScalar(0.5).multiply(n),
    i !== void 0 ? ((jd.x = o * Sf.x - i * Sf.y), (jd.y = i * Sf.x + o * Sf.y)) : jd.copy(Sf),
    r.copy(e),
    (r.x += jd.x),
    (r.y += jd.y),
    r.applyMatrix4(CM);
}
const dm = new J(),
  kx = new J();
class RM extends wn {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = 'LOD'),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(t < i[o].distance); o++);
    return i.splice(o, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  removeLevel(e) {
    const t = this.levels;
    for (let n = 0; n < t.length; n++)
      if (t[n].distance === e) {
        const i = t.splice(n, 1);
        return this.remove(i[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let o = t[n].distance;
        if ((t[n].object.visible && (o -= o * t[n].hysteresis), e < o)) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      dm.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(dm);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      dm.setFromMatrixPosition(e.matrixWorld), kx.setFromMatrixPosition(this.matrixWorld);
      const n = dm.distanceTo(kx) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o; i++) {
        let a = t[i].distance;
        if ((t[i].object.visible && (a -= a * t[i].hysteresis), n >= a))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), (t.object.levels = []);
    const n = this.levels;
    for (let i = 0, o = n.length; i < o; i++) {
      const a = n[i];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return t;
  }
}
const zx = new J(),
  Hx = new Bn(),
  Gx = new Bn(),
  lC = new J(),
  Vx = new Qt(),
  hm = new J(),
  g0 = new or(),
  Wx = new Qt(),
  v0 = new sc();
class Vy extends oi {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = ly),
      (this.bindMatrix = new Qt()),
      (this.bindMatrixInverse = new Qt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Ar()), this.boundingBox.makeEmpty();
    const t = e.getAttribute('position');
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, hm), this.boundingBox.expandByPoint(hm);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new or()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute('position');
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, hm), this.boundingSphere.expandByPoint(hm);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      g0.copy(this.boundingSphere),
      g0.applyMatrix4(i),
      e.ray.intersectsSphere(g0) !== !1 &&
        (Wx.copy(i).invert(),
        v0.copy(e.ray).applyMatrix4(Wx),
        !(this.boundingBox !== null && v0.intersectsBox(this.boundingBox) === !1) &&
          this._computeIntersections(e, t, v0)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Bn(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === ly
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === iM
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    Hx.fromBufferAttribute(i.attributes.skinIndex, e),
      Gx.fromBufferAttribute(i.attributes.skinWeight, e),
      zx.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const a = Gx.getComponent(o);
      if (a !== 0) {
        const u = Hx.getComponent(o);
        Vx.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]),
          t.addScaledVector(lC.copy(zx).applyMatrix4(Vx), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Zg extends wn {
  constructor() {
    super(), (this.isBone = !0), (this.type = 'Bone');
  }
}
class po extends Ln {
  constructor(e = null, t = 1, n = 1, i, o, a, u, d, h = Ki, m = Ki, g, v) {
    super(null, a, u, d, h, m, i, o, g, v),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const Xx = new Qt(),
  uC = new Qt();
class Vh {
  constructor(e = [], t = []) {
    (this.uuid = vs()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Qt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Qt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, a = e.length; o < a; o++) {
      const u = e[o] ? e[o].matrixWorld : uC;
      Xx.multiplyMatrices(u, t[o]), Xx.toArray(n, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Vh(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new po(t, e, e, Si, fi);
    return (n.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = n), this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const o = e.bones[n];
      let a = t[o];
      a === void 0 && (console.warn('THREE.Skeleton: No bone found with UUID:', o), (a = new Zg())),
        this.bones.push(a),
        this.boneInverses.push(new Qt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: 'Skeleton', generator: 'Skeleton.toJSON' },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const u = n[i];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class ec extends Pn {
  constructor(e, t, n, i = 1) {
    super(e, t, n), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
  }
}
const Mf = new Qt(),
  Jx = new Qt(),
  pm = [],
  Yx = new Ar(),
  cC = new Qt(),
  Qd = new oi(),
  qd = new or();
class Wy extends oi {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new ec(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, cC);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Ar()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mf), Yx.copy(e.boundingBox).applyMatrix4(Mf), this.boundingBox.union(Yx);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new or()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Mf),
        qd.copy(e.boundingSphere).applyMatrix4(Mf),
        this.boundingSphere.union(qd);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      o = n.length + 1,
      a = e * o + 1;
    for (let u = 0; u < n.length; u++) n[u] = i[a + u];
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((Qd.geometry = this.geometry),
      (Qd.material = this.material),
      Qd.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        qd.copy(this.boundingSphere),
        qd.applyMatrix4(n),
        e.ray.intersectsSphere(qd) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, Mf),
          Jx.multiplyMatrices(n, Mf),
          (Qd.matrixWorld = Jx),
          Qd.raycast(e, pm);
        for (let a = 0, u = pm.length; a < u; a++) {
          const d = pm[a];
          (d.instanceId = o), (d.object = this), t.push(d);
        }
        pm.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new ec(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences,
      i = n.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new po(new Float32Array(i * this.count), i, this.count, Nh, fi));
    const o = this.morphTexture.source.data.data;
    let a = 0;
    for (let h = 0; h < n.length; h++) a += n[h];
    const u = this.geometry.morphTargetsRelative ? 1 : 1 - a,
      d = i * e;
    (o[d] = u), o.set(n, d + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: 'dispose' }),
      this.morphTexture !== null && (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
const y0 = new J(),
  fC = new J(),
  dC = new dn();
class Ra {
  constructor(e = new J(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = y0.subVectors(n, t).cross(fC.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(y0),
      i = this.normal.dot(n);
    if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || dC.getNormalMatrix(e),
      i = this.coplanarPoint(y0).applyMatrix4(e),
      o = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Su = new or(),
  mm = new J();
class Wh {
  constructor(e = new Ra(), t = new Ra(), n = new Ra(), i = new Ra(), o = new Ra(), a = new Ra()) {
    this.planes = [e, t, n, i, o, a];
  }
  set(e, t, n, i, o, a) {
    const u = this.planes;
    return u[0].copy(e), u[1].copy(t), u[2].copy(n), u[3].copy(i), u[4].copy(o), u[5].copy(a), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = ho) {
    const n = this.planes,
      i = e.elements,
      o = i[0],
      a = i[1],
      u = i[2],
      d = i[3],
      h = i[4],
      m = i[5],
      g = i[6],
      v = i[7],
      x = i[8],
      A = i[9],
      C = i[10],
      E = i[11],
      S = i[12],
      b = i[13],
      I = i[14],
      B = i[15];
    if (
      (n[0].setComponents(d - o, v - h, E - x, B - S).normalize(),
      n[1].setComponents(d + o, v + h, E + x, B + S).normalize(),
      n[2].setComponents(d + a, v + m, E + A, B + b).normalize(),
      n[3].setComponents(d - a, v - m, E - A, B - b).normalize(),
      n[4].setComponents(d - u, v - g, E - C, B - I).normalize(),
      t === ho)
    )
      n[5].setComponents(d + u, v + g, E + C, B + I).normalize();
    else if (t === Eh) n[5].setComponents(u, g, C, I).normalize();
    else
      throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Su.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Su.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Su);
  }
  intersectsSprite(e) {
    return (
      Su.center.set(0, 0, 0),
      (Su.radius = 0.7071067811865476),
      Su.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Su)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((mm.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (mm.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (mm.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(mm) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function _0(r, e) {
  return r - e;
}
function hC(r, e) {
  return r.z - e.z;
}
function pC(r, e) {
  return e.z - r.z;
}
class mC {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, n, i) {
    const o = this.pool,
      a = this.list;
    this.index >= o.length && o.push({ start: -1, count: -1, z: -1, index: -1 });
    const u = o[this.index];
    a.push(u), this.index++, (u.start = e), (u.count = t), (u.z = n), (u.index = i);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Qr = new Qt(),
  gC = new At(1, 1, 1),
  x0 = new Wh(),
  gm = new Ar(),
  Mu = new or(),
  $d = new J(),
  Kx = new J(),
  vC = new J(),
  A0 = new mC(),
  _r = new oi(),
  vm = [];
function yC(r, e, t = 0) {
  const n = e.itemSize;
  if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
    const i = r.count;
    for (let o = 0; o < i; o++)
      for (let a = 0; a < n; a++) e.setComponent(o + t, a, r.getComponent(o, a));
  } else e.array.set(r.array, t * n);
  e.needsUpdate = !0;
}
function Eu(r, e) {
  if (r.constructor !== e.constructor) {
    const t = Math.min(r.length, e.length);
    for (let n = 0; n < t; n++) e[n] = r[n];
  } else {
    const t = Math.min(r.length, e.length);
    e.set(new r.constructor(r.buffer, 0, t));
  }
}
class bM extends oi {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(e, t, n = t * 2, i) {
    super(new hn(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = n),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      n = new po(t, e, e, Si, fi);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      n = new po(t, e, e, Uh, ko);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      n = new po(t, e, e, Si, fi);
    (n.colorSpace = bn.workingColorSpace), (this._colorsTexture = n);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      n = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const o in e.attributes) {
        const a = e.getAttribute(o),
          { array: u, itemSize: d, normalized: h } = a,
          m = new u.constructor(n * d),
          g = new Pn(m, d, h);
        t.setAttribute(o, g);
      }
      if (e.getIndex() !== null) {
        const o = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new Pn(o, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`,
        );
      const i = e.getAttribute(n),
        o = t.getAttribute(n);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.',
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`,
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`,
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ar());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const o = t[n].geometryIndex;
      this.getMatrixAt(n, Qr), this.getBoundingBoxAt(o, gm).applyMatrix4(Qr), e.union(gm);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new or());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, i = t.length; n < i; n++) {
      if (t[n].active === !1) continue;
      const o = t[n].geometryIndex;
      this.getMatrixAt(n, Qr), this.getBoundingSphereAt(o, Mu).applyMatrix4(Qr), e.union(Mu);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error('THREE.BatchedMesh: Maximum item count reached.');
    const n = { visible: !0, active: !0, geometryIndex: e };
    let i = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(_0),
        (i = this._availableInstanceIds.shift()),
        (this._instanceInfo[i] = n))
      : ((i = this._instanceInfo.length), this._instanceInfo.push(n));
    const o = this._matricesTexture;
    Qr.identity().toArray(o.image.data, i * 16), (o.needsUpdate = !0);
    const a = this._colorsTexture;
    return (
      a && (gC.toArray(a.image.data, i * 4), (a.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      i
    );
  }
  addGeometry(e, t = -1, n = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const i = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      o = this._geometryInfo;
    (i.vertexStart = this._nextVertexStart),
      (i.reservedVertexCount = t === -1 ? e.getAttribute('position').count : t);
    const a = e.getIndex();
    if (
      (a !== null &&
        ((i.indexStart = this._nextIndexStart), (i.reservedIndexCount = n === -1 ? a.count : n)),
      (i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount) ||
        i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error('THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.');
    let d;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(_0),
          (d = this._availableGeometryIds.shift()),
          (o[d] = i))
        : ((d = this._geometryCount), this._geometryCount++, o.push(i)),
      this.setGeometryAt(d, e),
      (this._nextIndexStart = i.indexStart + i.reservedIndexCount),
      (this._nextVertexStart = i.vertexStart + i.reservedVertexCount),
      d
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error('THREE.BatchedMesh: Maximum geometry count reached.');
    this._validateGeometry(t);
    const n = this.geometry,
      i = n.getIndex() !== null,
      o = n.getIndex(),
      a = t.getIndex(),
      u = this._geometryInfo[e];
    if (
      (i && a.count > u.reservedIndexCount) ||
      t.attributes.position.count > u.reservedVertexCount
    )
      throw new Error('THREE.BatchedMesh: Reserved space not large enough for provided geometry.');
    const d = u.vertexStart,
      h = u.reservedVertexCount;
    u.vertexCount = t.getAttribute('position').count;
    for (const m in n.attributes) {
      const g = t.getAttribute(m),
        v = n.getAttribute(m);
      yC(g, v, d);
      const x = g.itemSize;
      for (let A = g.count, C = h; A < C; A++) {
        const E = d + A;
        for (let S = 0; S < x; S++) v.setComponent(E, S, 0);
      }
      (v.needsUpdate = !0), v.addUpdateRange(d * x, h * x);
    }
    if (i) {
      const m = u.indexStart,
        g = u.reservedIndexCount;
      u.indexCount = t.getIndex().count;
      for (let v = 0; v < a.count; v++) o.setX(m + v, d + a.getX(v));
      for (let v = a.count, x = g; v < x; v++) o.setX(m + v, d);
      (o.needsUpdate = !0), o.addUpdateRange(m, u.reservedIndexCount);
    }
    return (
      (u.start = i ? u.indexStart : u.vertexStart),
      (u.count = i ? u.indexCount : u.vertexCount),
      (u.boundingBox = null),
      t.boundingBox !== null && (u.boundingBox = t.boundingBox.clone()),
      (u.boundingSphere = null),
      t.boundingSphere !== null && (u.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const n = this._instanceInfo;
    for (let i = 0, o = n.length; i < o; i++)
      n[i].active && n[i].geometryIndex === e && this.deleteInstance(i);
    return (
      (t[e].active = !1), this._availableGeometryIds.push(e), (this._visibilityChanged = !0), this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const n = this._geometryInfo,
      i = n.map((a, u) => u).sort((a, u) => n[a].vertexStart - n[u].vertexStart),
      o = this.geometry;
    for (let a = 0, u = n.length; a < u; a++) {
      const d = i[a],
        h = n[d];
      if (h.active !== !1) {
        if (o.index !== null) {
          if (h.indexStart !== t) {
            const { indexStart: m, vertexStart: g, reservedIndexCount: v } = h,
              x = o.index,
              A = x.array,
              C = e - g;
            for (let E = m; E < m + v; E++) A[E] = A[E] + C;
            x.array.copyWithin(t, m, m + v), x.addUpdateRange(t, v), (h.indexStart = t);
          }
          t += h.reservedIndexCount;
        }
        if (h.vertexStart !== e) {
          const { vertexStart: m, reservedVertexCount: g } = h,
            v = o.attributes;
          for (const x in v) {
            const A = v[x],
              { array: C, itemSize: E } = A;
            C.copyWithin(e * E, m * E, (m + g) * E), A.addUpdateRange(e * E, g * E);
          }
          h.vertexStart = e;
        }
        (e += h.reservedVertexCount),
          (h.start = o.index ? h.indexStart : h.vertexStart),
          (this._nextIndexStart = o.index ? h.indexStart + h.reservedIndexCount : 0),
          (this._nextVertexStart = h.vertexStart + h.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingBox === null) {
      const o = new Ar(),
        a = n.index,
        u = n.attributes.position;
      for (let d = i.start, h = i.start + i.count; d < h; d++) {
        let m = d;
        a && (m = a.getX(m)), o.expandByPoint($d.fromBufferAttribute(u, m));
      }
      i.boundingBox = o;
    }
    return t.copy(i.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const n = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingSphere === null) {
      const o = new or();
      this.getBoundingBoxAt(e, gm), gm.getCenter(o.center);
      const a = n.index,
        u = n.attributes.position;
      let d = 0;
      for (let h = i.start, m = i.start + i.count; h < m; h++) {
        let g = h;
        a && (g = a.getX(g)),
          $d.fromBufferAttribute(u, g),
          (d = Math.max(d, o.center.distanceToSquared($d)));
      }
      (o.radius = Math.sqrt(d)), (i.boundingSphere = o);
    }
    return t.copy(i.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const n = this._matricesTexture,
      i = this._matricesTexture.image.data;
    return t.toArray(i, e * 16), (n.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16);
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4);
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t), (this._visibilityChanged = !0), this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const n = this._geometryInfo[e];
    return (
      (t.vertexStart = n.vertexStart),
      (t.vertexCount = n.vertexCount),
      (t.reservedVertexCount = n.reservedVertexCount),
      (t.indexStart = n.indexStart),
      (t.indexCount = n.indexCount),
      (t.reservedIndexCount = n.reservedIndexCount),
      (t.start = n.start),
      (t.count = n.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      n = this._instanceInfo;
    for (t.sort(_0); t[t.length - 1] === n.length; ) n.pop(), t.pop();
    if (e < n.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`,
      );
    const i = new Int32Array(e),
      o = new Int32Array(e);
    Eu(this._multiDrawCounts, i),
      Eu(this._multiDrawStarts, o),
      (this._multiDrawCounts = i),
      (this._multiDrawStarts = o),
      (this._maxInstanceCount = e);
    const a = this._indirectTexture,
      u = this._matricesTexture,
      d = this._colorsTexture;
    a.dispose(),
      this._initIndirectTexture(),
      Eu(a.image.data, this._indirectTexture.image.data),
      u.dispose(),
      this._initMatricesTexture(),
      Eu(u.image.data, this._matricesTexture.image.data),
      d &&
        (d.dispose(), this._initColorsTexture(), Eu(d.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const n = [...this._geometryInfo].filter((u) => u.active);
    if (Math.max(...n.map((u) => u.vertexStart + u.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`,
      );
    if (this.geometry.index && Math.max(...n.map((d) => d.indexStart + d.reservedIndexCount)) > t)
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`,
      );
    const o = this.geometry;
    o.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1), (this.geometry = new hn()), this._initializeGeometry(o));
    const a = this.geometry;
    o.index && Eu(o.index.array, a.index.array);
    for (const u in o.attributes) Eu(o.attributes[u].array, a.attributes[u].array);
  }
  raycast(e, t) {
    const n = this._instanceInfo,
      i = this._geometryInfo,
      o = this.matrixWorld,
      a = this.geometry;
    (_r.material = this.material),
      (_r.geometry.index = a.index),
      (_r.geometry.attributes = a.attributes),
      _r.geometry.boundingBox === null && (_r.geometry.boundingBox = new Ar()),
      _r.geometry.boundingSphere === null && (_r.geometry.boundingSphere = new or());
    for (let u = 0, d = n.length; u < d; u++) {
      if (!n[u].visible || !n[u].active) continue;
      const h = n[u].geometryIndex,
        m = i[h];
      _r.geometry.setDrawRange(m.start, m.count),
        this.getMatrixAt(u, _r.matrixWorld).premultiply(o),
        this.getBoundingBoxAt(h, _r.geometry.boundingBox),
        this.getBoundingSphereAt(h, _r.geometry.boundingSphere),
        _r.raycast(e, vm);
      for (let g = 0, v = vm.length; g < v; g++) {
        const x = vm[g];
        (x.object = this), (x.batchId = u), t.push(x);
      }
      vm.length = 0;
    }
    (_r.material = null),
      (_r.geometry.index = null),
      (_r.geometry.attributes = {}),
      _r.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data = this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null && (this._colorsTexture.dispose(), (this._colorsTexture = null)),
      this
    );
  }
  onBeforeRender(e, t, n, i, o) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
    const a = i.getIndex(),
      u = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
      d = this._instanceInfo,
      h = this._multiDrawStarts,
      m = this._multiDrawCounts,
      g = this._geometryInfo,
      v = this.perObjectFrustumCulled,
      x = this._indirectTexture,
      A = x.image.data;
    v &&
      (Qr.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
      x0.setFromProjectionMatrix(Qr, e.coordinateSystem));
    let C = 0;
    if (this.sortObjects) {
      Qr.copy(this.matrixWorld).invert(),
        $d.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Qr),
        Kx.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(Qr);
      for (let b = 0, I = d.length; b < I; b++)
        if (d[b].visible && d[b].active) {
          const B = d[b].geometryIndex;
          this.getMatrixAt(b, Qr), this.getBoundingSphereAt(B, Mu).applyMatrix4(Qr);
          let z = !1;
          if ((v && (z = !x0.intersectsSphere(Mu)), !z)) {
            const N = g[B],
              G = vC.subVectors(Mu.center, $d).dot(Kx);
            A0.push(N.start, N.count, G, b);
          }
        }
      const E = A0.list,
        S = this.customSort;
      S === null ? E.sort(o.transparent ? pC : hC) : S.call(this, E, n);
      for (let b = 0, I = E.length; b < I; b++) {
        const B = E[b];
        (h[C] = B.start * u), (m[C] = B.count), (A[C] = B.index), C++;
      }
      A0.reset();
    } else
      for (let E = 0, S = d.length; E < S; E++)
        if (d[E].visible && d[E].active) {
          const b = d[E].geometryIndex;
          let I = !1;
          if (
            (v &&
              (this.getMatrixAt(E, Qr),
              this.getBoundingSphereAt(b, Mu).applyMatrix4(Qr),
              (I = !x0.intersectsSphere(Mu))),
            !I)
          ) {
            const B = g[b];
            (h[C] = B.start * u), (m[C] = B.count), (A[C] = E), C++;
          }
        }
    (x.needsUpdate = !0), (this._multiDrawCount = C), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, n, i, o, a) {
    this.onBeforeRender(e, null, i, o, a);
  }
}
class Sr extends Oi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Bg = new J(),
  Pg = new J(),
  jx = new Qt(),
  eh = new sc(),
  ym = new or(),
  S0 = new J(),
  Zx = new J();
class Fa extends wn {
  constructor(e = new hn(), t = new Sr()) {
    super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, o = t.count; i < o; i++)
        Bg.fromBufferAttribute(t, i - 1),
          Pg.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += Bg.distanceTo(Pg));
      e.setAttribute('lineDistance', new kt(n, 1));
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ym.copy(n.boundingSphere),
      ym.applyMatrix4(i),
      (ym.radius += o),
      e.ray.intersectsSphere(ym) === !1)
    )
      return;
    jx.copy(i).invert(), eh.copy(e.ray).applyMatrix4(jx);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      d = u * u,
      h = this.isLineSegments ? 2 : 1,
      m = n.index,
      v = n.attributes.position;
    if (m !== null) {
      const x = Math.max(0, a.start),
        A = Math.min(m.count, a.start + a.count);
      for (let C = x, E = A - 1; C < E; C += h) {
        const S = m.getX(C),
          b = m.getX(C + 1),
          I = _m(this, e, eh, d, S, b, C);
        I && t.push(I);
      }
      if (this.isLineLoop) {
        const C = m.getX(A - 1),
          E = m.getX(x),
          S = _m(this, e, eh, d, C, E, A - 1);
        S && t.push(S);
      }
    } else {
      const x = Math.max(0, a.start),
        A = Math.min(v.count, a.start + a.count);
      for (let C = x, E = A - 1; C < E; C += h) {
        const S = _m(this, e, eh, d, C, C + 1, C);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const C = _m(this, e, eh, d, A - 1, x, A - 1);
        C && t.push(C);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), (this.morphTargetDictionary[u] = o);
        }
      }
    }
  }
}
function _m(r, e, t, n, i, o, a) {
  const u = r.geometry.attributes.position;
  if (
    (Bg.fromBufferAttribute(u, i),
    Pg.fromBufferAttribute(u, o),
    t.distanceSqToSegment(Bg, Pg, S0, Zx) > n)
  )
    return;
  S0.applyMatrix4(r.matrixWorld);
  const h = e.ray.origin.distanceTo(S0);
  if (!(h < e.near || h > e.far))
    return {
      distance: h,
      point: Zx.clone().applyMatrix4(r.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r,
    };
}
const Qx = new J(),
  qx = new J();
class mo extends Fa {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        Qx.fromBufferAttribute(t, i),
          qx.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + Qx.distanceTo(qx));
      e.setAttribute('lineDistance', new kt(n, 1));
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      );
    return this;
  }
}
class Xy extends Fa {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
  }
}
class Qg extends Oi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const $x = new Qt(),
  dy = new sc(),
  xm = new or(),
  Am = new J();
class Jy extends wn {
  constructor(e = new hn(), t = new Qg()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      xm.copy(n.boundingSphere),
      xm.applyMatrix4(i),
      (xm.radius += o),
      e.ray.intersectsSphere(xm) === !1)
    )
      return;
    $x.copy(i).invert(), dy.copy(e.ray).applyMatrix4($x);
    const u = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      d = u * u,
      h = n.index,
      g = n.attributes.position;
    if (h !== null) {
      const v = Math.max(0, a.start),
        x = Math.min(h.count, a.start + a.count);
      for (let A = v, C = x; A < C; A++) {
        const E = h.getX(A);
        Am.fromBufferAttribute(g, E), eA(Am, E, d, i, e, t, this);
      }
    } else {
      const v = Math.max(0, a.start),
        x = Math.min(g.count, a.start + a.count);
      for (let A = v, C = x; A < C; A++) Am.fromBufferAttribute(g, A), eA(Am, A, d, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, a = i.length; o < a; o++) {
          const u = i[o].name || String(o);
          this.morphTargetInfluences.push(0), (this.morphTargetDictionary[u] = o);
        }
      }
    }
  }
}
function eA(r, e, t, n, i, o, a) {
  const u = dy.distanceSqToPoint(r);
  if (u < t) {
    const d = new J();
    dy.closestPointToPoint(r, d), d.applyMatrix4(n);
    const h = i.ray.origin.distanceTo(d);
    if (h < i.near || h > i.far) return;
    o.push({
      distance: h,
      distanceToRay: Math.sqrt(u),
      point: d,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class IM extends Ln {
  constructor(e, t, n, i, o, a, u, d, h) {
    super(e, t, n, i, o, a, u, d, h),
      (this.isVideoTexture = !0),
      (this.minFilter = a !== void 0 ? a : Fn),
      (this.magFilter = o !== void 0 ? o : Fn),
      (this.generateMipmaps = !1);
    const m = this;
    function g() {
      (m.needsUpdate = !0), e.requestVideoFrameCallback(g);
    }
    'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(g);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    'requestVideoFrameCallback' in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class _C extends IM {
  constructor(e, t, n, i, o, a, u, d) {
    super({}, e, t, n, i, o, a, u, d), (this.isVideoFrameTexture = !0);
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    (this.image = e), (this.needsUpdate = !0);
  }
}
class xC extends Ln {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Ki),
      (this.minFilter = Ki),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class qg extends Ln {
  constructor(e, t, n, i, o, a, u, d, h, m, g, v) {
    super(null, a, u, d, h, m, i, o, g, v),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class AC extends qg {
  constructor(e, t, n, i, o, a) {
    super(e, t, n, o, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Ai),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class SC extends qg {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Oo),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class MC extends Ln {
  constructor(e, t, n, i, o, a, u, d, h) {
    super(e, t, n, i, o, a, u, d, h), (this.isCanvasTexture = !0), (this.needsUpdate = !0);
  }
}
class Yy extends Ln {
  constructor(e, t, n, i, o, a, u, d, h, m = Yu) {
    if (m !== Yu && m !== $u)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      );
    n === void 0 && m === Yu && (n = ko),
      n === void 0 && m === $u && (n = qu),
      super(null, i, o, a, u, d, m, n, h),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = u !== void 0 ? u : Ki),
      (this.minFilter = d !== void 0 ? d : Ki),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class go {
  constructor() {
    (this.type = 'Curve'), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      o = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      (n = this.getPoint(a / e)), (o += n.distanceTo(i)), t.push(o), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const o = n.length;
    let a;
    t ? (a = t) : (a = e * n[o - 1]);
    let u = 0,
      d = o - 1,
      h;
    for (; u <= d; )
      if (((i = Math.floor(u + (d - u) / 2)), (h = n[i] - a), h < 0)) u = i + 1;
      else if (h > 0) d = i - 1;
      else {
        d = i;
        break;
      }
    if (((i = d), n[i] === a)) return i / (o - 1);
    const m = n[i],
      v = n[i + 1] - m,
      x = (a - m) / v;
    return (i + x) / (o - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const a = this.getPoint(i),
      u = this.getPoint(o),
      d = t || (a.isVector2 ? new Ge() : new J());
    return d.copy(u).sub(a).normalize(), d;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new J(),
      i = [],
      o = [],
      a = [],
      u = new J(),
      d = new Qt();
    for (let x = 0; x <= e; x++) {
      const A = x / e;
      i[x] = this.getTangentAt(A, new J());
    }
    (o[0] = new J()), (a[0] = new J());
    let h = Number.MAX_VALUE;
    const m = Math.abs(i[0].x),
      g = Math.abs(i[0].y),
      v = Math.abs(i[0].z);
    m <= h && ((h = m), n.set(1, 0, 0)),
      g <= h && ((h = g), n.set(0, 1, 0)),
      v <= h && n.set(0, 0, 1),
      u.crossVectors(i[0], n).normalize(),
      o[0].crossVectors(i[0], u),
      a[0].crossVectors(i[0], o[0]);
    for (let x = 1; x <= e; x++) {
      if (
        ((o[x] = o[x - 1].clone()),
        (a[x] = a[x - 1].clone()),
        u.crossVectors(i[x - 1], i[x]),
        u.length() > Number.EPSILON)
      ) {
        u.normalize();
        const A = Math.acos(un(i[x - 1].dot(i[x]), -1, 1));
        o[x].applyMatrix4(d.makeRotationAxis(u, A));
      }
      a[x].crossVectors(i[x], o[x]);
    }
    if (t === !0) {
      let x = Math.acos(un(o[0].dot(o[e]), -1, 1));
      (x /= e), i[0].dot(u.crossVectors(o[0], o[e])) > 0 && (x = -x);
      for (let A = 1; A <= e; A++)
        o[A].applyMatrix4(d.makeRotationAxis(i[A], x * A)), a[A].crossVectors(i[A], o[A]);
    }
    return { tangents: i, normals: o, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' } };
    return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class $g extends go {
  constructor(e = 0, t = 0, n = 1, i = 1, o = 0, a = Math.PI * 2, u = !1, d = 0) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = a),
      (this.aClockwise = u),
      (this.aRotation = d);
  }
  getPoint(e, t = new Ge()) {
    const n = t,
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (a ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !a && (o === i ? (o = -i) : (o = o - i));
    const u = this.aStartAngle + e * o;
    let d = this.aX + this.xRadius * Math.cos(u),
      h = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const m = Math.cos(this.aRotation),
        g = Math.sin(this.aRotation),
        v = d - this.aX,
        x = h - this.aY;
      (d = v * m - x * g + this.aX), (h = v * g + x * m + this.aY);
    }
    return n.set(d, h);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class BM extends $g {
  constructor(e, t, n, i, o, a) {
    super(e, t, n, n, i, o, a), (this.isArcCurve = !0), (this.type = 'ArcCurve');
  }
}
function Ky() {
  let r = 0,
    e = 0,
    t = 0,
    n = 0;
  function i(o, a, u, d) {
    (r = o), (e = u), (t = -3 * o + 3 * a - 2 * u - d), (n = 2 * o - 2 * a + u + d);
  }
  return {
    initCatmullRom: function (o, a, u, d, h) {
      i(a, u, h * (u - o), h * (d - a));
    },
    initNonuniformCatmullRom: function (o, a, u, d, h, m, g) {
      let v = (a - o) / h - (u - o) / (h + m) + (u - a) / m,
        x = (u - a) / m - (d - a) / (m + g) + (d - u) / g;
      (v *= m), (x *= m), i(a, u, v, x);
    },
    calc: function (o) {
      const a = o * o,
        u = a * o;
      return r + e * o + t * a + n * u;
    },
  };
}
const Sm = new J(),
  M0 = new Ky(),
  E0 = new Ky(),
  w0 = new Ky();
class PM extends go {
  constructor(e = [], t = !1, n = 'centripetal', i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new J()) {
    const n = t,
      i = this.points,
      o = i.length,
      a = (o - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(a),
      d = a - u;
    this.closed
      ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / o) + 1) * o)
      : d === 0 && u === o - 1 && ((u = o - 2), (d = 1));
    let h, m;
    this.closed || u > 0 ? (h = i[(u - 1) % o]) : (Sm.subVectors(i[0], i[1]).add(i[0]), (h = Sm));
    const g = i[u % o],
      v = i[(u + 1) % o];
    if (
      (this.closed || u + 2 < o
        ? (m = i[(u + 2) % o])
        : (Sm.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (m = Sm)),
      this.curveType === 'centripetal' || this.curveType === 'chordal')
    ) {
      const x = this.curveType === 'chordal' ? 0.5 : 0.25;
      let A = Math.pow(h.distanceToSquared(g), x),
        C = Math.pow(g.distanceToSquared(v), x),
        E = Math.pow(v.distanceToSquared(m), x);
      C < 1e-4 && (C = 1),
        A < 1e-4 && (A = C),
        E < 1e-4 && (E = C),
        M0.initNonuniformCatmullRom(h.x, g.x, v.x, m.x, A, C, E),
        E0.initNonuniformCatmullRom(h.y, g.y, v.y, m.y, A, C, E),
        w0.initNonuniformCatmullRom(h.z, g.z, v.z, m.z, A, C, E);
    } else
      this.curveType === 'catmullrom' &&
        (M0.initCatmullRom(h.x, g.x, v.x, m.x, this.tension),
        E0.initCatmullRom(h.y, g.y, v.y, m.y, this.tension),
        w0.initCatmullRom(h.z, g.z, v.z, m.z, this.tension));
    return n.set(M0.calc(d), E0.calc(d), w0.calc(d)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new J().fromArray(i));
    }
    return (
      (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this
    );
  }
}
function tA(r, e, t, n, i) {
  const o = (n - e) * 0.5,
    a = (i - t) * 0.5,
    u = r * r,
    d = r * u;
  return (2 * t - 2 * n + o + a) * d + (-3 * t + 3 * n - 2 * o - a) * u + o * r + t;
}
function EC(r, e) {
  const t = 1 - r;
  return t * t * e;
}
function wC(r, e) {
  return 2 * (1 - r) * r * e;
}
function CC(r, e) {
  return r * r * e;
}
function vh(r, e, t, n) {
  return EC(r, e) + wC(r, t) + CC(r, n);
}
function TC(r, e) {
  const t = 1 - r;
  return t * t * t * e;
}
function RC(r, e) {
  const t = 1 - r;
  return 3 * t * t * r * e;
}
function bC(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function IC(r, e) {
  return r * r * r * e;
}
function yh(r, e, t, n, i) {
  return TC(r, e) + RC(r, t) + bC(r, n) + IC(r, i);
}
class jy extends go {
  constructor(e = new Ge(), t = new Ge(), n = new Ge(), i = new Ge()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new Ge()) {
    const n = t,
      i = this.v0,
      o = this.v1,
      a = this.v2,
      u = this.v3;
    return n.set(yh(e, i.x, o.x, a.x, u.x), yh(e, i.y, o.y, a.y, u.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class DM extends go {
  constructor(e = new J(), t = new J(), n = new J(), i = new J()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new J()) {
    const n = t,
      i = this.v0,
      o = this.v1,
      a = this.v2,
      u = this.v3;
    return (
      n.set(yh(e, i.x, o.x, a.x, u.x), yh(e, i.y, o.y, a.y, u.y), yh(e, i.z, o.z, a.z, u.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Zy extends go {
  constructor(e = new Ge(), t = new Ge()) {
    super(), (this.isLineCurve = !0), (this.type = 'LineCurve'), (this.v1 = e), (this.v2 = t);
  }
  getPoint(e, t = new Ge()) {
    const n = t;
    return (
      e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ge()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class LM extends go {
  constructor(e = new J(), t = new J()) {
    super(), (this.isLineCurve3 = !0), (this.type = 'LineCurve3'), (this.v1 = e), (this.v2 = t);
  }
  getPoint(e, t = new J()) {
    const n = t;
    return (
      e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new J()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Qy extends go {
  constructor(e = new Ge(), t = new Ge(), n = new Ge()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new Ge()) {
    const n = t,
      i = this.v0,
      o = this.v1,
      a = this.v2;
    return n.set(vh(e, i.x, o.x, a.x), vh(e, i.y, o.y, a.y)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class qy extends go {
  constructor(e = new J(), t = new J(), n = new J()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new J()) {
    const n = t,
      i = this.v0,
      o = this.v1,
      a = this.v2;
    return n.set(vh(e, i.x, o.x, a.x), vh(e, i.y, o.y, a.y), vh(e, i.z, o.z, a.z)), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class $y extends go {
  constructor(e = []) {
    super(), (this.isSplineCurve = !0), (this.type = 'SplineCurve'), (this.points = e);
  }
  getPoint(e, t = new Ge()) {
    const n = t,
      i = this.points,
      o = (i.length - 1) * e,
      a = Math.floor(o),
      u = o - a,
      d = i[a === 0 ? a : a - 1],
      h = i[a],
      m = i[a > i.length - 2 ? i.length - 1 : a + 1],
      g = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return n.set(tA(u, d.x, h.x, m.x, g.x), tA(u, d.y, h.y, m.y, g.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new Ge().fromArray(i));
    }
    return this;
  }
}
var Dg = Object.freeze({
  __proto__: null,
  ArcCurve: BM,
  CatmullRomCurve3: PM,
  CubicBezierCurve: jy,
  CubicBezierCurve3: DM,
  EllipseCurve: $g,
  LineCurve: Zy,
  LineCurve3: LM,
  QuadraticBezierCurve: Qy,
  QuadraticBezierCurve3: qy,
  SplineCurve: $y,
});
class FM extends go {
  constructor() {
    super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
      this.curves.push(new Dg[n](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= n) {
        const a = i[o] - n,
          u = this.curves[o],
          d = u.getLength(),
          h = d === 0 ? 0 : 1 - a / d;
        return u.getPointAt(h, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const a = o[i],
        u = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
          ? 1
          : a.isSplineCurve
          ? e * a.points.length
          : e,
        d = a.getPoints(u);
      for (let h = 0; h < d.length; h++) {
        const m = d[h];
        (n && n.equals(m)) || (t.push(m), (n = m));
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Dg[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Ch extends FM {
  constructor(e) {
    super(), (this.type = 'Path'), (this.currentPoint = new Ge()), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new Zy(this.currentPoint.clone(), new Ge(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const o = new Qy(this.currentPoint.clone(), new Ge(e, t), new Ge(n, i));
    return this.curves.push(o), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, a) {
    const u = new jy(this.currentPoint.clone(), new Ge(e, t), new Ge(n, i), new Ge(o, a));
    return this.curves.push(u), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new $y(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, o, a) {
    const u = this.currentPoint.x,
      d = this.currentPoint.y;
    return this.absarc(e + u, t + d, n, i, o, a), this;
  }
  absarc(e, t, n, i, o, a) {
    return this.absellipse(e, t, n, n, i, o, a), this;
  }
  ellipse(e, t, n, i, o, a, u, d) {
    const h = this.currentPoint.x,
      m = this.currentPoint.y;
    return this.absellipse(e + h, t + m, n, i, o, a, u, d), this;
  }
  absellipse(e, t, n, i, o, a, u, d) {
    const h = new $g(e, t, n, i, o, a, u, d);
    if (this.curves.length > 0) {
      const g = h.getPoint(0);
      g.equals(this.currentPoint) || this.lineTo(g.x, g.y);
    }
    this.curves.push(h);
    const m = h.getPoint(1);
    return this.currentPoint.copy(m), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Xh extends hn {
  constructor(
    e = [new Ge(0, -0.5), new Ge(0.5, 0), new Ge(0, 0.5)],
    t = 12,
    n = 0,
    i = Math.PI * 2,
  ) {
    super(),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }),
      (t = Math.floor(t)),
      (i = un(i, 0, Math.PI * 2));
    const o = [],
      a = [],
      u = [],
      d = [],
      h = [],
      m = 1 / t,
      g = new J(),
      v = new Ge(),
      x = new J(),
      A = new J(),
      C = new J();
    let E = 0,
      S = 0;
    for (let b = 0; b <= e.length - 1; b++)
      switch (b) {
        case 0:
          (E = e[b + 1].x - e[b].x),
            (S = e[b + 1].y - e[b].y),
            (x.x = S * 1),
            (x.y = -E),
            (x.z = S * 0),
            C.copy(x),
            x.normalize(),
            d.push(x.x, x.y, x.z);
          break;
        case e.length - 1:
          d.push(C.x, C.y, C.z);
          break;
        default:
          (E = e[b + 1].x - e[b].x),
            (S = e[b + 1].y - e[b].y),
            (x.x = S * 1),
            (x.y = -E),
            (x.z = S * 0),
            A.copy(x),
            (x.x += C.x),
            (x.y += C.y),
            (x.z += C.z),
            x.normalize(),
            d.push(x.x, x.y, x.z),
            C.copy(A);
      }
    for (let b = 0; b <= t; b++) {
      const I = n + b * m * i,
        B = Math.sin(I),
        z = Math.cos(I);
      for (let N = 0; N <= e.length - 1; N++) {
        (g.x = e[N].x * B),
          (g.y = e[N].y),
          (g.z = e[N].x * z),
          a.push(g.x, g.y, g.z),
          (v.x = b / t),
          (v.y = N / (e.length - 1)),
          u.push(v.x, v.y);
        const G = d[3 * N + 0] * B,
          k = d[3 * N + 1],
          L = d[3 * N + 0] * z;
        h.push(G, k, L);
      }
    }
    for (let b = 0; b < t; b++)
      for (let I = 0; I < e.length - 1; I++) {
        const B = I + b * e.length,
          z = B,
          N = B + e.length,
          G = B + e.length + 1,
          k = B + 1;
        o.push(z, N, k), o.push(G, k, N);
      }
    this.setIndex(o),
      this.setAttribute('position', new kt(a, 3)),
      this.setAttribute('uv', new kt(u, 2)),
      this.setAttribute('normal', new kt(h, 3));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new Xh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class ev extends Xh {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const o = new Ch();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(n), i),
      (this.type = 'CapsuleGeometry'),
      (this.parameters = { radius: e, length: t, capSegments: n, radialSegments: i });
  }
  static fromJSON(e) {
    return new ev(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class tv extends hn {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(),
      (this.type = 'CircleGeometry'),
      (this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }),
      (t = Math.max(3, t));
    const o = [],
      a = [],
      u = [],
      d = [],
      h = new J(),
      m = new Ge();
    a.push(0, 0, 0), u.push(0, 0, 1), d.push(0.5, 0.5);
    for (let g = 0, v = 3; g <= t; g++, v += 3) {
      const x = n + (g / t) * i;
      (h.x = e * Math.cos(x)),
        (h.y = e * Math.sin(x)),
        a.push(h.x, h.y, h.z),
        u.push(0, 0, 1),
        (m.x = (a[v] / e + 1) / 2),
        (m.y = (a[v + 1] / e + 1) / 2),
        d.push(m.x, m.y);
    }
    for (let g = 1; g <= t; g++) o.push(g, g + 1, 0);
    this.setIndex(o),
      this.setAttribute('position', new kt(a, 3)),
      this.setAttribute('normal', new kt(u, 3)),
      this.setAttribute('uv', new kt(d, 2));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new tv(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Jf extends hn {
  constructor(e = 1, t = 1, n = 1, i = 32, o = 1, a = !1, u = 0, d = Math.PI * 2) {
    super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: o,
        openEnded: a,
        thetaStart: u,
        thetaLength: d,
      });
    const h = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const m = [],
      g = [],
      v = [],
      x = [];
    let A = 0;
    const C = [],
      E = n / 2;
    let S = 0;
    b(),
      a === !1 && (e > 0 && I(!0), t > 0 && I(!1)),
      this.setIndex(m),
      this.setAttribute('position', new kt(g, 3)),
      this.setAttribute('normal', new kt(v, 3)),
      this.setAttribute('uv', new kt(x, 2));
    function b() {
      const B = new J(),
        z = new J();
      let N = 0;
      const G = (t - e) / n;
      for (let k = 0; k <= o; k++) {
        const L = [],
          D = k / o,
          V = D * (t - e) + e;
        for (let oe = 0; oe <= i; oe++) {
          const ie = oe / i,
            ce = ie * d + u,
            xe = Math.sin(ce),
            de = Math.cos(ce);
          (z.x = V * xe),
            (z.y = -D * n + E),
            (z.z = V * de),
            g.push(z.x, z.y, z.z),
            B.set(xe, G, de).normalize(),
            v.push(B.x, B.y, B.z),
            x.push(ie, 1 - D),
            L.push(A++);
        }
        C.push(L);
      }
      for (let k = 0; k < i; k++)
        for (let L = 0; L < o; L++) {
          const D = C[L][k],
            V = C[L + 1][k],
            oe = C[L + 1][k + 1],
            ie = C[L][k + 1];
          (e > 0 || L !== 0) && (m.push(D, V, ie), (N += 3)),
            (t > 0 || L !== o - 1) && (m.push(V, oe, ie), (N += 3));
        }
      h.addGroup(S, N, 0), (S += N);
    }
    function I(B) {
      const z = A,
        N = new Ge(),
        G = new J();
      let k = 0;
      const L = B === !0 ? e : t,
        D = B === !0 ? 1 : -1;
      for (let oe = 1; oe <= i; oe++) g.push(0, E * D, 0), v.push(0, D, 0), x.push(0.5, 0.5), A++;
      const V = A;
      for (let oe = 0; oe <= i; oe++) {
        const ce = (oe / i) * d + u,
          xe = Math.cos(ce),
          de = Math.sin(ce);
        (G.x = L * de),
          (G.y = E * D),
          (G.z = L * xe),
          g.push(G.x, G.y, G.z),
          v.push(0, D, 0),
          (N.x = xe * 0.5 + 0.5),
          (N.y = de * 0.5 * D + 0.5),
          x.push(N.x, N.y),
          A++;
      }
      for (let oe = 0; oe < i; oe++) {
        const ie = z + oe,
          ce = V + oe;
        B === !0 ? m.push(ce, ce + 1, ie) : m.push(ce + 1, ce, ie), (k += 3);
      }
      h.addGroup(S, k, B === !0 ? 1 : 2), (S += k);
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new Jf(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class nv extends Jf {
  constructor(e = 1, t = 1, n = 32, i = 1, o = !1, a = 0, u = Math.PI * 2) {
    super(0, e, t, n, i, o, a, u),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: o,
        thetaStart: a,
        thetaLength: u,
      });
  }
  static fromJSON(e) {
    return new nv(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Bl extends hn {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: e, indices: t, radius: n, detail: i });
    const o = [],
      a = [];
    u(i),
      h(n),
      m(),
      this.setAttribute('position', new kt(o, 3)),
      this.setAttribute('normal', new kt(o.slice(), 3)),
      this.setAttribute('uv', new kt(a, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(b) {
      const I = new J(),
        B = new J(),
        z = new J();
      for (let N = 0; N < t.length; N += 3)
        x(t[N + 0], I), x(t[N + 1], B), x(t[N + 2], z), d(I, B, z, b);
    }
    function d(b, I, B, z) {
      const N = z + 1,
        G = [];
      for (let k = 0; k <= N; k++) {
        G[k] = [];
        const L = b.clone().lerp(B, k / N),
          D = I.clone().lerp(B, k / N),
          V = N - k;
        for (let oe = 0; oe <= V; oe++)
          oe === 0 && k === N ? (G[k][oe] = L) : (G[k][oe] = L.clone().lerp(D, oe / V));
      }
      for (let k = 0; k < N; k++)
        for (let L = 0; L < 2 * (N - k) - 1; L++) {
          const D = Math.floor(L / 2);
          L % 2 === 0
            ? (v(G[k][D + 1]), v(G[k + 1][D]), v(G[k][D]))
            : (v(G[k][D + 1]), v(G[k + 1][D + 1]), v(G[k + 1][D]));
        }
    }
    function h(b) {
      const I = new J();
      for (let B = 0; B < o.length; B += 3)
        (I.x = o[B + 0]),
          (I.y = o[B + 1]),
          (I.z = o[B + 2]),
          I.normalize().multiplyScalar(b),
          (o[B + 0] = I.x),
          (o[B + 1] = I.y),
          (o[B + 2] = I.z);
    }
    function m() {
      const b = new J();
      for (let I = 0; I < o.length; I += 3) {
        (b.x = o[I + 0]), (b.y = o[I + 1]), (b.z = o[I + 2]);
        const B = E(b) / 2 / Math.PI + 0.5,
          z = S(b) / Math.PI + 0.5;
        a.push(B, 1 - z);
      }
      A(), g();
    }
    function g() {
      for (let b = 0; b < a.length; b += 6) {
        const I = a[b + 0],
          B = a[b + 2],
          z = a[b + 4],
          N = Math.max(I, B, z),
          G = Math.min(I, B, z);
        N > 0.9 &&
          G < 0.1 &&
          (I < 0.2 && (a[b + 0] += 1), B < 0.2 && (a[b + 2] += 1), z < 0.2 && (a[b + 4] += 1));
      }
    }
    function v(b) {
      o.push(b.x, b.y, b.z);
    }
    function x(b, I) {
      const B = b * 3;
      (I.x = e[B + 0]), (I.y = e[B + 1]), (I.z = e[B + 2]);
    }
    function A() {
      const b = new J(),
        I = new J(),
        B = new J(),
        z = new J(),
        N = new Ge(),
        G = new Ge(),
        k = new Ge();
      for (let L = 0, D = 0; L < o.length; L += 9, D += 6) {
        b.set(o[L + 0], o[L + 1], o[L + 2]),
          I.set(o[L + 3], o[L + 4], o[L + 5]),
          B.set(o[L + 6], o[L + 7], o[L + 8]),
          N.set(a[D + 0], a[D + 1]),
          G.set(a[D + 2], a[D + 3]),
          k.set(a[D + 4], a[D + 5]),
          z.copy(b).add(I).add(B).divideScalar(3);
        const V = E(z);
        C(N, D + 0, b, V), C(G, D + 2, I, V), C(k, D + 4, B, V);
      }
    }
    function C(b, I, B, z) {
      z < 0 && b.x === 1 && (a[I] = b.x - 1),
        B.x === 0 && B.z === 0 && (a[I] = z / 2 / Math.PI + 0.5);
    }
    function E(b) {
      return Math.atan2(b.z, -b.x);
    }
    function S(b) {
      return Math.atan2(-b.y, Math.sqrt(b.x * b.x + b.z * b.z));
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new Bl(e.vertices, e.indices, e.radius, e.details);
  }
}
class iv extends Bl {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10,
        6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13,
        15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4,
        0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5,
        1, 5, 9,
      ];
    super(o, a, e, t),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new iv(e.radius, e.detail);
  }
}
const Mm = new J(),
  Em = new J(),
  C0 = new J(),
  wm = new es();
class NM extends hn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(Ku * t),
        a = e.getIndex(),
        u = e.getAttribute('position'),
        d = a ? a.count : u.count,
        h = [0, 0, 0],
        m = ['a', 'b', 'c'],
        g = new Array(3),
        v = {},
        x = [];
      for (let A = 0; A < d; A += 3) {
        a
          ? ((h[0] = a.getX(A)), (h[1] = a.getX(A + 1)), (h[2] = a.getX(A + 2)))
          : ((h[0] = A), (h[1] = A + 1), (h[2] = A + 2));
        const { a: C, b: E, c: S } = wm;
        if (
          (C.fromBufferAttribute(u, h[0]),
          E.fromBufferAttribute(u, h[1]),
          S.fromBufferAttribute(u, h[2]),
          wm.getNormal(C0),
          (g[0] = `${Math.round(C.x * i)},${Math.round(C.y * i)},${Math.round(C.z * i)}`),
          (g[1] = `${Math.round(E.x * i)},${Math.round(E.y * i)},${Math.round(E.z * i)}`),
          (g[2] = `${Math.round(S.x * i)},${Math.round(S.y * i)},${Math.round(S.z * i)}`),
          !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
        )
          for (let b = 0; b < 3; b++) {
            const I = (b + 1) % 3,
              B = g[b],
              z = g[I],
              N = wm[m[b]],
              G = wm[m[I]],
              k = `${B}_${z}`,
              L = `${z}_${B}`;
            L in v && v[L]
              ? (C0.dot(v[L].normal) <= o && (x.push(N.x, N.y, N.z), x.push(G.x, G.y, G.z)),
                (v[L] = null))
              : k in v || (v[k] = { index0: h[b], index1: h[I], normal: C0.clone() });
          }
      }
      for (const A in v)
        if (v[A]) {
          const { index0: C, index1: E } = v[A];
          Mm.fromBufferAttribute(u, C),
            Em.fromBufferAttribute(u, E),
            x.push(Mm.x, Mm.y, Mm.z),
            x.push(Em.x, Em.y, Em.z);
        }
      this.setAttribute('position', new kt(x, 3));
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
}
class Zu extends Ch {
  constructor(e) {
    super(e), (this.uuid = vs()), (this.type = 'Shape'), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Ch().fromJSON(i));
    }
    return this;
  }
}
const BC = {
  triangulate: function (r, e, t = 2) {
    const n = e && e.length,
      i = n ? e[0] * t : r.length;
    let o = UM(r, 0, i, t, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let u, d, h, m, g, v, x;
    if ((n && (o = NC(r, e, o, t)), r.length > 80 * t)) {
      (u = h = r[0]), (d = m = r[1]);
      for (let A = t; A < i; A += t)
        (g = r[A]),
          (v = r[A + 1]),
          g < u && (u = g),
          v < d && (d = v),
          g > h && (h = g),
          v > m && (m = v);
      (x = Math.max(h - u, m - d)), (x = x !== 0 ? 32767 / x : 0);
    }
    return Th(o, a, t, u, d, x, 0), a;
  },
};
function UM(r, e, t, n, i) {
  let o, a;
  if (i === YC(r, e, t, n) > 0) for (o = e; o < t; o += n) a = nA(o, r[o], r[o + 1], a);
  else for (o = t - n; o >= e; o -= n) a = nA(o, r[o], r[o + 1], a);
  return a && rv(a, a.next) && (bh(a), (a = a.next)), a;
}
function tc(r, e) {
  if (!r) return r;
  e || (e = r);
  let t = r,
    n;
  do
    if (((n = !1), !t.steiner && (rv(t, t.next) || ci(t.prev, t, t.next) === 0))) {
      if ((bh(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function Th(r, e, t, n, i, o, a) {
  if (!r) return;
  !a && o && HC(r, n, i, o);
  let u = r,
    d,
    h;
  for (; r.prev !== r.next; ) {
    if (((d = r.prev), (h = r.next), o ? DC(r, n, i, o) : PC(r))) {
      e.push((d.i / t) | 0),
        e.push((r.i / t) | 0),
        e.push((h.i / t) | 0),
        bh(r),
        (r = h.next),
        (u = h.next);
      continue;
    }
    if (((r = h), r === u)) {
      a
        ? a === 1
          ? ((r = LC(tc(r), e, t)), Th(r, e, t, n, i, o, 2))
          : a === 2 && FC(r, e, t, n, i, o)
        : Th(tc(r), e, t, n, i, o, 1);
      break;
    }
  }
}
function PC(r) {
  const e = r.prev,
    t = r,
    n = r.next;
  if (ci(e, t, n) >= 0) return !1;
  const i = e.x,
    o = t.x,
    a = n.x,
    u = e.y,
    d = t.y,
    h = n.y,
    m = i < o ? (i < a ? i : a) : o < a ? o : a,
    g = u < d ? (u < h ? u : h) : d < h ? d : h,
    v = i > o ? (i > a ? i : a) : o > a ? o : a,
    x = u > d ? (u > h ? u : h) : d > h ? d : h;
  let A = n.next;
  for (; A !== e; ) {
    if (
      A.x >= m &&
      A.x <= v &&
      A.y >= g &&
      A.y <= x &&
      If(i, u, o, d, a, h, A.x, A.y) &&
      ci(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.next;
  }
  return !0;
}
function DC(r, e, t, n) {
  const i = r.prev,
    o = r,
    a = r.next;
  if (ci(i, o, a) >= 0) return !1;
  const u = i.x,
    d = o.x,
    h = a.x,
    m = i.y,
    g = o.y,
    v = a.y,
    x = u < d ? (u < h ? u : h) : d < h ? d : h,
    A = m < g ? (m < v ? m : v) : g < v ? g : v,
    C = u > d ? (u > h ? u : h) : d > h ? d : h,
    E = m > g ? (m > v ? m : v) : g > v ? g : v,
    S = hy(x, A, e, t, n),
    b = hy(C, E, e, t, n);
  let I = r.prevZ,
    B = r.nextZ;
  for (; I && I.z >= S && B && B.z <= b; ) {
    if (
      (I.x >= x &&
        I.x <= C &&
        I.y >= A &&
        I.y <= E &&
        I !== i &&
        I !== a &&
        If(u, m, d, g, h, v, I.x, I.y) &&
        ci(I.prev, I, I.next) >= 0) ||
      ((I = I.prevZ),
      B.x >= x &&
        B.x <= C &&
        B.y >= A &&
        B.y <= E &&
        B !== i &&
        B !== a &&
        If(u, m, d, g, h, v, B.x, B.y) &&
        ci(B.prev, B, B.next) >= 0)
    )
      return !1;
    B = B.nextZ;
  }
  for (; I && I.z >= S; ) {
    if (
      I.x >= x &&
      I.x <= C &&
      I.y >= A &&
      I.y <= E &&
      I !== i &&
      I !== a &&
      If(u, m, d, g, h, v, I.x, I.y) &&
      ci(I.prev, I, I.next) >= 0
    )
      return !1;
    I = I.prevZ;
  }
  for (; B && B.z <= b; ) {
    if (
      B.x >= x &&
      B.x <= C &&
      B.y >= A &&
      B.y <= E &&
      B !== i &&
      B !== a &&
      If(u, m, d, g, h, v, B.x, B.y) &&
      ci(B.prev, B, B.next) >= 0
    )
      return !1;
    B = B.nextZ;
  }
  return !0;
}
function LC(r, e, t) {
  let n = r;
  do {
    const i = n.prev,
      o = n.next.next;
    !rv(i, o) &&
      OM(i, n, n.next, o) &&
      Rh(i, o) &&
      Rh(o, i) &&
      (e.push((i.i / t) | 0),
      e.push((n.i / t) | 0),
      e.push((o.i / t) | 0),
      bh(n),
      bh(n.next),
      (n = r = o)),
      (n = n.next);
  } while (n !== r);
  return tc(n);
}
function FC(r, e, t, n, i, o) {
  let a = r;
  do {
    let u = a.next.next;
    for (; u !== a.prev; ) {
      if (a.i !== u.i && WC(a, u)) {
        let d = kM(a, u);
        (a = tc(a, a.next)), (d = tc(d, d.next)), Th(a, e, t, n, i, o, 0), Th(d, e, t, n, i, o, 0);
        return;
      }
      u = u.next;
    }
    a = a.next;
  } while (a !== r);
}
function NC(r, e, t, n) {
  const i = [];
  let o, a, u, d, h;
  for (o = 0, a = e.length; o < a; o++)
    (u = e[o] * n),
      (d = o < a - 1 ? e[o + 1] * n : r.length),
      (h = UM(r, u, d, n, !1)),
      h === h.next && (h.steiner = !0),
      i.push(VC(h));
  for (i.sort(UC), o = 0; o < i.length; o++) t = OC(i[o], t);
  return t;
}
function UC(r, e) {
  return r.x - e.x;
}
function OC(r, e) {
  const t = kC(r, e);
  if (!t) return e;
  const n = kM(t, r);
  return tc(n, n.next), tc(t, t.next);
}
function kC(r, e) {
  let t = e,
    n = -1 / 0,
    i;
  const o = r.x,
    a = r.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const v = t.x + ((a - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (v <= o && v > n && ((n = v), (i = t.x < t.next.x ? t : t.next), v === o)) return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const u = i,
    d = i.x,
    h = i.y;
  let m = 1 / 0,
    g;
  t = i;
  do
    o >= t.x &&
      t.x >= d &&
      o !== t.x &&
      If(a < h ? o : n, a, d, h, a < h ? n : o, a, t.x, t.y) &&
      ((g = Math.abs(a - t.y) / (o - t.x)),
      Rh(t, r) &&
        (g < m || (g === m && (t.x > i.x || (t.x === i.x && zC(i, t))))) &&
        ((i = t), (m = g))),
      (t = t.next);
  while (t !== u);
  return i;
}
function zC(r, e) {
  return ci(r.prev, r, e.prev) < 0 && ci(e.next, r, r.next) < 0;
}
function HC(r, e, t, n) {
  let i = r;
  do
    i.z === 0 && (i.z = hy(i.x, i.y, e, t, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== r);
  (i.prevZ.nextZ = null), (i.prevZ = null), GC(i);
}
function GC(r) {
  let e,
    t,
    n,
    i,
    o,
    a,
    u,
    d,
    h = 1;
  do {
    for (t = r, r = null, o = null, a = 0; t; ) {
      for (a++, n = t, u = 0, e = 0; e < h && (u++, (n = n.nextZ), !!n); e++);
      for (d = h; u > 0 || (d > 0 && n); )
        u !== 0 && (d === 0 || !n || t.z <= n.z)
          ? ((i = t), (t = t.nextZ), u--)
          : ((i = n), (n = n.nextZ), d--),
          o ? (o.nextZ = i) : (r = i),
          (i.prevZ = o),
          (o = i);
      t = n;
    }
    (o.nextZ = null), (h *= 2);
  } while (a > 1);
  return r;
}
function hy(r, e, t, n, i) {
  return (
    (r = ((r - t) * i) | 0),
    (e = ((e - n) * i) | 0),
    (r = (r | (r << 8)) & 16711935),
    (r = (r | (r << 4)) & 252645135),
    (r = (r | (r << 2)) & 858993459),
    (r = (r | (r << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    r | (e << 1)
  );
}
function VC(r) {
  let e = r,
    t = r;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== r);
  return t;
}
function If(r, e, t, n, i, o, a, u) {
  return (
    (i - a) * (e - u) >= (r - a) * (o - u) &&
    (r - a) * (n - u) >= (t - a) * (e - u) &&
    (t - a) * (o - u) >= (i - a) * (n - u)
  );
}
function WC(r, e) {
  return (
    r.next.i !== e.i &&
    r.prev.i !== e.i &&
    !XC(r, e) &&
    ((Rh(r, e) && Rh(e, r) && JC(r, e) && (ci(r.prev, r, e.prev) || ci(r, e.prev, e))) ||
      (rv(r, e) && ci(r.prev, r, r.next) > 0 && ci(e.prev, e, e.next) > 0))
  );
}
function ci(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function rv(r, e) {
  return r.x === e.x && r.y === e.y;
}
function OM(r, e, t, n) {
  const i = Tm(ci(r, e, t)),
    o = Tm(ci(r, e, n)),
    a = Tm(ci(t, n, r)),
    u = Tm(ci(t, n, e));
  return !!(
    (i !== o && a !== u) ||
    (i === 0 && Cm(r, t, e)) ||
    (o === 0 && Cm(r, n, e)) ||
    (a === 0 && Cm(t, r, n)) ||
    (u === 0 && Cm(t, e, n))
  );
}
function Cm(r, e, t) {
  return (
    e.x <= Math.max(r.x, t.x) &&
    e.x >= Math.min(r.x, t.x) &&
    e.y <= Math.max(r.y, t.y) &&
    e.y >= Math.min(r.y, t.y)
  );
}
function Tm(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function XC(r, e) {
  let t = r;
  do {
    if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && OM(t, t.next, r, e))
      return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function Rh(r, e) {
  return ci(r.prev, r, r.next) < 0
    ? ci(r, e, r.next) >= 0 && ci(r, r.prev, e) >= 0
    : ci(r, e, r.prev) < 0 || ci(r, r.next, e) < 0;
}
function JC(r, e) {
  let t = r,
    n = !1;
  const i = (r.x + e.x) / 2,
    o = (r.y + e.y) / 2;
  do
    t.y > o != t.next.y > o &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next);
  while (t !== r);
  return n;
}
function kM(r, e) {
  const t = new py(r.i, r.x, r.y),
    n = new py(e.i, e.x, e.y),
    i = r.next,
    o = e.prev;
  return (
    (r.next = e),
    (e.prev = r),
    (t.next = i),
    (i.prev = t),
    (n.next = t),
    (t.prev = n),
    (o.next = n),
    (n.prev = o),
    n
  );
}
function nA(r, e, t, n) {
  const i = new py(r, e, t);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function bh(r) {
  (r.next.prev = r.prev),
    (r.prev.next = r.next),
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function py(r, e, t) {
  (this.i = r),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function YC(r, e, t, n) {
  let i = 0;
  for (let o = e, a = t - n; o < t; o += n) (i += (r[a] - r[o]) * (r[o + 1] + r[a + 1])), (a = o);
  return i;
}
class Fo {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, o = 0; o < t; i = o++) n += e[i].x * e[o].y - e[o].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return Fo.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      i = [],
      o = [];
    iA(e), rA(n, e);
    let a = e.length;
    t.forEach(iA);
    for (let d = 0; d < t.length; d++) i.push(a), (a += t[d].length), rA(n, t[d]);
    const u = BC.triangulate(n, i);
    for (let d = 0; d < u.length; d += 3) o.push(u.slice(d, d + 3));
    return o;
  }
}
function iA(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function rA(r, e) {
  for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
}
class sv extends hn {
  constructor(
    e = new Zu([new Ge(0.5, 0.5), new Ge(-0.5, 0.5), new Ge(-0.5, -0.5), new Ge(0.5, -0.5)]),
    t = {},
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const n = this,
      i = [],
      o = [];
    for (let u = 0, d = e.length; u < d; u++) {
      const h = e[u];
      a(h);
    }
    this.setAttribute('position', new kt(i, 3)),
      this.setAttribute('uv', new kt(o, 2)),
      this.computeVertexNormals();
    function a(u) {
      const d = [],
        h = t.curveSegments !== void 0 ? t.curveSegments : 12,
        m = t.steps !== void 0 ? t.steps : 1,
        g = t.depth !== void 0 ? t.depth : 1;
      let v = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        x = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        A = t.bevelSize !== void 0 ? t.bevelSize : x - 0.1,
        C = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        E = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const S = t.extrudePath,
        b = t.UVGenerator !== void 0 ? t.UVGenerator : KC;
      let I,
        B = !1,
        z,
        N,
        G,
        k;
      S &&
        ((I = S.getSpacedPoints(m)),
        (B = !0),
        (v = !1),
        (z = S.computeFrenetFrames(m, !1)),
        (N = new J()),
        (G = new J()),
        (k = new J())),
        v || ((E = 0), (x = 0), (A = 0), (C = 0));
      const L = u.extractPoints(h);
      let D = L.shape;
      const V = L.holes;
      if (!Fo.isClockWise(D)) {
        D = D.reverse();
        for (let Ye = 0, ke = V.length; Ye < ke; Ye++) {
          const j = V[Ye];
          Fo.isClockWise(j) && (V[Ye] = j.reverse());
        }
      }
      const ie = Fo.triangulateShape(D, V),
        ce = D;
      for (let Ye = 0, ke = V.length; Ye < ke; Ye++) {
        const j = V[Ye];
        D = D.concat(j);
      }
      function xe(Ye, ke, j) {
        return (
          ke || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          Ye.clone().addScaledVector(ke, j)
        );
      }
      const de = D.length,
        Ce = ie.length;
      function X(Ye, ke, j) {
        let It, qe, yt;
        const rt = Ye.x - ke.x,
          Ht = Ye.y - ke.y,
          lt = j.x - Ye.x,
          K = j.y - Ye.y,
          H = rt * rt + Ht * Ht,
          ve = rt * K - Ht * lt;
        if (Math.abs(ve) > Number.EPSILON) {
          const Le = Math.sqrt(H),
            We = Math.sqrt(lt * lt + K * K),
            ze = ke.x - Ht / Le,
            Ct = ke.y + rt / Le,
            at = j.x - K / We,
            pt = j.y + lt / We,
            $t = ((at - ze) * K - (pt - Ct) * lt) / (rt * K - Ht * lt);
          (It = ze + rt * $t - Ye.x), (qe = Ct + Ht * $t - Ye.y);
          const Ze = It * It + qe * qe;
          if (Ze <= 2) return new Ge(It, qe);
          yt = Math.sqrt(Ze / 2);
        } else {
          let Le = !1;
          rt > Number.EPSILON
            ? lt > Number.EPSILON && (Le = !0)
            : rt < -Number.EPSILON
            ? lt < -Number.EPSILON && (Le = !0)
            : Math.sign(Ht) === Math.sign(K) && (Le = !0),
            Le
              ? ((It = -Ht), (qe = rt), (yt = Math.sqrt(H)))
              : ((It = rt), (qe = Ht), (yt = Math.sqrt(H / 2)));
        }
        return new Ge(It / yt, qe / yt);
      }
      const fe = [];
      for (let Ye = 0, ke = ce.length, j = ke - 1, It = Ye + 1; Ye < ke; Ye++, j++, It++)
        j === ke && (j = 0), It === ke && (It = 0), (fe[Ye] = X(ce[Ye], ce[j], ce[It]));
      const te = [];
      let Y,
        ue = fe.concat();
      for (let Ye = 0, ke = V.length; Ye < ke; Ye++) {
        const j = V[Ye];
        Y = [];
        for (let It = 0, qe = j.length, yt = qe - 1, rt = It + 1; It < qe; It++, yt++, rt++)
          yt === qe && (yt = 0), rt === qe && (rt = 0), (Y[It] = X(j[It], j[yt], j[rt]));
        te.push(Y), (ue = ue.concat(Y));
      }
      for (let Ye = 0; Ye < E; Ye++) {
        const ke = Ye / E,
          j = x * Math.cos((ke * Math.PI) / 2),
          It = A * Math.sin((ke * Math.PI) / 2) + C;
        for (let qe = 0, yt = ce.length; qe < yt; qe++) {
          const rt = xe(ce[qe], fe[qe], It);
          Ue(rt.x, rt.y, -j);
        }
        for (let qe = 0, yt = V.length; qe < yt; qe++) {
          const rt = V[qe];
          Y = te[qe];
          for (let Ht = 0, lt = rt.length; Ht < lt; Ht++) {
            const K = xe(rt[Ht], Y[Ht], It);
            Ue(K.x, K.y, -j);
          }
        }
      }
      const He = A + C;
      for (let Ye = 0; Ye < de; Ye++) {
        const ke = v ? xe(D[Ye], ue[Ye], He) : D[Ye];
        B
          ? (G.copy(z.normals[0]).multiplyScalar(ke.x),
            N.copy(z.binormals[0]).multiplyScalar(ke.y),
            k.copy(I[0]).add(G).add(N),
            Ue(k.x, k.y, k.z))
          : Ue(ke.x, ke.y, 0);
      }
      for (let Ye = 1; Ye <= m; Ye++)
        for (let ke = 0; ke < de; ke++) {
          const j = v ? xe(D[ke], ue[ke], He) : D[ke];
          B
            ? (G.copy(z.normals[Ye]).multiplyScalar(j.x),
              N.copy(z.binormals[Ye]).multiplyScalar(j.y),
              k.copy(I[Ye]).add(G).add(N),
              Ue(k.x, k.y, k.z))
            : Ue(j.x, j.y, (g / m) * Ye);
        }
      for (let Ye = E - 1; Ye >= 0; Ye--) {
        const ke = Ye / E,
          j = x * Math.cos((ke * Math.PI) / 2),
          It = A * Math.sin((ke * Math.PI) / 2) + C;
        for (let qe = 0, yt = ce.length; qe < yt; qe++) {
          const rt = xe(ce[qe], fe[qe], It);
          Ue(rt.x, rt.y, g + j);
        }
        for (let qe = 0, yt = V.length; qe < yt; qe++) {
          const rt = V[qe];
          Y = te[qe];
          for (let Ht = 0, lt = rt.length; Ht < lt; Ht++) {
            const K = xe(rt[Ht], Y[Ht], It);
            B ? Ue(K.x, K.y + I[m - 1].y, I[m - 1].x + j) : Ue(K.x, K.y, g + j);
          }
        }
      }
      ge(), De();
      function ge() {
        const Ye = i.length / 3;
        if (v) {
          let ke = 0,
            j = de * ke;
          for (let It = 0; It < Ce; It++) {
            const qe = ie[It];
            et(qe[2] + j, qe[1] + j, qe[0] + j);
          }
          (ke = m + E * 2), (j = de * ke);
          for (let It = 0; It < Ce; It++) {
            const qe = ie[It];
            et(qe[0] + j, qe[1] + j, qe[2] + j);
          }
        } else {
          for (let ke = 0; ke < Ce; ke++) {
            const j = ie[ke];
            et(j[2], j[1], j[0]);
          }
          for (let ke = 0; ke < Ce; ke++) {
            const j = ie[ke];
            et(j[0] + de * m, j[1] + de * m, j[2] + de * m);
          }
        }
        n.addGroup(Ye, i.length / 3 - Ye, 0);
      }
      function De() {
        const Ye = i.length / 3;
        let ke = 0;
        Ie(ce, ke), (ke += ce.length);
        for (let j = 0, It = V.length; j < It; j++) {
          const qe = V[j];
          Ie(qe, ke), (ke += qe.length);
        }
        n.addGroup(Ye, i.length / 3 - Ye, 1);
      }
      function Ie(Ye, ke) {
        let j = Ye.length;
        for (; --j >= 0; ) {
          const It = j;
          let qe = j - 1;
          qe < 0 && (qe = Ye.length - 1);
          for (let yt = 0, rt = m + E * 2; yt < rt; yt++) {
            const Ht = de * yt,
              lt = de * (yt + 1),
              K = ke + It + Ht,
              H = ke + qe + Ht,
              ve = ke + qe + lt,
              Le = ke + It + lt;
            Bt(K, H, ve, Le);
          }
        }
      }
      function Ue(Ye, ke, j) {
        d.push(Ye), d.push(ke), d.push(j);
      }
      function et(Ye, ke, j) {
        ht(Ye), ht(ke), ht(j);
        const It = i.length / 3,
          qe = b.generateTopUV(n, i, It - 3, It - 2, It - 1);
        Jt(qe[0]), Jt(qe[1]), Jt(qe[2]);
      }
      function Bt(Ye, ke, j, It) {
        ht(Ye), ht(ke), ht(It), ht(ke), ht(j), ht(It);
        const qe = i.length / 3,
          yt = b.generateSideWallUV(n, i, qe - 6, qe - 3, qe - 2, qe - 1);
        Jt(yt[0]), Jt(yt[1]), Jt(yt[3]), Jt(yt[1]), Jt(yt[2]), Jt(yt[3]);
      }
      function ht(Ye) {
        i.push(d[Ye * 3 + 0]), i.push(d[Ye * 3 + 1]), i.push(d[Ye * 3 + 2]);
      }
      function Jt(Ye) {
        o.push(Ye.x), o.push(Ye.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return jC(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let o = 0, a = e.shapes.length; o < a; o++) {
      const u = t[e.shapes[o]];
      n.push(u);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new Dg[i.type]().fromJSON(i)), new sv(n, e.options)
    );
  }
}
const KC = {
  generateTopUV: function (r, e, t, n, i) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      u = e[n * 3],
      d = e[n * 3 + 1],
      h = e[i * 3],
      m = e[i * 3 + 1];
    return [new Ge(o, a), new Ge(u, d), new Ge(h, m)];
  },
  generateSideWallUV: function (r, e, t, n, i, o) {
    const a = e[t * 3],
      u = e[t * 3 + 1],
      d = e[t * 3 + 2],
      h = e[n * 3],
      m = e[n * 3 + 1],
      g = e[n * 3 + 2],
      v = e[i * 3],
      x = e[i * 3 + 1],
      A = e[i * 3 + 2],
      C = e[o * 3],
      E = e[o * 3 + 1],
      S = e[o * 3 + 2];
    return Math.abs(u - m) < Math.abs(a - h)
      ? [new Ge(a, 1 - d), new Ge(h, 1 - g), new Ge(v, 1 - A), new Ge(C, 1 - S)]
      : [new Ge(u, 1 - d), new Ge(m, 1 - g), new Ge(x, 1 - A), new Ge(E, 1 - S)];
  },
};
function jC(r, e, t) {
  if (((t.shapes = []), Array.isArray(r)))
    for (let n = 0, i = r.length; n < i; n++) {
      const o = r[n];
      t.shapes.push(o.uuid);
    }
  else t.shapes.push(r.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Jh extends Bl {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7,
        1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9,
        8, 1,
      ];
    super(i, o, e, t),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Jh(e.radius, e.detail);
  }
}
class Yh extends Bl {
  constructor(e = 1, t = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(n, i, e, t),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Yh(e.radius, e.detail);
  }
}
class Pl extends hn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i });
    const o = e / 2,
      a = t / 2,
      u = Math.floor(n),
      d = Math.floor(i),
      h = u + 1,
      m = d + 1,
      g = e / u,
      v = t / d,
      x = [],
      A = [],
      C = [],
      E = [];
    for (let S = 0; S < m; S++) {
      const b = S * v - a;
      for (let I = 0; I < h; I++) {
        const B = I * g - o;
        A.push(B, -b, 0), C.push(0, 0, 1), E.push(I / u), E.push(1 - S / d);
      }
    }
    for (let S = 0; S < d; S++)
      for (let b = 0; b < u; b++) {
        const I = b + h * S,
          B = b + h * (S + 1),
          z = b + 1 + h * (S + 1),
          N = b + 1 + h * S;
        x.push(I, B, N), x.push(B, z, N);
      }
    this.setIndex(x),
      this.setAttribute('position', new kt(A, 3)),
      this.setAttribute('normal', new kt(C, 3)),
      this.setAttribute('uv', new kt(E, 2));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new Pl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class ov extends hn {
  constructor(e = 0.5, t = 1, n = 32, i = 1, o = 0, a = Math.PI * 2) {
    super(),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: o,
        thetaLength: a,
      }),
      (n = Math.max(3, n)),
      (i = Math.max(1, i));
    const u = [],
      d = [],
      h = [],
      m = [];
    let g = e;
    const v = (t - e) / i,
      x = new J(),
      A = new Ge();
    for (let C = 0; C <= i; C++) {
      for (let E = 0; E <= n; E++) {
        const S = o + (E / n) * a;
        (x.x = g * Math.cos(S)),
          (x.y = g * Math.sin(S)),
          d.push(x.x, x.y, x.z),
          h.push(0, 0, 1),
          (A.x = (x.x / t + 1) / 2),
          (A.y = (x.y / t + 1) / 2),
          m.push(A.x, A.y);
      }
      g += v;
    }
    for (let C = 0; C < i; C++) {
      const E = C * (n + 1);
      for (let S = 0; S < n; S++) {
        const b = S + E,
          I = b,
          B = b + n + 1,
          z = b + n + 2,
          N = b + 1;
        u.push(I, B, N), u.push(B, z, N);
      }
    }
    this.setIndex(u),
      this.setAttribute('position', new kt(d, 3)),
      this.setAttribute('normal', new kt(h, 3)),
      this.setAttribute('uv', new kt(m, 2));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new ov(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class av extends hn {
  constructor(e = new Zu([new Ge(0, 0.5), new Ge(-0.5, -0.5), new Ge(0.5, -0.5)]), t = 12) {
    super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: e, curveSegments: t });
    const n = [],
      i = [],
      o = [],
      a = [];
    let u = 0,
      d = 0;
    if (Array.isArray(e) === !1) h(e);
    else for (let m = 0; m < e.length; m++) h(e[m]), this.addGroup(u, d, m), (u += d), (d = 0);
    this.setIndex(n),
      this.setAttribute('position', new kt(i, 3)),
      this.setAttribute('normal', new kt(o, 3)),
      this.setAttribute('uv', new kt(a, 2));
    function h(m) {
      const g = i.length / 3,
        v = m.extractPoints(t);
      let x = v.shape;
      const A = v.holes;
      Fo.isClockWise(x) === !1 && (x = x.reverse());
      for (let E = 0, S = A.length; E < S; E++) {
        const b = A[E];
        Fo.isClockWise(b) === !0 && (A[E] = b.reverse());
      }
      const C = Fo.triangulateShape(x, A);
      for (let E = 0, S = A.length; E < S; E++) {
        const b = A[E];
        x = x.concat(b);
      }
      for (let E = 0, S = x.length; E < S; E++) {
        const b = x[E];
        i.push(b.x, b.y, 0), o.push(0, 0, 1), a.push(b.x, b.y);
      }
      for (let E = 0, S = C.length; E < S; E++) {
        const b = C[E],
          I = b[0] + g,
          B = b[1] + g,
          z = b[2] + g;
        n.push(I, B, z), (d += 3);
      }
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return ZC(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const a = t[e.shapes[i]];
      n.push(a);
    }
    return new av(n, e.curveSegments);
  }
}
function ZC(r, e) {
  if (((e.shapes = []), Array.isArray(r)))
    for (let t = 0, n = r.length; t < n; t++) {
      const i = r[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(r.uuid);
  return e;
}
class Kh extends hn {
  constructor(e = 1, t = 32, n = 16, i = 0, o = Math.PI * 2, a = 0, u = Math.PI) {
    super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: o,
        thetaStart: a,
        thetaLength: u,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const d = Math.min(a + u, Math.PI);
    let h = 0;
    const m = [],
      g = new J(),
      v = new J(),
      x = [],
      A = [],
      C = [],
      E = [];
    for (let S = 0; S <= n; S++) {
      const b = [],
        I = S / n;
      let B = 0;
      S === 0 && a === 0 ? (B = 0.5 / t) : S === n && d === Math.PI && (B = -0.5 / t);
      for (let z = 0; z <= t; z++) {
        const N = z / t;
        (g.x = -e * Math.cos(i + N * o) * Math.sin(a + I * u)),
          (g.y = e * Math.cos(a + I * u)),
          (g.z = e * Math.sin(i + N * o) * Math.sin(a + I * u)),
          A.push(g.x, g.y, g.z),
          v.copy(g).normalize(),
          C.push(v.x, v.y, v.z),
          E.push(N + B, 1 - I),
          b.push(h++);
      }
      m.push(b);
    }
    for (let S = 0; S < n; S++)
      for (let b = 0; b < t; b++) {
        const I = m[S][b + 1],
          B = m[S][b],
          z = m[S + 1][b],
          N = m[S + 1][b + 1];
        (S !== 0 || a > 0) && x.push(I, B, N), (S !== n - 1 || d < Math.PI) && x.push(B, z, N);
      }
    this.setIndex(x),
      this.setAttribute('position', new kt(A, 3)),
      this.setAttribute('normal', new kt(C, 3)),
      this.setAttribute('uv', new kt(E, 2));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new Kh(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class lv extends Bl {
  constructor(e = 1, t = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(n, i, e, t),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new lv(e.radius, e.detail);
  }
}
class uv extends hn {
  constructor(e = 1, t = 0.4, n = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = 'TorusGeometry'),
      (this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: o }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const a = [],
      u = [],
      d = [],
      h = [],
      m = new J(),
      g = new J(),
      v = new J();
    for (let x = 0; x <= n; x++)
      for (let A = 0; A <= i; A++) {
        const C = (A / i) * o,
          E = (x / n) * Math.PI * 2;
        (g.x = (e + t * Math.cos(E)) * Math.cos(C)),
          (g.y = (e + t * Math.cos(E)) * Math.sin(C)),
          (g.z = t * Math.sin(E)),
          u.push(g.x, g.y, g.z),
          (m.x = e * Math.cos(C)),
          (m.y = e * Math.sin(C)),
          v.subVectors(g, m).normalize(),
          d.push(v.x, v.y, v.z),
          h.push(A / i),
          h.push(x / n);
      }
    for (let x = 1; x <= n; x++)
      for (let A = 1; A <= i; A++) {
        const C = (i + 1) * x + A - 1,
          E = (i + 1) * (x - 1) + A - 1,
          S = (i + 1) * (x - 1) + A,
          b = (i + 1) * x + A;
        a.push(C, E, b), a.push(E, S, b);
      }
    this.setIndex(a),
      this.setAttribute('position', new kt(u, 3)),
      this.setAttribute('normal', new kt(d, 3)),
      this.setAttribute('uv', new kt(h, 2));
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new uv(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class cv extends hn {
  constructor(e = 1, t = 0.4, n = 64, i = 8, o = 2, a = 3) {
    super(),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: o, q: a }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const u = [],
      d = [],
      h = [],
      m = [],
      g = new J(),
      v = new J(),
      x = new J(),
      A = new J(),
      C = new J(),
      E = new J(),
      S = new J();
    for (let I = 0; I <= n; ++I) {
      const B = (I / n) * o * Math.PI * 2;
      b(B, o, a, e, x),
        b(B + 0.01, o, a, e, A),
        E.subVectors(A, x),
        S.addVectors(A, x),
        C.crossVectors(E, S),
        S.crossVectors(C, E),
        C.normalize(),
        S.normalize();
      for (let z = 0; z <= i; ++z) {
        const N = (z / i) * Math.PI * 2,
          G = -t * Math.cos(N),
          k = t * Math.sin(N);
        (g.x = x.x + (G * S.x + k * C.x)),
          (g.y = x.y + (G * S.y + k * C.y)),
          (g.z = x.z + (G * S.z + k * C.z)),
          d.push(g.x, g.y, g.z),
          v.subVectors(g, x).normalize(),
          h.push(v.x, v.y, v.z),
          m.push(I / n),
          m.push(z / i);
      }
    }
    for (let I = 1; I <= n; I++)
      for (let B = 1; B <= i; B++) {
        const z = (i + 1) * (I - 1) + (B - 1),
          N = (i + 1) * I + (B - 1),
          G = (i + 1) * I + B,
          k = (i + 1) * (I - 1) + B;
        u.push(z, N, k), u.push(N, G, k);
      }
    this.setIndex(u),
      this.setAttribute('position', new kt(d, 3)),
      this.setAttribute('normal', new kt(h, 3)),
      this.setAttribute('uv', new kt(m, 2));
    function b(I, B, z, N, G) {
      const k = Math.cos(I),
        L = Math.sin(I),
        D = (z / B) * I,
        V = Math.cos(D);
      (G.x = N * (2 + V) * 0.5 * k), (G.y = N * (2 + V) * L * 0.5), (G.z = N * Math.sin(D) * 0.5);
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  static fromJSON(e) {
    return new cv(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class fv extends hn {
  constructor(
    e = new qy(new J(-1, -1, 0), new J(-1, 1, 0), new J(1, 1, 0)),
    t = 64,
    n = 1,
    i = 8,
    o = !1,
  ) {
    super(),
      (this.type = 'TubeGeometry'),
      (this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: i, closed: o });
    const a = e.computeFrenetFrames(t, o);
    (this.tangents = a.tangents), (this.normals = a.normals), (this.binormals = a.binormals);
    const u = new J(),
      d = new J(),
      h = new Ge();
    let m = new J();
    const g = [],
      v = [],
      x = [],
      A = [];
    C(),
      this.setIndex(A),
      this.setAttribute('position', new kt(g, 3)),
      this.setAttribute('normal', new kt(v, 3)),
      this.setAttribute('uv', new kt(x, 2));
    function C() {
      for (let I = 0; I < t; I++) E(I);
      E(o === !1 ? t : 0), b(), S();
    }
    function E(I) {
      m = e.getPointAt(I / t, m);
      const B = a.normals[I],
        z = a.binormals[I];
      for (let N = 0; N <= i; N++) {
        const G = (N / i) * Math.PI * 2,
          k = Math.sin(G),
          L = -Math.cos(G);
        (d.x = L * B.x + k * z.x),
          (d.y = L * B.y + k * z.y),
          (d.z = L * B.z + k * z.z),
          d.normalize(),
          v.push(d.x, d.y, d.z),
          (u.x = m.x + n * d.x),
          (u.y = m.y + n * d.y),
          (u.z = m.z + n * d.z),
          g.push(u.x, u.y, u.z);
      }
    }
    function S() {
      for (let I = 1; I <= t; I++)
        for (let B = 1; B <= i; B++) {
          const z = (i + 1) * (I - 1) + (B - 1),
            N = (i + 1) * I + (B - 1),
            G = (i + 1) * I + B,
            k = (i + 1) * (I - 1) + B;
          A.push(z, N, k), A.push(N, G, k);
        }
    }
    function b() {
      for (let I = 0; I <= t; I++)
        for (let B = 0; B <= i; B++) (h.x = I / t), (h.y = B / i), x.push(h.x, h.y);
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new fv(
      new Dg[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed,
    );
  }
}
class zM extends hn {
  constructor(e = null) {
    if (
      (super(), (this.type = 'WireframeGeometry'), (this.parameters = { geometry: e }), e !== null)
    ) {
      const t = [],
        n = new Set(),
        i = new J(),
        o = new J();
      if (e.index !== null) {
        const a = e.attributes.position,
          u = e.index;
        let d = e.groups;
        d.length === 0 && (d = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let h = 0, m = d.length; h < m; ++h) {
          const g = d[h],
            v = g.start,
            x = g.count;
          for (let A = v, C = v + x; A < C; A += 3)
            for (let E = 0; E < 3; E++) {
              const S = u.getX(A + E),
                b = u.getX(A + ((E + 1) % 3));
              i.fromBufferAttribute(a, S),
                o.fromBufferAttribute(a, b),
                sA(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let u = 0, d = a.count / 3; u < d; u++)
          for (let h = 0; h < 3; h++) {
            const m = 3 * u + h,
              g = 3 * u + ((h + 1) % 3);
            i.fromBufferAttribute(a, m),
              o.fromBufferAttribute(a, g),
              sA(i, o, n) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute('position', new kt(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
  }
}
function sA(r, e, t) {
  const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var oA = Object.freeze({
  __proto__: null,
  BoxGeometry: oc,
  CapsuleGeometry: ev,
  CircleGeometry: tv,
  ConeGeometry: nv,
  CylinderGeometry: Jf,
  DodecahedronGeometry: iv,
  EdgesGeometry: NM,
  ExtrudeGeometry: sv,
  IcosahedronGeometry: Jh,
  LatheGeometry: Xh,
  OctahedronGeometry: Yh,
  PlaneGeometry: Pl,
  PolyhedronGeometry: Bl,
  RingGeometry: ov,
  ShapeGeometry: av,
  SphereGeometry: Kh,
  TetrahedronGeometry: lv,
  TorusGeometry: uv,
  TorusKnotGeometry: cv,
  TubeGeometry: fv,
  WireframeGeometry: zM,
});
class HM extends Oi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = 'ShadowMaterial'),
      (this.color = new At(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class GM extends is {
  constructor(e) {
    super(e), (this.isRawShaderMaterial = !0), (this.type = 'RawShaderMaterial');
  }
}
class jh extends Oi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = 'MeshStandardMaterial'),
      (this.defines = { STANDARD: '' }),
      (this.color = new At(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new At(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '' }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Ns extends jh {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ge(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return un((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new At(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new At(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new At(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class VM extends Oi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new At(16777215)),
      (this.specular = new At(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new At(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Lh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class WM extends Oi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new At(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class XM extends Oi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class JM extends Oi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new At(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new At(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ys()),
      (this.combine = Lh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class e_ extends Oi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = lM),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class t_ extends Oi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class YM extends Oi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new At(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Il),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: '' }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class KM extends Sr {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Vu(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == 'number'
    ? new e(r)
    : Array.prototype.slice.call(r);
}
function jM(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function ZM(r) {
  function e(i, o) {
    return r[i] - r[o];
  }
  const t = r.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function my(r, e, t) {
  const n = r.length,
    i = new r.constructor(n);
  for (let o = 0, a = 0; a !== n; ++o) {
    const u = t[o] * e;
    for (let d = 0; d !== e; ++d) i[a++] = r[u + d];
  }
  return i;
}
function n_(r, e, t, n) {
  let i = 1,
    o = r[0];
  for (; o !== void 0 && o[n] === void 0; ) o = r[i++];
  if (o === void 0) return;
  let a = o[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do (a = o[n]), a !== void 0 && (e.push(o.time), t.push.apply(t, a)), (o = r[i++]);
      while (o !== void 0);
    else if (a.toArray !== void 0)
      do (a = o[n]), a !== void 0 && (e.push(o.time), a.toArray(t, t.length)), (o = r[i++]);
      while (o !== void 0);
    else
      do (a = o[n]), a !== void 0 && (e.push(o.time), t.push(a)), (o = r[i++]);
      while (o !== void 0);
}
function QC(r, e, t, n, i = 30) {
  const o = r.clone();
  o.name = e;
  const a = [];
  for (let d = 0; d < o.tracks.length; ++d) {
    const h = o.tracks[d],
      m = h.getValueSize(),
      g = [],
      v = [];
    for (let x = 0; x < h.times.length; ++x) {
      const A = h.times[x] * i;
      if (!(A < t || A >= n)) {
        g.push(h.times[x]);
        for (let C = 0; C < m; ++C) v.push(h.values[x * m + C]);
      }
    }
    g.length !== 0 &&
      ((h.times = Vu(g, h.times.constructor)), (h.values = Vu(v, h.values.constructor)), a.push(h));
  }
  o.tracks = a;
  let u = 1 / 0;
  for (let d = 0; d < o.tracks.length; ++d) u > o.tracks[d].times[0] && (u = o.tracks[d].times[0]);
  for (let d = 0; d < o.tracks.length; ++d) o.tracks[d].shift(-1 * u);
  return o.resetDuration(), o;
}
function qC(r, e = 0, t = r, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length,
    o = e / n;
  for (let a = 0; a < i; ++a) {
    const u = t.tracks[a],
      d = u.ValueTypeName;
    if (d === 'bool' || d === 'string') continue;
    const h = r.tracks.find(function (S) {
      return S.name === u.name && S.ValueTypeName === d;
    });
    if (h === void 0) continue;
    let m = 0;
    const g = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = g / 3);
    let v = 0;
    const x = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (v = x / 3);
    const A = u.times.length - 1;
    let C;
    if (o <= u.times[0]) {
      const S = m,
        b = g - m;
      C = u.values.slice(S, b);
    } else if (o >= u.times[A]) {
      const S = A * g + m,
        b = S + g - m;
      C = u.values.slice(S, b);
    } else {
      const S = u.createInterpolant(),
        b = m,
        I = g - m;
      S.evaluate(o), (C = S.resultBuffer.slice(b, I));
    }
    d === 'quaternion' && new ji().fromArray(C).normalize().conjugate().toArray(C);
    const E = h.times.length;
    for (let S = 0; S < E; ++S) {
      const b = S * x + v;
      if (d === 'quaternion') ji.multiplyQuaternionsFlat(h.values, b, C, 0, h.values, b);
      else {
        const I = x - v * 2;
        for (let B = 0; B < I; ++B) h.values[b + B] -= C[B];
      }
    }
  }
  return (r.blendMode = Fy), r;
}
const $C = {
  convertArray: Vu,
  isTypedArray: jM,
  getKeyframeOrder: ZM,
  sortedArray: my,
  flattenJSON: n_,
  subclip: QC,
  makeClipAdditive: qC,
};
class Yf {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      o = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i: if (!(e < i)) {
            for (let u = n + 2; ; ) {
              if (i === void 0) {
                if (e < o) break i;
                return (n = t.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
              }
              if (n === u) break;
              if (((o = i), (i = t[++n]), e < i)) break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= o)) {
            const u = t[1];
            e < u && ((n = 2), (o = u));
            for (let d = n - 2; ; ) {
              if (o === void 0) return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === d) break;
              if (((i = o), (o = t[--n - 1]), e >= o)) break t;
            }
            (a = n), (n = 0);
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const u = (n + a) >>> 1;
          e < t[u] ? (a = u) : (n = u + 1);
        }
        if (((i = t[n]), (o = t[n - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (n = t.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
      }
      (this._cachedIndex = n), this.intervalChanged_(n, o, i);
    }
    return this.interpolate_(n, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let a = 0; a !== i; ++a) t[a] = n[o + a];
    return t;
  }
  interpolate_() {
    throw new Error('call to abstract method');
  }
  intervalChanged_() {}
}
class QM extends Yf {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: ku, endingEnd: ku });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let o = e - 2,
      a = e + 1,
      u = i[o],
      d = i[a];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case zu:
          (o = e), (u = 2 * t - n);
          break;
        case Ah:
          (o = i.length - 2), (u = t + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (u = n);
      }
    if (d === void 0)
      switch (this.getSettings_().endingEnd) {
        case zu:
          (a = e), (d = 2 * n - t);
          break;
        case Ah:
          (a = 1), (d = n + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (d = t);
      }
    const h = (n - t) * 0.5,
      m = this.valueSize;
    (this._weightPrev = h / (t - u)),
      (this._weightNext = h / (d - n)),
      (this._offsetPrev = o * m),
      (this._offsetNext = a * m);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      u = this.valueSize,
      d = e * u,
      h = d - u,
      m = this._offsetPrev,
      g = this._offsetNext,
      v = this._weightPrev,
      x = this._weightNext,
      A = (n - t) / (i - t),
      C = A * A,
      E = C * A,
      S = -v * E + 2 * v * C - v * A,
      b = (1 + v) * E + (-1.5 - 2 * v) * C + (-0.5 + v) * A + 1,
      I = (-1 - x) * E + (1.5 + x) * C + 0.5 * A,
      B = x * E - x * C;
    for (let z = 0; z !== u; ++z) o[z] = S * a[m + z] + b * a[h + z] + I * a[d + z] + B * a[g + z];
    return o;
  }
}
class i_ extends Yf {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      u = this.valueSize,
      d = e * u,
      h = d - u,
      m = (n - t) / (i - t),
      g = 1 - m;
    for (let v = 0; v !== u; ++v) o[v] = a[h + v] * g + a[d + v] * m;
    return o;
  }
}
class qM extends Yf {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class vo {
  constructor(e, t, n, i) {
    if (e === void 0) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (t === void 0 || t.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
    (this.name = e),
      (this.times = Vu(t, this.TimeBufferType)),
      (this.values = Vu(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = { name: e.name, times: Vu(e.times, Array), values: Vu(e.values, Array) };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new qM(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new i_(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new QM(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case kf:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case zf:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Xm:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn('THREE.KeyframeTrack:', n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return kf;
      case this.InterpolantFactoryMethodLinear:
        return zf;
      case this.InterpolantFactoryMethodSmooth:
        return Xm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let o = 0,
      a = i - 1;
    for (; o !== i && n[o] < e; ) ++o;
    for (; a !== -1 && n[a] > t; ) --a;
    if ((++a, o !== 0 || a !== i)) {
      o >= a && ((a = Math.max(a, 1)), (o = a - 1));
      const u = this.getValueSize();
      (this.times = n.slice(o, a)), (this.values = this.values.slice(o * u, a * u));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (e = !1));
    const n = this.times,
      i = this.values,
      o = n.length;
    o === 0 && (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1));
    let a = null;
    for (let u = 0; u !== o; u++) {
      const d = n[u];
      if (typeof d == 'number' && isNaN(d)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, u, d), (e = !1);
        break;
      }
      if (a !== null && a > d) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, u, d, a), (e = !1);
        break;
      }
      a = d;
    }
    if (i !== void 0 && jM(i))
      for (let u = 0, d = i.length; u !== d; ++u) {
        const h = i[u];
        if (isNaN(h)) {
          console.error('THREE.KeyframeTrack: Value is not a valid number.', this, u, h), (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === Xm,
      o = e.length - 1;
    let a = 1;
    for (let u = 1; u < o; ++u) {
      let d = !1;
      const h = e[u],
        m = e[u + 1];
      if (h !== m && (u !== 1 || h !== e[0]))
        if (i) d = !0;
        else {
          const g = u * n,
            v = g - n,
            x = g + n;
          for (let A = 0; A !== n; ++A) {
            const C = t[g + A];
            if (C !== t[v + A] || C !== t[x + A]) {
              d = !0;
              break;
            }
          }
        }
      if (d) {
        if (u !== a) {
          e[a] = e[u];
          const g = u * n,
            v = a * n;
          for (let x = 0; x !== n; ++x) t[v + x] = t[g + x];
        }
        ++a;
      }
    }
    if (o > 0) {
      e[a] = e[o];
      for (let u = o * n, d = a * n, h = 0; h !== n; ++h) t[d + h] = t[u + h];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = e.slice(0, a)), (this.values = t.slice(0, a * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
vo.prototype.TimeBufferType = Float32Array;
vo.prototype.ValueBufferType = Float32Array;
vo.prototype.DefaultInterpolation = zf;
class ac extends vo {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
ac.prototype.ValueTypeName = 'bool';
ac.prototype.ValueBufferType = Array;
ac.prototype.DefaultInterpolation = kf;
ac.prototype.InterpolantFactoryMethodLinear = void 0;
ac.prototype.InterpolantFactoryMethodSmooth = void 0;
class r_ extends vo {}
r_.prototype.ValueTypeName = 'color';
class nc extends vo {}
nc.prototype.ValueTypeName = 'number';
class $M extends Yf {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      u = this.valueSize,
      d = (n - t) / (i - t);
    let h = e * u;
    for (let m = h + u; h !== m; h += 4) ji.slerpFlat(o, 0, a, h - u, a, h, d);
    return o;
  }
}
class ic extends vo {
  InterpolantFactoryMethodLinear(e) {
    return new $M(this.times, this.values, this.getValueSize(), e);
  }
}
ic.prototype.ValueTypeName = 'quaternion';
ic.prototype.InterpolantFactoryMethodSmooth = void 0;
class lc extends vo {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
lc.prototype.ValueTypeName = 'string';
lc.prototype.ValueBufferType = Array;
lc.prototype.DefaultInterpolation = kf;
lc.prototype.InterpolantFactoryMethodLinear = void 0;
lc.prototype.InterpolantFactoryMethodSmooth = void 0;
class rc extends vo {}
rc.prototype.ValueTypeName = 'vector';
class Vf {
  constructor(e = '', t = -1, n = [], i = Xg) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = vs()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, u = n.length; a !== u; ++a) t.push(tT(n[a]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
    for (let o = 0, a = n.length; o !== a; ++o) t.push(vo.toJSON(n[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const o = t.length,
      a = [];
    for (let u = 0; u < o; u++) {
      let d = [],
        h = [];
      d.push((u + o - 1) % o, u, (u + 1) % o), h.push(0, 1, 0);
      const m = ZM(d);
      (d = my(d, 1, m)),
        (h = my(h, 1, m)),
        !i && d[0] === 0 && (d.push(o), h.push(h[0])),
        a.push(new nc('.morphTargetInfluences[' + t[u].name + ']', d, h).scale(1 / n));
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, d = e.length; u < d; u++) {
      const h = e[u],
        m = h.name.match(o);
      if (m && m.length > 1) {
        const g = m[1];
        let v = i[g];
        v || (i[g] = v = []), v.push(h);
      }
    }
    const a = [];
    for (const u in i) a.push(this.CreateFromMorphTargetSequence(u, i[u], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
    const n = function (g, v, x, A, C) {
        if (x.length !== 0) {
          const E = [],
            S = [];
          n_(x, E, S, A), E.length !== 0 && C.push(new g(v, E, S));
        }
      },
      i = [],
      o = e.name || 'default',
      a = e.fps || 30,
      u = e.blendMode;
    let d = e.length || -1;
    const h = e.hierarchy || [];
    for (let g = 0; g < h.length; g++) {
      const v = h[g].keys;
      if (!(!v || v.length === 0))
        if (v[0].morphTargets) {
          const x = {};
          let A;
          for (A = 0; A < v.length; A++)
            if (v[A].morphTargets)
              for (let C = 0; C < v[A].morphTargets.length; C++) x[v[A].morphTargets[C]] = -1;
          for (const C in x) {
            const E = [],
              S = [];
            for (let b = 0; b !== v[A].morphTargets.length; ++b) {
              const I = v[A];
              E.push(I.time), S.push(I.morphTarget === C ? 1 : 0);
            }
            i.push(new nc('.morphTargetInfluence[' + C + ']', E, S));
          }
          d = x.length * a;
        } else {
          const x = '.bones[' + t[g].name + ']';
          n(rc, x + '.position', v, 'pos', i),
            n(ic, x + '.quaternion', v, 'rot', i),
            n(rc, x + '.scale', v, 'scl', i);
        }
    }
    return i.length === 0 ? null : new this(o, d, i, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const o = this.tracks[n];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function eT(r) {
  switch (r.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return nc;
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return rc;
    case 'color':
      return r_;
    case 'quaternion':
      return ic;
    case 'bool':
    case 'boolean':
      return ac;
    case 'string':
      return lc;
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + r);
}
function tT(r) {
  if (r.type === void 0)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  const e = eT(r.type);
  if (r.times === void 0) {
    const t = [],
      n = [];
    n_(r.keys, t, n, 'value'), (r.times = t), (r.values = n);
  }
  return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation);
}
const Pa = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  },
};
class dv {
  constructor(e, t, n) {
    const i = this;
    let o = !1,
      a = 0,
      u = 0,
      d;
    const h = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (m) {
        u++, o === !1 && i.onStart !== void 0 && i.onStart(m, a, u), (o = !0);
      }),
      (this.itemEnd = function (m) {
        a++,
          i.onProgress !== void 0 && i.onProgress(m, a, u),
          a === u && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (m) {
        i.onError !== void 0 && i.onError(m);
      }),
      (this.resolveURL = function (m) {
        return d ? d(m) : m;
      }),
      (this.setURLModifier = function (m) {
        return (d = m), this;
      }),
      (this.addHandler = function (m, g) {
        return h.push(m, g), this;
      }),
      (this.removeHandler = function (m) {
        const g = h.indexOf(m);
        return g !== -1 && h.splice(g, 2), this;
      }),
      (this.getHandler = function (m) {
        for (let g = 0, v = h.length; g < v; g += 2) {
          const x = h[g],
            A = h[g + 1];
          if ((x.global && (x.lastIndex = 0), x.test(m))) return A;
        }
        return null;
      });
  }
}
const eE = new dv();
class lr {
  constructor(e) {
    (this.manager = e !== void 0 ? e : eE),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, o) {
      n.load(e, i, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
lr.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const Ca = {};
class nT extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class ar extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Pa.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (Ca[e] !== void 0) {
      Ca[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (Ca[e] = []), Ca[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin',
      }),
      u = this.mimeType,
      d = this.responseType;
    fetch(a)
      .then((h) => {
        if (h.status === 200 || h.status === 0) {
          if (
            (h.status === 0 && console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' || h.body === void 0 || h.body.getReader === void 0)
          )
            return h;
          const m = Ca[e],
            g = h.body.getReader(),
            v = h.headers.get('X-File-Size') || h.headers.get('Content-Length'),
            x = v ? parseInt(v) : 0,
            A = x !== 0;
          let C = 0;
          const E = new ReadableStream({
            start(S) {
              b();
              function b() {
                g.read().then(
                  ({ done: I, value: B }) => {
                    if (I) S.close();
                    else {
                      C += B.byteLength;
                      const z = new ProgressEvent('progress', {
                        lengthComputable: A,
                        loaded: C,
                        total: x,
                      });
                      for (let N = 0, G = m.length; N < G; N++) {
                        const k = m[N];
                        k.onProgress && k.onProgress(z);
                      }
                      S.enqueue(B), b();
                    }
                  },
                  (I) => {
                    S.error(I);
                  },
                );
              }
            },
          });
          return new Response(E);
        } else throw new nT(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h);
      })
      .then((h) => {
        switch (d) {
          case 'arraybuffer':
            return h.arrayBuffer();
          case 'blob':
            return h.blob();
          case 'document':
            return h.text().then((m) => new DOMParser().parseFromString(m, u));
          case 'json':
            return h.json();
          default:
            if (u === void 0) return h.text();
            {
              const g = /charset="?([^;"\s]*)"?/i.exec(u),
                v = g && g[1] ? g[1].toLowerCase() : void 0,
                x = new TextDecoder(v);
              return h.arrayBuffer().then((A) => x.decode(A));
            }
        }
      })
      .then((h) => {
        Pa.add(e, h);
        const m = Ca[e];
        delete Ca[e];
        for (let g = 0, v = m.length; g < v; g++) {
          const x = m[g];
          x.onLoad && x.onLoad(h);
        }
      })
      .catch((h) => {
        const m = Ca[e];
        if (m === void 0) throw (this.manager.itemError(e), h);
        delete Ca[e];
        for (let g = 0, v = m.length; g < v; g++) {
          const x = m[g];
          x.onError && x.onError(h);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class iT extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = new ar(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (u) {
          try {
            t(o.parse(JSON.parse(u)));
          } catch (d) {
            i ? i(d) : console.error(d), o.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Vf.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class rT extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = [],
      u = new qg(),
      d = new ar(this.manager);
    d.setPath(this.path),
      d.setResponseType('arraybuffer'),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(o.withCredentials);
    let h = 0;
    function m(g) {
      d.load(
        e[g],
        function (v) {
          const x = o.parse(v, !0);
          (a[g] = { width: x.width, height: x.height, format: x.format, mipmaps: x.mipmaps }),
            (h += 1),
            h === 6 &&
              (x.mipmapCount === 1 && (u.minFilter = Fn),
              (u.image = a),
              (u.format = x.format),
              (u.needsUpdate = !0),
              t && t(u));
        },
        n,
        i,
      );
    }
    if (Array.isArray(e)) for (let g = 0, v = e.length; g < v; ++g) m(g);
    else
      d.load(
        e,
        function (g) {
          const v = o.parse(g, !0);
          if (v.isCubemap) {
            const x = v.mipmaps.length / v.mipmapCount;
            for (let A = 0; A < x; A++) {
              a[A] = { mipmaps: [] };
              for (let C = 0; C < v.mipmapCount; C++)
                a[A].mipmaps.push(v.mipmaps[A * v.mipmapCount + C]),
                  (a[A].format = v.format),
                  (a[A].width = v.width),
                  (a[A].height = v.height);
            }
            u.image = a;
          } else (u.image.width = v.width), (u.image.height = v.height), (u.mipmaps = v.mipmaps);
          v.mipmapCount === 1 && (u.minFilter = Fn),
            (u.format = v.format),
            (u.needsUpdate = !0),
            t && t(u);
        },
        n,
        i,
      );
    return u;
  }
}
class Ih extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
    const o = this,
      a = Pa.get(e);
    if (a !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    const u = wh('img');
    function d() {
      m(), Pa.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function h(g) {
      m(), i && i(g), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function m() {
      u.removeEventListener('load', d, !1), u.removeEventListener('error', h, !1);
    }
    return (
      u.addEventListener('load', d, !1),
      u.addEventListener('error', h, !1),
      e.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (u.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (u.src = e),
      u
    );
  }
}
class tE extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new zh();
    o.colorSpace = xr;
    const a = new Ih(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let u = 0;
    function d(h) {
      a.load(
        e[h],
        function (m) {
          (o.images[h] = m), u++, u === 6 && ((o.needsUpdate = !0), t && t(o));
        },
        void 0,
        i,
      );
    }
    for (let h = 0; h < e.length; ++h) d(h);
    return o;
  }
}
class s_ extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = new po(),
      u = new ar(this.manager);
    return (
      u.setResponseType('arraybuffer'),
      u.setRequestHeader(this.requestHeader),
      u.setPath(this.path),
      u.setWithCredentials(o.withCredentials),
      u.load(
        e,
        function (d) {
          let h;
          try {
            h = o.parse(d);
          } catch (m) {
            if (i !== void 0) i(m);
            else {
              console.error(m);
              return;
            }
          }
          h.image !== void 0
            ? (a.image = h.image)
            : h.data !== void 0 &&
              ((a.image.width = h.width), (a.image.height = h.height), (a.image.data = h.data)),
            (a.wrapS = h.wrapS !== void 0 ? h.wrapS : Ai),
            (a.wrapT = h.wrapT !== void 0 ? h.wrapT : Ai),
            (a.magFilter = h.magFilter !== void 0 ? h.magFilter : Fn),
            (a.minFilter = h.minFilter !== void 0 ? h.minFilter : Fn),
            (a.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1),
            h.colorSpace !== void 0 && (a.colorSpace = h.colorSpace),
            h.flipY !== void 0 && (a.flipY = h.flipY),
            h.format !== void 0 && (a.format = h.format),
            h.type !== void 0 && (a.type = h.type),
            h.mipmaps !== void 0 && ((a.mipmaps = h.mipmaps), (a.minFilter = Ds)),
            h.mipmapCount === 1 && (a.minFilter = Fn),
            h.generateMipmaps !== void 0 && (a.generateMipmaps = h.generateMipmaps),
            (a.needsUpdate = !0),
            t && t(a, h);
        },
        n,
        i,
      ),
      a
    );
  }
}
class Zh extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = new Ln(),
      a = new Ih(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (u) {
          (o.image = u), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        n,
        i,
      ),
      o
    );
  }
}
class Dl extends wn {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new At(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class nE extends Dl {
  constructor(e, t, n) {
    super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = 'HemisphereLight'),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new At(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const T0 = new Qt(),
  aA = new J(),
  lA = new J();
class o_ {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ge(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Qt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Wh()),
      (this._frameExtents = new Ge(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Bn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    aA.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(aA),
      lA.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(lA),
      t.updateMatrixWorld(),
      T0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(T0),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(T0);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class sT extends o_ {
  constructor() {
    super(new gi(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = Hf * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || o !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class a_ extends Dl {
  constructor(e, t, n = 0, i = Math.PI / 3, o = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new wn()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new sT());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const uA = new Qt(),
  th = new J(),
  R0 = new J();
class oT extends o_ {
  constructor() {
    super(new gi(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ge(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Bn(2, 1, 1, 1),
        new Bn(0, 1, 1, 1),
        new Bn(3, 1, 1, 1),
        new Bn(1, 1, 1, 1),
        new Bn(3, 0, 1, 1),
        new Bn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new J(1, 0, 0),
        new J(-1, 0, 0),
        new J(0, 0, 1),
        new J(0, 0, -1),
        new J(0, 1, 0),
        new J(0, -1, 0),
      ]),
      (this._cubeUps = [
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 0, 1),
        new J(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      o = e.distance || n.far;
    o !== n.far && ((n.far = o), n.updateProjectionMatrix()),
      th.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(th),
      R0.copy(n.position),
      R0.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(R0),
      n.updateMatrixWorld(),
      i.makeTranslation(-th.x, -th.y, -th.z),
      uA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(uA);
  }
}
class l_ extends Dl {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new oT());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class No extends kh {
  constructor(e = -1, t = 1, n = 1, i = -1, o = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = o),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, o, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = n - e,
      a = n + e,
      u = i + t,
      d = i - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
        m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += h * this.view.offsetX),
        (a = o + h * this.view.width),
        (u -= m * this.view.offsetY),
        (d = u - m * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(o, a, u, d, this.near, this.far, this.coordinateSystem),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class aT extends o_ {
  constructor() {
    super(new No(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class u_ extends Dl {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(wn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new wn()),
      (this.shadow = new aT());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
  }
}
class iE extends Dl {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
  }
}
class rE extends Dl {
  constructor(e, t, n = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = 'RectAreaLight'),
      (this.width = n),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), (this.width = e.width), (this.height = e.height), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class sE {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new J());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      i = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.282095),
      t.addScaledVector(a[1], 0.488603 * i),
      t.addScaledVector(a[2], 0.488603 * o),
      t.addScaledVector(a[3], 0.488603 * n),
      t.addScaledVector(a[4], 1.092548 * (n * i)),
      t.addScaledVector(a[5], 1.092548 * (i * o)),
      t.addScaledVector(a[6], 0.315392 * (3 * o * o - 1)),
      t.addScaledVector(a[7], 1.092548 * (n * o)),
      t.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      i = e.y,
      o = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.886227),
      t.addScaledVector(a[1], 2 * 0.511664 * i),
      t.addScaledVector(a[2], 2 * 0.511664 * o),
      t.addScaledVector(a[3], 2 * 0.511664 * n),
      t.addScaledVector(a[4], 2 * 0.429043 * n * i),
      t.addScaledVector(a[5], 2 * 0.429043 * i * o),
      t.addScaledVector(a[6], 0.743125 * o * o - 0.247708),
      t.addScaledVector(a[7], 2 * 0.429043 * n * o),
      t.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      i = e.y,
      o = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * o),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * i),
      (t[5] = 1.092548 * i * o),
      (t[6] = 0.315392 * (3 * o * o - 1)),
      (t[7] = 1.092548 * n * o),
      (t[8] = 0.546274 * (n * n - i * i));
  }
}
class oE extends Dl {
  constructor(e = new sE(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class hv extends lr {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, n, i) {
    const o = this,
      a = new ar(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (u) {
          try {
            t(o.parse(JSON.parse(u)));
          } catch (d) {
            i ? i(d) : console.error(d), o.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = this.textures;
    function n(o) {
      return t[o] === void 0 && console.warn('THREE.MaterialLoader: Undefined texture', o), t[o];
    }
    const i = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new At().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive),
      e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == 'number'
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const a = e.uniforms[o];
        switch (((i.uniforms[o] = {}), a.type)) {
          case 't':
            i.uniforms[o].value = n(a.value);
            break;
          case 'c':
            i.uniforms[o].value = new At().setHex(a.value);
            break;
          case 'v2':
            i.uniforms[o].value = new Ge().fromArray(a.value);
            break;
          case 'v3':
            i.uniforms[o].value = new J().fromArray(a.value);
            break;
          case 'v4':
            i.uniforms[o].value = new Bn().fromArray(a.value);
            break;
          case 'm3':
            i.uniforms[o].value = new dn().fromArray(a.value);
            break;
          case 'm4':
            i.uniforms[o].value = new Qt().fromArray(a.value);
            break;
          default:
            i.uniforms[o].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = n(e.map)),
      e.matcap !== void 0 && (i.matcap = n(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), (i.normalScale = new Ge().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)),
      e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
      e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
      e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)),
      e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = n(e.envMap)),
      e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
      e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new Ge().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return hv.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: HM,
      SpriteMaterial: Gy,
      RawShaderMaterial: GM,
      ShaderMaterial: is,
      PointsMaterial: Qg,
      MeshPhysicalMaterial: Ns,
      MeshStandardMaterial: jh,
      MeshPhongMaterial: VM,
      MeshToonMaterial: WM,
      MeshNormalMaterial: XM,
      MeshLambertMaterial: JM,
      MeshDepthMaterial: e_,
      MeshDistanceMaterial: t_,
      MeshBasicMaterial: ts,
      MeshMatcapMaterial: YM,
      LineDashedMaterial: KM,
      LineBasicMaterial: Sr,
      Material: Oi,
    };
    return new t[e]();
  }
}
class wl {
  static decodeText(e) {
    if (
      (console.warn(
        'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.',
      ),
      typeof TextDecoder < 'u')
    )
      return new TextDecoder().decode(e);
    let t = '';
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf('/');
    return t === -1 ? './' : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != 'string' || e === ''
      ? ''
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class aE extends hn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.instanceCount = this.instanceCount), (e.isInstancedBufferGeometry = !0), e;
  }
}
class lE extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = new ar(o.manager);
    a.setPath(o.path),
      a.setRequestHeader(o.requestHeader),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (u) {
          try {
            t(o.parse(JSON.parse(u)));
          } catch (d) {
            i ? i(d) : console.error(d), o.manager.itemError(e);
          }
        },
        n,
        i,
      );
  }
  parse(e) {
    const t = {},
      n = {};
    function i(x, A) {
      if (t[A] !== void 0) return t[A];
      const E = x.interleavedBuffers[A],
        S = o(x, E.buffer),
        b = bf(E.type, S),
        I = new Gh(b, E.stride);
      return (I.uuid = E.uuid), (t[A] = I), I;
    }
    function o(x, A) {
      if (n[A] !== void 0) return n[A];
      const E = x.arrayBuffers[A],
        S = new Uint32Array(E).buffer;
      return (n[A] = S), S;
    }
    const a = e.isInstancedBufferGeometry ? new aE() : new hn(),
      u = e.data.index;
    if (u !== void 0) {
      const x = bf(u.type, u.array);
      a.setIndex(new Pn(x, 1));
    }
    const d = e.data.attributes;
    for (const x in d) {
      const A = d[x];
      let C;
      if (A.isInterleavedBufferAttribute) {
        const E = i(e.data, A.data);
        C = new bl(E, A.itemSize, A.offset, A.normalized);
      } else {
        const E = bf(A.type, A.array),
          S = A.isInstancedBufferAttribute ? ec : Pn;
        C = new S(E, A.itemSize, A.normalized);
      }
      A.name !== void 0 && (C.name = A.name),
        A.usage !== void 0 && C.setUsage(A.usage),
        a.setAttribute(x, C);
    }
    const h = e.data.morphAttributes;
    if (h)
      for (const x in h) {
        const A = h[x],
          C = [];
        for (let E = 0, S = A.length; E < S; E++) {
          const b = A[E];
          let I;
          if (b.isInterleavedBufferAttribute) {
            const B = i(e.data, b.data);
            I = new bl(B, b.itemSize, b.offset, b.normalized);
          } else {
            const B = bf(b.type, b.array);
            I = new Pn(B, b.itemSize, b.normalized);
          }
          b.name !== void 0 && (I.name = b.name), C.push(I);
        }
        a.morphAttributes[x] = C;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const g = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (g !== void 0)
      for (let x = 0, A = g.length; x !== A; ++x) {
        const C = g[x];
        a.addGroup(C.start, C.count, C.materialIndex);
      }
    const v = e.data.boundingSphere;
    if (v !== void 0) {
      const x = new J();
      v.center !== void 0 && x.fromArray(v.center), (a.boundingSphere = new or(x, v.radius));
    }
    return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a;
  }
}
class lT extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = this.path === '' ? wl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const u = new ar(this.manager);
    u.setPath(this.path),
      u.setRequestHeader(this.requestHeader),
      u.setWithCredentials(this.withCredentials),
      u.load(
        e,
        function (d) {
          let h = null;
          try {
            h = JSON.parse(d);
          } catch (g) {
            i !== void 0 && i(g),
              console.error("THREE:ObjectLoader: Can't parse " + e + '.', g.message);
            return;
          }
          const m = h.metadata;
          if (m === void 0 || m.type === void 0 || m.type.toLowerCase() === 'geometry') {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(h, t);
        },
        n,
        i,
      );
  }
  async loadAsync(e, t) {
    const n = this,
      i = this.path === '' ? wl.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new ar(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const a = await o.loadAsync(e, t),
      u = JSON.parse(a),
      d = u.metadata;
    if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === 'geometry')
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      a = this.parseImages(e.images, function () {
        t !== void 0 && t(h);
      }),
      u = this.parseTextures(e.textures, a),
      d = this.parseMaterials(e.materials, u),
      h = this.parseObject(e.object, o, d, u, n),
      m = this.parseSkeletons(e.skeletons, h);
    if ((this.bindSkeletons(h, m), this.bindLightTargets(h), t !== void 0)) {
      let g = !1;
      for (const v in a)
        if (a[v].data instanceof HTMLImageElement) {
          g = !0;
          break;
        }
      g === !1 && t(h);
    }
    return h;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      n = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, n),
      o = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, o),
      u = this.parseMaterials(e.materials, a),
      d = this.parseObject(e.object, i, u, a, t),
      h = this.parseSkeletons(e.skeletons, d);
    return this.bindSkeletons(d, h), this.bindLightTargets(d), d;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const o = new Zu().fromJSON(e[n]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {},
      i = {};
    if (
      (t.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, a = e.length; o < a; o++) {
        const u = new Vh().fromJSON(e[o], i);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new lE();
      for (let o = 0, a = e.length; o < a; o++) {
        let u;
        const d = e[o];
        switch (d.type) {
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            u = i.parse(d);
            break;
          default:
            d.type in oA
              ? (u = oA[d.type].fromJSON(d, t))
              : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${d.type}"`);
        }
        (u.uuid = d.uuid),
          d.name !== void 0 && (u.name = d.name),
          d.userData !== void 0 && (u.userData = d.userData),
          (n[d.uuid] = u);
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {},
      i = {};
    if (e !== void 0) {
      const o = new hv();
      o.setTextures(t);
      for (let a = 0, u = e.length; a < u; a++) {
        const d = e[a];
        n[d.uuid] === void 0 && (n[d.uuid] = o.parse(d)), (i[d.uuid] = n[d.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n],
          o = Vf.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this,
      i = {};
    let o;
    function a(d) {
      return (
        n.manager.itemStart(d),
        o.load(
          d,
          function () {
            n.manager.itemEnd(d);
          },
          void 0,
          function () {
            n.manager.itemError(d), n.manager.itemEnd(d);
          },
        )
      );
    }
    function u(d) {
      if (typeof d == 'string') {
        const h = d,
          m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : n.resourcePath + h;
        return a(m);
      } else return d.data ? { data: bf(d.type, d.data), width: d.width, height: d.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const d = new dv(t);
      (o = new Ih(d)), o.setCrossOrigin(this.crossOrigin);
      for (let h = 0, m = e.length; h < m; h++) {
        const g = e[h],
          v = g.url;
        if (Array.isArray(v)) {
          const x = [];
          for (let A = 0, C = v.length; A < C; A++) {
            const E = v[A],
              S = u(E);
            S !== null &&
              (S instanceof HTMLImageElement
                ? x.push(S)
                : x.push(new po(S.data, S.width, S.height)));
          }
          i[g.uuid] = new Hu(x);
        } else {
          const x = u(g.url);
          i[g.uuid] = new Hu(x);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      n = {};
    let i;
    async function o(a) {
      if (typeof a == 'string') {
        const u = a,
          d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await i.loadAsync(d);
      } else return a.data ? { data: bf(a.type, a.data), width: a.width, height: a.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Ih(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, u = e.length; a < u; a++) {
        const d = e[a],
          h = d.url;
        if (Array.isArray(h)) {
          const m = [];
          for (let g = 0, v = h.length; g < v; g++) {
            const x = h[g],
              A = await o(x);
            A !== null &&
              (A instanceof HTMLImageElement
                ? m.push(A)
                : m.push(new po(A.data, A.width, A.height)));
          }
          n[d.uuid] = new Hu(m);
        } else {
          const m = await o(d.url);
          n[d.uuid] = new Hu(m);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(o, a) {
      return typeof o == 'number'
        ? o
        : (console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', o),
          a[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o];
        u.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid),
          t[u.image] === void 0 && console.warn('THREE.ObjectLoader: Undefined image', u.image);
        const d = t[u.image],
          h = d.data;
        let m;
        Array.isArray(h)
          ? ((m = new zh()), h.length === 6 && (m.needsUpdate = !0))
          : (h && h.data ? (m = new po()) : (m = new Ln()), h && (m.needsUpdate = !0)),
          (m.source = d),
          (m.uuid = u.uuid),
          u.name !== void 0 && (m.name = u.name),
          u.mapping !== void 0 && (m.mapping = n(u.mapping, uT)),
          u.channel !== void 0 && (m.channel = u.channel),
          u.offset !== void 0 && m.offset.fromArray(u.offset),
          u.repeat !== void 0 && m.repeat.fromArray(u.repeat),
          u.center !== void 0 && m.center.fromArray(u.center),
          u.rotation !== void 0 && (m.rotation = u.rotation),
          u.wrap !== void 0 && ((m.wrapS = n(u.wrap[0], cA)), (m.wrapT = n(u.wrap[1], cA))),
          u.format !== void 0 && (m.format = u.format),
          u.internalFormat !== void 0 && (m.internalFormat = u.internalFormat),
          u.type !== void 0 && (m.type = u.type),
          u.colorSpace !== void 0 && (m.colorSpace = u.colorSpace),
          u.minFilter !== void 0 && (m.minFilter = n(u.minFilter, fA)),
          u.magFilter !== void 0 && (m.magFilter = n(u.magFilter, fA)),
          u.anisotropy !== void 0 && (m.anisotropy = u.anisotropy),
          u.flipY !== void 0 && (m.flipY = u.flipY),
          u.generateMipmaps !== void 0 && (m.generateMipmaps = u.generateMipmaps),
          u.premultiplyAlpha !== void 0 && (m.premultiplyAlpha = u.premultiplyAlpha),
          u.unpackAlignment !== void 0 && (m.unpackAlignment = u.unpackAlignment),
          u.compareFunction !== void 0 && (m.compareFunction = u.compareFunction),
          u.userData !== void 0 && (m.userData = u.userData),
          (i[u.uuid] = m);
      }
    return i;
  }
  parseObject(e, t, n, i, o) {
    let a;
    function u(v) {
      return t[v] === void 0 && console.warn('THREE.ObjectLoader: Undefined geometry', v), t[v];
    }
    function d(v) {
      if (v !== void 0) {
        if (Array.isArray(v)) {
          const x = [];
          for (let A = 0, C = v.length; A < C; A++) {
            const E = v[A];
            n[E] === void 0 && console.warn('THREE.ObjectLoader: Undefined material', E),
              x.push(n[E]);
          }
          return x;
        }
        return n[v] === void 0 && console.warn('THREE.ObjectLoader: Undefined material', v), n[v];
      }
    }
    function h(v) {
      return i[v] === void 0 && console.warn('THREE.ObjectLoader: Undefined texture', v), i[v];
    }
    let m, g;
    switch (e.type) {
      case 'Scene':
        (a = new Hh()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new At(e.background))
              : (a.background = h(e.background))),
          e.environment !== void 0 && (a.environment = h(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === 'Fog'
              ? (a.fog = new jg(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === 'FogExp2' && (a.fog = new Kg(e.fog.color, e.fog.density)),
            e.fog.name !== '' && (a.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 && a.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 && (a.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            a.environmentRotation.fromArray(e.environmentRotation);
        break;
      case 'PerspectiveCamera':
        (a = new gi(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case 'OrthographicCamera':
        (a = new No(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case 'AmbientLight':
        a = new iE(e.color, e.intensity);
        break;
      case 'DirectionalLight':
        (a = new u_(e.color, e.intensity)), (a.target = e.target || '');
        break;
      case 'PointLight':
        a = new l_(e.color, e.intensity, e.distance, e.decay);
        break;
      case 'RectAreaLight':
        a = new rE(e.color, e.intensity, e.width, e.height);
        break;
      case 'SpotLight':
        (a = new a_(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay)),
          (a.target = e.target || '');
        break;
      case 'HemisphereLight':
        a = new nE(e.color, e.groundColor, e.intensity);
        break;
      case 'LightProbe':
        a = new oE().fromJSON(e);
        break;
      case 'SkinnedMesh':
        (m = u(e.geometry)),
          (g = d(e.material)),
          (a = new Vy(m, g)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case 'Mesh':
        (m = u(e.geometry)), (g = d(e.material)), (a = new oi(m, g));
        break;
      case 'InstancedMesh':
        (m = u(e.geometry)), (g = d(e.material));
        const v = e.count,
          x = e.instanceMatrix,
          A = e.instanceColor;
        (a = new Wy(m, g, v)),
          (a.instanceMatrix = new ec(new Float32Array(x.array), 16)),
          A !== void 0 && (a.instanceColor = new ec(new Float32Array(A.array), A.itemSize));
        break;
      case 'BatchedMesh':
        (m = u(e.geometry)),
          (g = d(e.material)),
          (a = new bM(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, g)),
          (a.geometry = m),
          (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (a.sortObjects = e.sortObjects),
          (a._drawRanges = e.drawRanges),
          (a._reservedRanges = e.reservedRanges),
          (a._visibility = e.visibility),
          (a._active = e.active),
          (a._bounds = e.bounds.map((C) => {
            const E = new Ar();
            E.min.fromArray(C.boxMin), E.max.fromArray(C.boxMax);
            const S = new or();
            return (
              (S.radius = C.sphereRadius),
              S.center.fromArray(C.sphereCenter),
              {
                boxInitialized: C.boxInitialized,
                box: E,
                sphereInitialized: C.sphereInitialized,
                sphere: S,
              }
            );
          })),
          (a._maxInstanceCount = e.maxInstanceCount),
          (a._maxVertexCount = e.maxVertexCount),
          (a._maxIndexCount = e.maxIndexCount),
          (a._geometryInitialized = e.geometryInitialized),
          (a._geometryCount = e.geometryCount),
          (a._matricesTexture = h(e.matricesTexture.uuid)),
          e.colorsTexture !== void 0 && (a._colorsTexture = h(e.colorsTexture.uuid));
        break;
      case 'LOD':
        a = new RM();
        break;
      case 'Line':
        a = new Fa(u(e.geometry), d(e.material));
        break;
      case 'LineLoop':
        a = new Xy(u(e.geometry), d(e.material));
        break;
      case 'LineSegments':
        a = new mo(u(e.geometry), d(e.material));
        break;
      case 'PointCloud':
      case 'Points':
        a = new Jy(u(e.geometry), d(e.material));
        break;
      case 'Sprite':
        a = new TM(d(e.material));
        break;
      case 'Group':
        a = new Ba();
        break;
      case 'Bone':
        a = new Zg();
        break;
      default:
        a = new wn();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 && (a.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const v = e.children;
      for (let x = 0; x < v.length; x++) a.add(this.parseObject(v[x], t, n, i, o));
    }
    if (e.animations !== void 0) {
      const v = e.animations;
      for (let x = 0; x < v.length; x++) {
        const A = v[x];
        a.animations.push(o[A]);
      }
    }
    if (e.type === 'LOD') {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const v = e.levels;
      for (let x = 0; x < v.length; x++) {
        const A = v[x],
          C = a.getObjectByProperty('uuid', A.object);
        C !== void 0 && a.addLevel(C, A.distance, A.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0
            ? console.warn('THREE.ObjectLoader: No skeleton found with UUID:', n.skeleton)
            : n.bind(i, n.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target,
          i = e.getObjectByProperty('uuid', n);
        i !== void 0 ? (t.target = i) : (t.target = new wn());
      }
    });
  }
}
const uT = {
    UVMapping: Cl,
    CubeReflectionMapping: Oo,
    CubeRefractionMapping: Tl,
    EquirectangularReflectionMapping: Nf,
    EquirectangularRefractionMapping: xh,
    CubeUVReflectionMapping: Xf,
  },
  cA = { RepeatWrapping: Rl, ClampToEdgeWrapping: Ai, MirroredRepeatWrapping: Uf },
  fA = {
    NearestFilter: Ki,
    NearestMipmapNearestFilter: Og,
    NearestMipmapLinearFilter: Ou,
    LinearFilter: Fn,
    LinearMipmapNearestFilter: Pf,
    LinearMipmapLinearFilter: Ds,
  };
class uE extends lr {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
      typeof fetch > 'u' && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      a = Pa.get(e);
    if (a !== void 0) {
      if ((o.manager.itemStart(e), a.then)) {
        a.then((h) => {
          t && t(h), o.manager.itemEnd(e);
        }).catch((h) => {
          i && i(h);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(a), o.manager.itemEnd(e);
        }, 0),
        a
      );
    }
    const u = {};
    (u.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (u.headers = this.requestHeader);
    const d = fetch(e, u)
      .then(function (h) {
        return h.blob();
      })
      .then(function (h) {
        return createImageBitmap(h, Object.assign(o.options, { colorSpaceConversion: 'none' }));
      })
      .then(function (h) {
        return Pa.add(e, h), t && t(h), o.manager.itemEnd(e), h;
      })
      .catch(function (h) {
        i && i(h), Pa.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Pa.add(e, d), o.manager.itemStart(e);
  }
}
let Rm;
class c_ {
  static getContext() {
    return Rm === void 0 && (Rm = new (window.AudioContext || window.webkitAudioContext)()), Rm;
  }
  static setContext(e) {
    Rm = e;
  }
}
class cT extends lr {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const o = this,
      a = new ar(this.manager);
    a.setResponseType('arraybuffer'),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (d) {
          try {
            const h = d.slice(0);
            c_.getContext()
              .decodeAudioData(h, function (g) {
                t(g);
              })
              .catch(u);
          } catch (h) {
            u(h);
          }
        },
        n,
        i,
      );
    function u(d) {
      i ? i(d) : console.error(d), o.manager.itemError(e);
    }
  }
}
const dA = new Qt(),
  hA = new Qt(),
  wu = new Qt();
class fT {
  constructor() {
    (this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new gi()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new gi()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        wu.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        o = (i * t.near) / t.focus,
        a = (t.near * Math.tan(Ku * t.fov * 0.5)) / t.zoom;
      let u, d;
      (hA.elements[12] = -i),
        (dA.elements[12] = i),
        (u = -a * t.aspect + o),
        (d = a * t.aspect + o),
        (wu.elements[0] = (2 * t.near) / (d - u)),
        (wu.elements[8] = (d + u) / (d - u)),
        this.cameraL.projectionMatrix.copy(wu),
        (u = -a * t.aspect - o),
        (d = a * t.aspect - o),
        (wu.elements[0] = (2 * t.near) / (d - u)),
        (wu.elements[8] = (d + u) / (d - u)),
        this.cameraR.projectionMatrix.copy(wu);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(hA),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(dA);
  }
}
class cE extends gi {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e), (this.index = 0);
  }
}
class f_ {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = pA()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = pA();
      (e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
    }
    return e;
  }
}
function pA() {
  return performance.now();
}
const Cu = new J(),
  mA = new ji(),
  dT = new J(),
  Tu = new J();
class hT extends wn {
  constructor() {
    super(),
      (this.type = 'AudioListener'),
      (this.context = c_.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new f_());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      n = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Cu, mA, dT),
      Tu.set(0, 0, -1).applyQuaternion(mA),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Cu.x, i),
        t.positionY.linearRampToValueAtTime(Cu.y, i),
        t.positionZ.linearRampToValueAtTime(Cu.z, i),
        t.forwardX.linearRampToValueAtTime(Tu.x, i),
        t.forwardY.linearRampToValueAtTime(Tu.y, i),
        t.forwardZ.linearRampToValueAtTime(Tu.z, i),
        t.upX.linearRampToValueAtTime(n.x, i),
        t.upY.linearRampToValueAtTime(n.y, i),
        t.upZ.linearRampToValueAtTime(n.z, i);
    } else t.setPosition(Cu.x, Cu.y, Cu.z), t.setOrientation(Tu.x, Tu.y, Tu.z, n.x, n.y, n.z);
  }
}
class fE extends wn {
  constructor(e) {
    super(),
      (this.type = 'Audio'),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = 'empty'),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'audioNode'),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaNode'),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaStreamNode'),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (this.buffer = e), (this.sourceType = 'buffer'), this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
        this.loop === !0 &&
          (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    return (this.loop = e), this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== 'buffer'
        ? (console.warn('THREE.Audio: Audio source type cannot be copied.'), this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const Ru = new J(),
  gA = new ji(),
  pT = new J(),
  bu = new J();
class mT extends fE {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = 'HRTF'),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, n) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(e) {
    if ((super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1))
      return;
    this.matrixWorld.decompose(Ru, gA, pT), bu.set(0, 0, 1).applyQuaternion(gA);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ru.x, n),
        t.positionY.linearRampToValueAtTime(Ru.y, n),
        t.positionZ.linearRampToValueAtTime(Ru.z, n),
        t.orientationX.linearRampToValueAtTime(bu.x, n),
        t.orientationY.linearRampToValueAtTime(bu.y, n),
        t.orientationZ.linearRampToValueAtTime(bu.z, n);
    } else t.setPosition(Ru.x, Ru.y, Ru.z), t.setOrientation(bu.x, bu.y, bu.z);
  }
}
class gT {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
}
class dE {
  constructor(e, t, n) {
    (this.binding = e), (this.valueSize = n);
    let i, o, a;
    switch (t) {
      case 'quaternion':
        (i = this._slerp),
          (o = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case 'string':
      case 'bool':
        (i = this._select),
          (o = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const n = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let u = 0; u !== i; ++u) n[o + u] = n[u];
      a = t;
    } else {
      a += t;
      const u = t / a;
      this._mixBufferRegion(n, o, 0, u, i);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, n),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      i = e * t + t,
      o = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      u = this.binding;
    if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)) {
      const d = t * this._origIndex;
      this._mixBufferRegion(n, i, d, 1 - o, t);
    }
    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let d = t, h = t + t; d !== h; ++d)
      if (n[d] !== n[d + t]) {
        u.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    e.getValue(t, i);
    for (let o = n, a = i; o !== a; ++o) t[o] = t[i + (o % n)];
    this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, i, o) {
    if (i >= 0.5) for (let a = 0; a !== o; ++a) e[t + a] = e[n + a];
  }
  _slerp(e, t, n, i) {
    ji.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, o) {
    const a = this._workIndex * o;
    ji.multiplyQuaternionsFlat(e, a, e, t, e, n), ji.slerpFlat(e, t, e, t, e, a, i);
  }
  _lerp(e, t, n, i, o) {
    const a = 1 - i;
    for (let u = 0; u !== o; ++u) {
      const d = t + u;
      e[d] = e[d] * a + e[n + u] * i;
    }
  }
  _lerpAdditive(e, t, n, i, o) {
    for (let a = 0; a !== o; ++a) {
      const u = t + a;
      e[u] = e[u] + e[n + a] * i;
    }
  }
}
const d_ = '\\[\\]\\.:\\/',
  vT = new RegExp('[' + d_ + ']', 'g'),
  h_ = '[^' + d_ + ']',
  yT = '[^' + d_.replace('\\.', '') + ']',
  _T = /((?:WC+[\/:])*)/.source.replace('WC', h_),
  xT = /(WCOD+)?/.source.replace('WCOD', yT),
  AT = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', h_),
  ST = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', h_),
  MT = new RegExp('^' + _T + xT + AT + ST + '$'),
  ET = ['material', 'materials', 'bones', 'map'];
class wT {
  constructor(e, t, n) {
    const i = n || Rn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = n.length; i !== o; ++i) n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
  }
}
class Rn {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || Rn.parseTrackName(t)),
      (this.node = Rn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Rn.Composite(e, t, n) : new Rn(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, '_').replace(vT, '');
  }
  static parseTrackName(e) {
    const t = MT.exec(e);
    if (t === null) throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf('.');
    if (i !== void 0 && i !== -1) {
      const o = n.nodeName.substring(i + 1);
      ET.indexOf(o) !== -1 && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = o));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === '' || t === '.' || t === -1 || t === e.name || t === e.uuid) return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (o) {
          for (let a = 0; a < o.length; a++) {
            const u = o[a];
            if (u.name === t || u.uuid === t) return u;
            const d = n(u.children);
            if (d) return d;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, o = n.length; i !== o; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e || ((e = Rn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
      return;
    }
    if (n) {
      let h = t.objectIndex;
      switch (n) {
        case 'materials':
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this,
            );
            return;
          }
          e = e.material.materials;
          break;
        case 'bones':
          if (!e.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this,
            );
            return;
          }
          e = e.skeleton.bones;
          for (let m = 0; m < e.length; m++)
            if (e[m].name === h) {
              h = m;
              break;
            }
          break;
        case 'map':
          if ('map' in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this,
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this,
            );
            return;
          }
          e = e[n];
      }
      if (h !== void 0) {
        if (e[h] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            e,
          );
          return;
        }
        e = e[h];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const h = t.nodeName;
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          h +
          '.' +
          i +
          " but it wasn't found.",
        e,
      );
      return;
    }
    let u = this.Versioning.None;
    (this.targetObject = e),
      e.isMaterial === !0
        ? (u = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let d = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === 'morphTargetInfluences') {
        if (!e.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this,
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this,
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      (d = this.BindingType.ArrayElement), (this.resolvedProperty = a), (this.propertyIndex = o);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((d = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((d = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[d]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[d][u]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Rn.Composite = wT;
Rn.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
Rn.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
Rn.prototype.GetterByBindingType = [
  Rn.prototype._getValue_direct,
  Rn.prototype._getValue_array,
  Rn.prototype._getValue_arrayElement,
  Rn.prototype._getValue_toArray,
];
Rn.prototype.SetterByBindingTypeAndVersioning = [
  [
    Rn.prototype._setValue_direct,
    Rn.prototype._setValue_direct_setNeedsUpdate,
    Rn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_array,
    Rn.prototype._setValue_array_setNeedsUpdate,
    Rn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_arrayElement,
    Rn.prototype._setValue_arrayElement_setNeedsUpdate,
    Rn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Rn.prototype._setValue_fromArray,
    Rn.prototype._setValue_fromArray_setNeedsUpdate,
    Rn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class CT {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = vs()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n) e[arguments[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      a = o.length;
    let u,
      d = e.length,
      h = this.nCachedObjects_;
    for (let m = 0, g = arguments.length; m !== g; ++m) {
      const v = arguments[m],
        x = v.uuid;
      let A = t[x];
      if (A === void 0) {
        (A = d++), (t[x] = A), e.push(v);
        for (let C = 0, E = a; C !== E; ++C) o[C].push(new Rn(v, n[C], i[C]));
      } else if (A < h) {
        u = e[A];
        const C = --h,
          E = e[C];
        (t[E.uuid] = A), (e[A] = E), (t[x] = C), (e[C] = v);
        for (let S = 0, b = a; S !== b; ++S) {
          const I = o[S],
            B = I[C];
          let z = I[A];
          (I[A] = B), z === void 0 && (z = new Rn(v, n[S], i[S])), (I[C] = z);
        }
      } else
        e[A] !== u &&
          console.error(
            'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
          );
    }
    this.nCachedObjects_ = h;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let o = this.nCachedObjects_;
    for (let a = 0, u = arguments.length; a !== u; ++a) {
      const d = arguments[a],
        h = d.uuid,
        m = t[h];
      if (m !== void 0 && m >= o) {
        const g = o++,
          v = e[g];
        (t[v.uuid] = m), (e[m] = v), (t[h] = g), (e[g] = d);
        for (let x = 0, A = i; x !== A; ++x) {
          const C = n[x],
            E = C[g],
            S = C[m];
          (C[m] = E), (C[g] = S);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let o = this.nCachedObjects_,
      a = e.length;
    for (let u = 0, d = arguments.length; u !== d; ++u) {
      const h = arguments[u],
        m = h.uuid,
        g = t[m];
      if (g !== void 0)
        if ((delete t[m], g < o)) {
          const v = --o,
            x = e[v],
            A = --a,
            C = e[A];
          (t[x.uuid] = g), (e[g] = x), (t[C.uuid] = v), (e[v] = C), e.pop();
          for (let E = 0, S = i; E !== S; ++E) {
            const b = n[E],
              I = b[v],
              B = b[A];
            (b[g] = I), (b[v] = B), b.pop();
          }
        } else {
          const v = --a,
            x = e[v];
          v > 0 && (t[x.uuid] = g), (e[g] = x), e.pop();
          for (let A = 0, C = i; A !== C; ++A) {
            const E = n[A];
            (E[g] = E[v]), E.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const a = this._paths,
      u = this._parsedPaths,
      d = this._objects,
      h = d.length,
      m = this.nCachedObjects_,
      g = new Array(h);
    (i = o.length), (n[e] = i), a.push(e), u.push(t), o.push(g);
    for (let v = m, x = d.length; v !== x; ++v) {
      const A = d[v];
      g[v] = new Rn(A, e, t);
    }
    return g;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      n = t[e];
    if (n !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        a = this._bindings,
        u = a.length - 1,
        d = a[u],
        h = e[u];
      (t[h] = n), (a[n] = d), a.pop(), (o[n] = o[u]), o.pop(), (i[n] = i[u]), i.pop();
    }
  }
}
class hE {
  constructor(e, t, n = null, i = t.blendMode) {
    (this._mixer = e), (this._clip = t), (this._localRoot = n), (this.blendMode = i);
    const o = t.tracks,
      a = o.length,
      u = new Array(a),
      d = { endingStart: ku, endingEnd: ku };
    for (let h = 0; h !== a; ++h) {
      const m = o[h].createInterpolant(null);
      (u[h] = m), (m.settings = d);
    }
    (this._interpolantSettings = d),
      (this._interpolants = u),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = sM),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if ((e.fadeOut(t), this.fadeIn(t), n)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        a = o / i,
        u = i / o;
      e.warp(1, a, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e), (this._effectiveTimeScale = this.paused ? 0 : e), this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer,
      o = i.time,
      a = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null && ((u = i._lendControlInterpolant()), (this._timeScaleInterpolant = u));
    const d = u.parameterPositions,
      h = u.sampleValues;
    return (d[0] = o), (d[1] = o + n), (h[0] = e / a), (h[1] = t / a), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const d = (e - o) * n;
      d < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * d));
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t),
      u = this._updateWeight(e);
    if (u > 0) {
      const d = this._interpolants,
        h = this._propertyBindings;
      switch (this.blendMode) {
        case Fy:
          for (let m = 0, g = d.length; m !== g; ++m) d[m].evaluate(a), h[m].accumulateAdditive(u);
          break;
        case Xg:
        default:
          for (let m = 0, g = d.length; m !== g; ++m) d[m].evaluate(a), h[m].accumulate(i, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopWarping(), t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const a = n === oM;
    if (e === 0) return o === -1 ? i : a && (o & 1) === 1 ? t - i : i;
    if (n === rM) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({ type: 'finished', action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        i >= t || i < 0)
      ) {
        const u = Math.floor(i / t);
        (i -= t * u), (o += Math.abs(u));
        const d = this.repetitions - o;
        if (d <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (d === 1) {
            const h = e < 0;
            this._setEndings(h, !h, a);
          } else this._setEndings(!1, !1, a);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: u });
        }
      } else this.time = i;
      if (a && (o & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = zu), (i.endingEnd = zu))
      : (e ? (i.endingStart = this.zeroSlopeAtStart ? zu : ku) : (i.endingStart = Ah),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? zu : ku) : (i.endingEnd = Ah));
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer,
      o = i.time;
    let a = this._weightInterpolant;
    a === null && ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
    const u = a.parameterPositions,
      d = a.sampleValues;
    return (u[0] = o), (d[0] = t), (u[1] = o + e), (d[1] = n), this;
  }
}
const TT = new Float32Array(1);
class RT extends Ho {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      a = e._propertyBindings,
      u = e._interpolants,
      d = n.uuid,
      h = this._bindingsByRootAndName;
    let m = h[d];
    m === void 0 && ((m = {}), (h[d] = m));
    for (let g = 0; g !== o; ++g) {
      const v = i[g],
        x = v.name;
      let A = m[x];
      if (A !== void 0) ++A.referenceCount, (a[g] = A);
      else {
        if (((A = a[g]), A !== void 0)) {
          A._cacheIndex === null && (++A.referenceCount, this._addInactiveBinding(A, d, x));
          continue;
        }
        const C = t && t._propertyBindings[g].binding.parsedPath;
        (A = new dE(Rn.create(n, x, C), v.ValueTypeName, v.getValueSize())),
          ++A.referenceCount,
          this._addInactiveBinding(A, d, x),
          (a[g] = A);
      }
      u[g].resultBuffer = A.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const o = t[n];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions,
      o = this._actionsByClip;
    let a = o[t];
    if (a === void 0)
      (a = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (o[t] = a);
    else {
      const u = a.knownActions;
      (e._byClipCacheIndex = u.length), u.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (a.actionByRoot[n] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      i = e._cacheIndex;
    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      a = this._actionsByClip,
      u = a[o],
      d = u.knownActions,
      h = d[d.length - 1],
      m = e._byClipCacheIndex;
    (h._byClipCacheIndex = m), (d[m] = h), d.pop(), (e._byClipCacheIndex = null);
    const g = u.actionByRoot,
      v = (e._localRoot || this._root).uuid;
    delete g[v], d.length === 0 && delete a[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const o = t[n];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = this._nActiveActions++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = n), (t[n] = o);
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = --this._nActiveActions,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = n), (t[n] = o);
  }
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let a = i[t];
    a === void 0 && ((a = {}), (i[t] = a)), (a[n] = e), (e._cacheIndex = o.length), o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      i = n.rootNode.uuid,
      o = n.path,
      a = this._bindingsByRootAndName,
      u = a[i],
      d = t[t.length - 1],
      h = e._cacheIndex;
    (d._cacheIndex = h),
      (t[h] = d),
      t.pop(),
      delete u[o],
      Object.keys(u).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = this._nActiveBindings++,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = n), (t[n] = o);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = --this._nActiveBindings,
      o = t[i];
    (e._cacheIndex = i), (t[i] = e), (o._cacheIndex = n), (t[n] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new i_(new Float32Array(2), new Float32Array(2), 1, TT)),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = t[i];
    (e.__cacheIndex = i), (t[i] = e), (o.__cacheIndex = n), (t[n] = o);
  }
  clipAction(e, t, n) {
    const i = t || this._root,
      o = i.uuid;
    let a = typeof e == 'string' ? Vf.findByName(i, e) : e;
    const u = a !== null ? a.uuid : e,
      d = this._actionsByClip[u];
    let h = null;
    if ((n === void 0 && (a !== null ? (n = a.blendMode) : (n = Xg)), d !== void 0)) {
      const g = d.actionByRoot[o];
      if (g !== void 0 && g.blendMode === n) return g;
      (h = d.knownActions[0]), a === null && (a = h._clip);
    }
    if (a === null) return null;
    const m = new hE(this, a, t, n);
    return this._bindAction(m, h), this._addInactiveAction(m, u, o), m;
  }
  existingAction(e, t) {
    const n = t || this._root,
      i = n.uuid,
      o = typeof e == 'string' ? Vf.findByName(n, e) : e,
      a = o ? o.uuid : e,
      u = this._actionsByClip[a];
    return (u !== void 0 && u.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let h = 0; h !== n; ++h) t[h]._update(i, e, o, a);
    const u = this._bindings,
      d = this._nActiveBindings;
    for (let h = 0; h !== d; ++h) u[h].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      i = this._actionsByClip,
      o = i[n];
    if (o !== void 0) {
      const a = o.knownActions;
      for (let u = 0, d = a.length; u !== d; ++u) {
        const h = a[u];
        this._deactivateAction(h);
        const m = h._cacheIndex,
          g = t[t.length - 1];
        (h._cacheIndex = null),
          (h._byClipCacheIndex = null),
          (g._cacheIndex = m),
          (t[m] = g),
          t.pop(),
          this._removeInactiveBindingsForAction(h);
      }
      delete i[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const a in n) {
      const u = n[a].actionByRoot,
        d = u[t];
      d !== void 0 && (this._deactivateAction(d), this._removeInactiveAction(d));
    }
    const i = this._bindingsByRootAndName,
      o = i[t];
    if (o !== void 0)
      for (const a in o) {
        const u = o[a];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class bT extends Jg {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isRenderTarget3D = !0),
      (this.depth = n),
      (this.texture = new Yg(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class IT extends Jg {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i),
      (this.isRenderTargetArray = !0),
      (this.depth = n),
      (this.texture = new Oh(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class p_ {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new p_(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let BT = 0;
class PT extends Ho {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, 'id', { value: BT++ }),
      (this.name = ''),
      (this.usage = Mh),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: 'dispose' }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const o = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let a = 0; a < o.length; a++) this.uniforms.push(o[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class DT extends Gh {
  constructor(e, t, n = 1) {
    super(e, t), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.isInstancedInterleavedBuffer = !0), (t.meshPerAttribute = this.meshPerAttribute), t;
  }
}
class LT {
  constructor(e, t, n, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ''),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const vA = new Qt();
class m_ {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new sc(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new ju()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error('THREE.Raycaster: Unsupported camera type: ' + t.type);
  }
  setFromXRController(e) {
    return (
      vA.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(vA),
      this
    );
  }
  intersectObject(e, t = !0, n = []) {
    return gy(e, this, n, t), n.sort(yA), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, o = e.length; i < o; i++) gy(e[i], this, n, t);
    return n.sort(yA), n;
  }
}
function yA(r, e) {
  return r.distance - e.distance;
}
function gy(r, e, t, n) {
  let i = !0;
  if ((r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0)) {
    const o = r.children;
    for (let a = 0, u = o.length; a < u; a++) gy(o[a], e, t, !0);
  }
}
class vy {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this;
  }
  makeSafe() {
    return (this.phi = un(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)), (this.phi = Math.acos(un(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class FT {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  copy(e) {
    return (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + n * n)), (this.theta = Math.atan2(e, n)), (this.y = t), this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class g_ {
  constructor(e, t, n, i) {
    (g_.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
    return this;
  }
  set(e, t, n, i) {
    const o = this.elements;
    return (o[0] = e), (o[2] = t), (o[1] = n), (o[3] = i), this;
  }
}
const _A = new Ge();
class NT {
  constructor(e = new Ge(1 / 0, 1 / 0), t = new Ge(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = _A.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _A).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const xA = new J(),
  bm = new J();
class UT {
  constructor(e = new J(), t = new J()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    xA.subVectors(e, this.start), bm.subVectors(this.end, this.start);
    const n = bm.dot(bm);
    let o = bm.dot(xA) / n;
    return t && (o = un(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const AA = new J();
class OT extends wn {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = 'SpotLightHelper');
    const n = new hn(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, u = 1, d = 32; a < d; a++, u++) {
      const h = (a / d) * Math.PI * 2,
        m = (u / d) * Math.PI * 2;
      i.push(Math.cos(h), Math.sin(h), 1, Math.cos(m), Math.sin(m), 1);
    }
    n.setAttribute('position', new kt(i, 3));
    const o = new Sr({ fog: !1, toneMapped: !1 });
    (this.cone = new mo(n, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      AA.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(AA),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const yl = new J(),
  Im = new Qt(),
  b0 = new Qt();
class kT extends mo {
  constructor(e) {
    const t = pE(e),
      n = new hn(),
      i = [],
      o = [],
      a = new At(0, 0, 1),
      u = new At(0, 1, 0);
    for (let h = 0; h < t.length; h++) {
      const m = t[h];
      m.parent &&
        m.parent.isBone &&
        (i.push(0, 0, 0), i.push(0, 0, 0), o.push(a.r, a.g, a.b), o.push(u.r, u.g, u.b));
    }
    n.setAttribute('position', new kt(i, 3)), n.setAttribute('color', new kt(o, 3));
    const d = new Sr({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, d),
      (this.isSkeletonHelper = !0),
      (this.type = 'SkeletonHelper'),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      i = n.getAttribute('position');
    b0.copy(this.root.matrixWorld).invert();
    for (let o = 0, a = 0; o < t.length; o++) {
      const u = t[o];
      u.parent &&
        u.parent.isBone &&
        (Im.multiplyMatrices(b0, u.matrixWorld),
        yl.setFromMatrixPosition(Im),
        i.setXYZ(a, yl.x, yl.y, yl.z),
        Im.multiplyMatrices(b0, u.parent.matrixWorld),
        yl.setFromMatrixPosition(Im),
        i.setXYZ(a + 1, yl.x, yl.y, yl.z),
        (a += 2));
    }
    (n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function pE(r) {
  const e = [];
  r.isBone === !0 && e.push(r);
  for (let t = 0; t < r.children.length; t++) e.push.apply(e, pE(r.children[t]));
  return e;
}
class zT extends oi {
  constructor(e, t, n) {
    const i = new Kh(t, 4, 2),
      o = new ts({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = n),
      (this.type = 'PointLightHelper'),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const HT = new J(),
  SA = new At(),
  MA = new At();
class GT extends wn {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = 'HemisphereLightHelper');
    const i = new Yh(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new ts({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute('position'),
      a = new Float32Array(o.count * 3);
    i.setAttribute('color', new Pn(a, 3)), this.add(new oi(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute('color');
      SA.copy(this.light.color), MA.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const o = n < i / 2 ? SA : MA;
        t.setXYZ(n, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(HT.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class VT extends mo {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    (n = new At(n)), (i = new At(i));
    const o = t / 2,
      a = e / t,
      u = e / 2,
      d = [],
      h = [];
    for (let v = 0, x = 0, A = -u; v <= t; v++, A += a) {
      d.push(-u, 0, A, u, 0, A), d.push(A, 0, -u, A, 0, u);
      const C = v === o ? n : i;
      C.toArray(h, x),
        (x += 3),
        C.toArray(h, x),
        (x += 3),
        C.toArray(h, x),
        (x += 3),
        C.toArray(h, x),
        (x += 3);
    }
    const m = new hn();
    m.setAttribute('position', new kt(d, 3)), m.setAttribute('color', new kt(h, 3));
    const g = new Sr({ vertexColors: !0, toneMapped: !1 });
    super(m, g), (this.type = 'GridHelper');
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class WT extends mo {
  constructor(e = 10, t = 16, n = 8, i = 64, o = 4473924, a = 8947848) {
    (o = new At(o)), (a = new At(a));
    const u = [],
      d = [];
    if (t > 1)
      for (let g = 0; g < t; g++) {
        const v = (g / t) * (Math.PI * 2),
          x = Math.sin(v) * e,
          A = Math.cos(v) * e;
        u.push(0, 0, 0), u.push(x, 0, A);
        const C = g & 1 ? o : a;
        d.push(C.r, C.g, C.b), d.push(C.r, C.g, C.b);
      }
    for (let g = 0; g < n; g++) {
      const v = g & 1 ? o : a,
        x = e - (e / n) * g;
      for (let A = 0; A < i; A++) {
        let C = (A / i) * (Math.PI * 2),
          E = Math.sin(C) * x,
          S = Math.cos(C) * x;
        u.push(E, 0, S),
          d.push(v.r, v.g, v.b),
          (C = ((A + 1) / i) * (Math.PI * 2)),
          (E = Math.sin(C) * x),
          (S = Math.cos(C) * x),
          u.push(E, 0, S),
          d.push(v.r, v.g, v.b);
      }
    }
    const h = new hn();
    h.setAttribute('position', new kt(u, 3)), h.setAttribute('color', new kt(d, 3));
    const m = new Sr({ vertexColors: !0, toneMapped: !1 });
    super(h, m), (this.type = 'PolarGridHelper');
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const EA = new J(),
  Bm = new J(),
  wA = new J();
class XT extends wn {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = 'DirectionalLightHelper'),
      t === void 0 && (t = 1);
    let i = new hn();
    i.setAttribute('position', new kt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
    const o = new Sr({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Fa(i, o)),
      this.add(this.lightPlane),
      (i = new hn()),
      i.setAttribute('position', new kt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Fa(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      EA.setFromMatrixPosition(this.light.matrixWorld),
      Bm.setFromMatrixPosition(this.light.target.matrixWorld),
      wA.subVectors(Bm, EA),
      this.lightPlane.lookAt(Bm),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Bm),
      (this.targetLine.scale.z = wA.length());
  }
}
const Pm = new J(),
  mi = new kh();
class JT extends mo {
  constructor(e) {
    const t = new hn(),
      n = new Sr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      a = {};
    u('n1', 'n2'),
      u('n2', 'n4'),
      u('n4', 'n3'),
      u('n3', 'n1'),
      u('f1', 'f2'),
      u('f2', 'f4'),
      u('f4', 'f3'),
      u('f3', 'f1'),
      u('n1', 'f1'),
      u('n2', 'f2'),
      u('n3', 'f3'),
      u('n4', 'f4'),
      u('p', 'n1'),
      u('p', 'n2'),
      u('p', 'n3'),
      u('p', 'n4'),
      u('u1', 'u2'),
      u('u2', 'u3'),
      u('u3', 'u1'),
      u('c', 't'),
      u('p', 'c'),
      u('cn1', 'cn2'),
      u('cn3', 'cn4'),
      u('cf1', 'cf2'),
      u('cf3', 'cf4');
    function u(A, C) {
      d(A), d(C);
    }
    function d(A) {
      i.push(0, 0, 0), o.push(0, 0, 0), a[A] === void 0 && (a[A] = []), a[A].push(i.length / 3 - 1);
    }
    t.setAttribute('position', new kt(i, 3)),
      t.setAttribute('color', new kt(o, 3)),
      super(t, n),
      (this.type = 'CameraHelper'),
      (this.camera = e),
      this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const h = new At(16755200),
      m = new At(16711680),
      g = new At(43775),
      v = new At(16777215),
      x = new At(3355443);
    this.setColors(h, m, g, v, x);
  }
  setColors(e, t, n, i, o) {
    const u = this.geometry.getAttribute('color');
    u.setXYZ(0, e.r, e.g, e.b),
      u.setXYZ(1, e.r, e.g, e.b),
      u.setXYZ(2, e.r, e.g, e.b),
      u.setXYZ(3, e.r, e.g, e.b),
      u.setXYZ(4, e.r, e.g, e.b),
      u.setXYZ(5, e.r, e.g, e.b),
      u.setXYZ(6, e.r, e.g, e.b),
      u.setXYZ(7, e.r, e.g, e.b),
      u.setXYZ(8, e.r, e.g, e.b),
      u.setXYZ(9, e.r, e.g, e.b),
      u.setXYZ(10, e.r, e.g, e.b),
      u.setXYZ(11, e.r, e.g, e.b),
      u.setXYZ(12, e.r, e.g, e.b),
      u.setXYZ(13, e.r, e.g, e.b),
      u.setXYZ(14, e.r, e.g, e.b),
      u.setXYZ(15, e.r, e.g, e.b),
      u.setXYZ(16, e.r, e.g, e.b),
      u.setXYZ(17, e.r, e.g, e.b),
      u.setXYZ(18, e.r, e.g, e.b),
      u.setXYZ(19, e.r, e.g, e.b),
      u.setXYZ(20, e.r, e.g, e.b),
      u.setXYZ(21, e.r, e.g, e.b),
      u.setXYZ(22, e.r, e.g, e.b),
      u.setXYZ(23, e.r, e.g, e.b),
      u.setXYZ(24, t.r, t.g, t.b),
      u.setXYZ(25, t.r, t.g, t.b),
      u.setXYZ(26, t.r, t.g, t.b),
      u.setXYZ(27, t.r, t.g, t.b),
      u.setXYZ(28, t.r, t.g, t.b),
      u.setXYZ(29, t.r, t.g, t.b),
      u.setXYZ(30, t.r, t.g, t.b),
      u.setXYZ(31, t.r, t.g, t.b),
      u.setXYZ(32, n.r, n.g, n.b),
      u.setXYZ(33, n.r, n.g, n.b),
      u.setXYZ(34, n.r, n.g, n.b),
      u.setXYZ(35, n.r, n.g, n.b),
      u.setXYZ(36, n.r, n.g, n.b),
      u.setXYZ(37, n.r, n.g, n.b),
      u.setXYZ(38, i.r, i.g, i.b),
      u.setXYZ(39, i.r, i.g, i.b),
      u.setXYZ(40, o.r, o.g, o.b),
      u.setXYZ(41, o.r, o.g, o.b),
      u.setXYZ(42, o.r, o.g, o.b),
      u.setXYZ(43, o.r, o.g, o.b),
      u.setXYZ(44, o.r, o.g, o.b),
      u.setXYZ(45, o.r, o.g, o.b),
      u.setXYZ(46, o.r, o.g, o.b),
      u.setXYZ(47, o.r, o.g, o.b),
      u.setXYZ(48, o.r, o.g, o.b),
      u.setXYZ(49, o.r, o.g, o.b),
      (u.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      i = 1;
    mi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const o = this.camera.coordinateSystem === ho ? -1 : 0;
    xi('c', t, e, mi, 0, 0, o),
      xi('t', t, e, mi, 0, 0, 1),
      xi('n1', t, e, mi, -1, -1, o),
      xi('n2', t, e, mi, n, -1, o),
      xi('n3', t, e, mi, -1, i, o),
      xi('n4', t, e, mi, n, i, o),
      xi('f1', t, e, mi, -1, -1, 1),
      xi('f2', t, e, mi, n, -1, 1),
      xi('f3', t, e, mi, -1, i, 1),
      xi('f4', t, e, mi, n, i, 1),
      xi('u1', t, e, mi, n * 0.7, i * 1.1, o),
      xi('u2', t, e, mi, -1 * 0.7, i * 1.1, o),
      xi('u3', t, e, mi, 0, i * 2, o),
      xi('cf1', t, e, mi, -1, 0, 1),
      xi('cf2', t, e, mi, n, 0, 1),
      xi('cf3', t, e, mi, 0, -1, 1),
      xi('cf4', t, e, mi, 0, i, 1),
      xi('cn1', t, e, mi, -1, 0, o),
      xi('cn2', t, e, mi, n, 0, o),
      xi('cn3', t, e, mi, 0, -1, o),
      xi('cn4', t, e, mi, 0, i, o),
      (e.getAttribute('position').needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function xi(r, e, t, n, i, o, a) {
  Pm.set(i, o, a).unproject(n);
  const u = e[r];
  if (u !== void 0) {
    const d = t.getAttribute('position');
    for (let h = 0, m = u.length; h < m; h++) d.setXYZ(u[h], Pm.x, Pm.y, Pm.z);
  }
}
const Dm = new Ar();
class YT extends mo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new hn();
    o.setIndex(new Pn(n, 1)),
      o.setAttribute('position', new Pn(i, 3)),
      super(o, new Sr({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = 'BoxHelper'),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
      this.object !== void 0 && Dm.setFromObject(this.object),
      Dm.isEmpty())
    )
      return;
    const t = Dm.min,
      n = Dm.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = n.x),
      (o[1] = n.y),
      (o[2] = n.z),
      (o[3] = t.x),
      (o[4] = n.y),
      (o[5] = n.z),
      (o[6] = t.x),
      (o[7] = t.y),
      (o[8] = n.z),
      (o[9] = n.x),
      (o[10] = t.y),
      (o[11] = n.z),
      (o[12] = n.x),
      (o[13] = n.y),
      (o[14] = t.z),
      (o[15] = t.x),
      (o[16] = n.y),
      (o[17] = t.z),
      (o[18] = t.x),
      (o[19] = t.y),
      (o[20] = t.z),
      (o[21] = n.x),
      (o[22] = t.y),
      (o[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class KT extends mo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
      o = new hn();
    o.setIndex(new Pn(n, 1)),
      o.setAttribute('position', new kt(i, 3)),
      super(o, new Sr({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = 'Box3Helper'),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class jT extends Fa {
  constructor(e, t = 1, n = 16776960) {
    const i = n,
      o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
      a = new hn();
    a.setAttribute('position', new kt(o, 3)),
      a.computeBoundingSphere(),
      super(a, new Sr({ color: i, toneMapped: !1 })),
      (this.type = 'PlaneHelper'),
      (this.plane = e),
      (this.size = t);
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      d = new hn();
    d.setAttribute('position', new kt(u, 3)),
      d.computeBoundingSphere(),
      this.add(
        new oi(
          d,
          new ts({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 }),
        ),
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const CA = new J();
let Lm, I0;
class ZT extends wn {
  constructor(
    e = new J(0, 0, 1),
    t = new J(0, 0, 0),
    n = 1,
    i = 16776960,
    o = n * 0.2,
    a = o * 0.2,
  ) {
    super(),
      (this.type = 'ArrowHelper'),
      Lm === void 0 &&
        ((Lm = new hn()),
        Lm.setAttribute('position', new kt([0, 0, 0, 0, 1, 0], 3)),
        (I0 = new Jf(0, 0.5, 1, 5, 1)),
        I0.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Fa(Lm, new Sr({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new oi(I0, new ts({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(n, o, a);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      CA.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(CA, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, t, n),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class QT extends mo {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new hn();
    i.setAttribute('position', new kt(t, 3)), i.setAttribute('color', new kt(n, 3));
    const o = new Sr({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = 'AxesHelper');
  }
  setColors(e, t, n) {
    const i = new At(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(t),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(n),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class qT {
  constructor() {
    (this.type = 'ShapePath'),
      (this.color = new At()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Ch()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, o, a) {
    return this.currentPath.bezierCurveTo(e, t, n, i, o, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(S) {
      const b = [];
      for (let I = 0, B = S.length; I < B; I++) {
        const z = S[I],
          N = new Zu();
        (N.curves = z.curves), b.push(N);
      }
      return b;
    }
    function n(S, b) {
      const I = b.length;
      let B = !1;
      for (let z = I - 1, N = 0; N < I; z = N++) {
        let G = b[z],
          k = b[N],
          L = k.x - G.x,
          D = k.y - G.y;
        if (Math.abs(D) > Number.EPSILON) {
          if ((D < 0 && ((G = b[N]), (L = -L), (k = b[z]), (D = -D)), S.y < G.y || S.y > k.y))
            continue;
          if (S.y === G.y) {
            if (S.x === G.x) return !0;
          } else {
            const V = D * (S.x - G.x) - L * (S.y - G.y);
            if (V === 0) return !0;
            if (V < 0) continue;
            B = !B;
          }
        } else {
          if (S.y !== G.y) continue;
          if ((k.x <= S.x && S.x <= G.x) || (G.x <= S.x && S.x <= k.x)) return !0;
        }
      }
      return B;
    }
    const i = Fo.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let a, u, d;
    const h = [];
    if (o.length === 1) return (u = o[0]), (d = new Zu()), (d.curves = u.curves), h.push(d), h;
    let m = !i(o[0].getPoints());
    m = e ? !m : m;
    const g = [],
      v = [];
    let x = [],
      A = 0,
      C;
    (v[A] = void 0), (x[A] = []);
    for (let S = 0, b = o.length; S < b; S++)
      (u = o[S]),
        (C = u.getPoints()),
        (a = i(C)),
        (a = e ? !a : a),
        a
          ? (!m && v[A] && A++,
            (v[A] = { s: new Zu(), p: C }),
            (v[A].s.curves = u.curves),
            m && A++,
            (x[A] = []))
          : x[A].push({ h: u, p: C[0] });
    if (!v[0]) return t(o);
    if (v.length > 1) {
      let S = !1,
        b = 0;
      for (let I = 0, B = v.length; I < B; I++) g[I] = [];
      for (let I = 0, B = v.length; I < B; I++) {
        const z = x[I];
        for (let N = 0; N < z.length; N++) {
          const G = z[N];
          let k = !0;
          for (let L = 0; L < v.length; L++)
            n(G.p, v[L].p) && (I !== L && b++, k ? ((k = !1), g[L].push(G)) : (S = !0));
          k && g[I].push(G);
        }
      }
      b > 0 && S === !1 && (x = g);
    }
    let E;
    for (let S = 0, b = v.length; S < b; S++) {
      (d = v[S].s), h.push(d), (E = x[S]);
      for (let I = 0, B = E.length; I < B; I++) d.holes.push(E[I].h);
    }
    return h;
  }
}
class $T extends Ho {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect() {}
  disconnect() {}
  dispose() {}
  update() {}
}
function eR(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return (
    t > e
      ? ((r.repeat.x = 1),
        (r.repeat.y = t / e),
        (r.offset.x = 0),
        (r.offset.y = (1 - r.repeat.y) / 2))
      : ((r.repeat.x = e / t),
        (r.repeat.y = 1),
        (r.offset.x = (1 - r.repeat.x) / 2),
        (r.offset.y = 0)),
    r
  );
}
function tR(r, e) {
  const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
  return (
    t > e
      ? ((r.repeat.x = e / t),
        (r.repeat.y = 1),
        (r.offset.x = (1 - r.repeat.x) / 2),
        (r.offset.y = 0))
      : ((r.repeat.x = 1),
        (r.repeat.y = t / e),
        (r.offset.x = 0),
        (r.offset.y = (1 - r.repeat.y) / 2)),
    r
  );
}
function nR(r) {
  return (r.repeat.x = 1), (r.repeat.y = 1), (r.offset.x = 0), (r.offset.y = 0), r;
}
function yy(r, e, t, n) {
  const i = iR(n);
  switch (t) {
    case by:
      return r * e;
    case By:
      return r * e;
    case Py:
      return r * e * 2;
    case Nh:
      return ((r * e) / i.components) * i.byteLength;
    case Uh:
      return ((r * e) / i.components) * i.byteLength;
    case Dy:
      return ((r * e * 2) / i.components) * i.byteLength;
    case Vg:
      return ((r * e * 2) / i.components) * i.byteLength;
    case Iy:
      return ((r * e * 3) / i.components) * i.byteLength;
    case Si:
      return ((r * e * 4) / i.components) * i.byteLength;
    case Wg:
      return ((r * e * 4) / i.components) * i.byteLength;
    case fh:
    case dh:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hh:
    case ph:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case sg:
    case ag:
      return (Math.max(r, 16) * Math.max(e, 8)) / 4;
    case rg:
    case og:
      return (Math.max(r, 8) * Math.max(e, 8)) / 2;
    case lg:
    case ug:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case cg:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fg:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case dg:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case hg:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case pg:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case mg:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case gg:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case vg:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case yg:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case _g:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case xg:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Ag:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Sg:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Mg:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Eg:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case mh:
    case wg:
    case Cg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case Ly:
    case Tg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Rg:
    case bg:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function iR(r) {
  switch (r) {
    case ns:
    case kg:
      return { byteLength: 1, components: 1 };
    case Of:
    case zg:
    case Yi:
      return { byteLength: 2, components: 1 };
    case Hg:
    case Gg:
      return { byteLength: 2, components: 4 };
    case ko:
    case Fh:
    case fi:
      return { byteLength: 4, components: 1 };
    case Ry:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
const rR = { contain: eR, cover: tR, fill: nR, getByteLength: yy };
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: Dh } }));
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = Dh));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function mE() {
  let r = null,
    e = !1,
    t = null,
    n = null;
  function i(o, a) {
    t(o, a), (n = r.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = r.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      r = o;
    },
  };
}
function sR(r) {
  const e = new WeakMap();
  function t(u, d) {
    const h = u.array,
      m = u.usage,
      g = h.byteLength,
      v = r.createBuffer();
    r.bindBuffer(d, v), r.bufferData(d, h, m), u.onUploadCallback();
    let x;
    if (h instanceof Float32Array) x = r.FLOAT;
    else if (h instanceof Uint16Array)
      u.isFloat16BufferAttribute ? (x = r.HALF_FLOAT) : (x = r.UNSIGNED_SHORT);
    else if (h instanceof Int16Array) x = r.SHORT;
    else if (h instanceof Uint32Array) x = r.UNSIGNED_INT;
    else if (h instanceof Int32Array) x = r.INT;
    else if (h instanceof Int8Array) x = r.BYTE;
    else if (h instanceof Uint8Array) x = r.UNSIGNED_BYTE;
    else if (h instanceof Uint8ClampedArray) x = r.UNSIGNED_BYTE;
    else throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + h);
    return {
      buffer: v,
      type: x,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: u.version,
      size: g,
    };
  }
  function n(u, d, h) {
    const m = d.array,
      g = d.updateRanges;
    if ((r.bindBuffer(h, u), g.length === 0)) r.bufferSubData(h, 0, m);
    else {
      g.sort((x, A) => x.start - A.start);
      let v = 0;
      for (let x = 1; x < g.length; x++) {
        const A = g[v],
          C = g[x];
        C.start <= A.start + A.count + 1
          ? (A.count = Math.max(A.count, C.start + C.count - A.start))
          : (++v, (g[v] = C));
      }
      g.length = v + 1;
      for (let x = 0, A = g.length; x < A; x++) {
        const C = g[x];
        r.bufferSubData(h, C.start * m.BYTES_PER_ELEMENT, m, C.start, C.count);
      }
      d.clearUpdateRanges();
    }
    d.onUploadCallback();
  }
  function i(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), e.get(u);
  }
  function o(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const d = e.get(u);
    d && (r.deleteBuffer(d.buffer), e.delete(u));
  }
  function a(u, d) {
    if ((u.isInterleavedBufferAttribute && (u = u.data), u.isGLBufferAttribute)) {
      const m = e.get(u);
      (!m || m.version < u.version) &&
        e.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    const h = e.get(u);
    if (h === void 0) e.set(u, t(u, d));
    else if (h.version < u.version) {
      if (h.size !== u.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      n(h.buffer, u, d), (h.version = u.version);
    }
  }
  return { get: i, remove: o, update: a };
}
var oR = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  aR = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  lR = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  uR = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  cR = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  fR = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  dR = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  hR = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  pR = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  mR = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  gR = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  vR = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  yR = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  _R = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  xR = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  AR = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  SR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  MR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  ER = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  wR = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  CR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  TR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  RR = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  bR = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  IR = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  BR = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  PR = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  DR = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  LR = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  FR = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  NR = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  UR = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  OR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  kR = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  zR = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  HR = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  GR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  VR = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  WR = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  XR = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  JR = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  YR = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  KR = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  jR = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  ZR = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  QR = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  qR = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  $R = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  eb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  tb = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  nb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  ib = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  rb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  sb = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  ob = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  ab = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  lb = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  ub = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  cb = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  fb = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  db = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  hb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  pb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  mb = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  gb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  vb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  yb = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  _b = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  xb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Ab = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  Sb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Mb = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Eb = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  wb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Cb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Tb = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Rb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  bb = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  Ib = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  Bb = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  Pb = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  Db = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  Lb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Fb = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  Nb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  Ub = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Ob = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  kb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  zb = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  Hb = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  Gb = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  Vb = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  Wb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  Xb = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  Jb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  Yb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Kb = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  jb = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Zb = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  Qb = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  qb = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  $b = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  eI = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  tI = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  nI = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  iI = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  rI = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const sI = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  oI = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  aI = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  lI = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  uI = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  cI = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  fI = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  dI = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  hI = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  pI = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  mI = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  gI = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vI = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  yI = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  _I = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  xI = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  AI = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  SI = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  MI = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  EI = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  wI = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  CI = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  TI = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  RI = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  bI = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  II = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  BI = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  PI = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  DI = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  LI = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  FI = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  NI = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  UI = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  OI = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  yn = {
    alphahash_fragment: oR,
    alphahash_pars_fragment: aR,
    alphamap_fragment: lR,
    alphamap_pars_fragment: uR,
    alphatest_fragment: cR,
    alphatest_pars_fragment: fR,
    aomap_fragment: dR,
    aomap_pars_fragment: hR,
    batching_pars_vertex: pR,
    batching_vertex: mR,
    begin_vertex: gR,
    beginnormal_vertex: vR,
    bsdfs: yR,
    iridescence_fragment: _R,
    bumpmap_pars_fragment: xR,
    clipping_planes_fragment: AR,
    clipping_planes_pars_fragment: SR,
    clipping_planes_pars_vertex: MR,
    clipping_planes_vertex: ER,
    color_fragment: wR,
    color_pars_fragment: CR,
    color_pars_vertex: TR,
    color_vertex: RR,
    common: bR,
    cube_uv_reflection_fragment: IR,
    defaultnormal_vertex: BR,
    displacementmap_pars_vertex: PR,
    displacementmap_vertex: DR,
    emissivemap_fragment: LR,
    emissivemap_pars_fragment: FR,
    colorspace_fragment: NR,
    colorspace_pars_fragment: UR,
    envmap_fragment: OR,
    envmap_common_pars_fragment: kR,
    envmap_pars_fragment: zR,
    envmap_pars_vertex: HR,
    envmap_physical_pars_fragment: qR,
    envmap_vertex: GR,
    fog_vertex: VR,
    fog_pars_vertex: WR,
    fog_fragment: XR,
    fog_pars_fragment: JR,
    gradientmap_pars_fragment: YR,
    lightmap_pars_fragment: KR,
    lights_lambert_fragment: jR,
    lights_lambert_pars_fragment: ZR,
    lights_pars_begin: QR,
    lights_toon_fragment: $R,
    lights_toon_pars_fragment: eb,
    lights_phong_fragment: tb,
    lights_phong_pars_fragment: nb,
    lights_physical_fragment: ib,
    lights_physical_pars_fragment: rb,
    lights_fragment_begin: sb,
    lights_fragment_maps: ob,
    lights_fragment_end: ab,
    logdepthbuf_fragment: lb,
    logdepthbuf_pars_fragment: ub,
    logdepthbuf_pars_vertex: cb,
    logdepthbuf_vertex: fb,
    map_fragment: db,
    map_pars_fragment: hb,
    map_particle_fragment: pb,
    map_particle_pars_fragment: mb,
    metalnessmap_fragment: gb,
    metalnessmap_pars_fragment: vb,
    morphinstance_vertex: yb,
    morphcolor_vertex: _b,
    morphnormal_vertex: xb,
    morphtarget_pars_vertex: Ab,
    morphtarget_vertex: Sb,
    normal_fragment_begin: Mb,
    normal_fragment_maps: Eb,
    normal_pars_fragment: wb,
    normal_pars_vertex: Cb,
    normal_vertex: Tb,
    normalmap_pars_fragment: Rb,
    clearcoat_normal_fragment_begin: bb,
    clearcoat_normal_fragment_maps: Ib,
    clearcoat_pars_fragment: Bb,
    iridescence_pars_fragment: Pb,
    opaque_fragment: Db,
    packing: Lb,
    premultiplied_alpha_fragment: Fb,
    project_vertex: Nb,
    dithering_fragment: Ub,
    dithering_pars_fragment: Ob,
    roughnessmap_fragment: kb,
    roughnessmap_pars_fragment: zb,
    shadowmap_pars_fragment: Hb,
    shadowmap_pars_vertex: Gb,
    shadowmap_vertex: Vb,
    shadowmask_pars_fragment: Wb,
    skinbase_vertex: Xb,
    skinning_pars_vertex: Jb,
    skinning_vertex: Yb,
    skinnormal_vertex: Kb,
    specularmap_fragment: jb,
    specularmap_pars_fragment: Zb,
    tonemapping_fragment: Qb,
    tonemapping_pars_fragment: qb,
    transmission_fragment: $b,
    transmission_pars_fragment: eI,
    uv_pars_fragment: tI,
    uv_pars_vertex: nI,
    uv_vertex: iI,
    worldpos_vertex: rI,
    background_vert: sI,
    background_frag: oI,
    backgroundCube_vert: aI,
    backgroundCube_frag: lI,
    cube_vert: uI,
    cube_frag: cI,
    depth_vert: fI,
    depth_frag: dI,
    distanceRGBA_vert: hI,
    distanceRGBA_frag: pI,
    equirect_vert: mI,
    equirect_frag: gI,
    linedashed_vert: vI,
    linedashed_frag: yI,
    meshbasic_vert: _I,
    meshbasic_frag: xI,
    meshlambert_vert: AI,
    meshlambert_frag: SI,
    meshmatcap_vert: MI,
    meshmatcap_frag: EI,
    meshnormal_vert: wI,
    meshnormal_frag: CI,
    meshphong_vert: TI,
    meshphong_frag: RI,
    meshphysical_vert: bI,
    meshphysical_frag: II,
    meshtoon_vert: BI,
    meshtoon_frag: PI,
    points_vert: DI,
    points_frag: LI,
    shadow_vert: FI,
    shadow_frag: NI,
    sprite_vert: UI,
    sprite_frag: OI,
  },
  xt = {
    common: {
      diffuse: { value: new At(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new dn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new dn() },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null }, specularMapTransform: { value: new dn() } },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new dn() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new dn() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new dn() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new dn() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new dn() },
      normalScale: { value: new Ge(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new dn() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new dn() } },
    metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new dn() } },
    roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new dn() } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new At(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: { direction: {}, color: {} } },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
      rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new At(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new dn() },
      alphaTest: { value: 0 },
      uvTransform: { value: new dn() },
    },
    sprite: {
      diffuse: { value: new At(16777215) },
      opacity: { value: 1 },
      center: { value: new Ge(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new dn() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new dn() },
      alphaTest: { value: 0 },
    },
  },
  fo = {
    basic: {
      uniforms: Nr([xt.common, xt.specularmap, xt.envmap, xt.aomap, xt.lightmap, xt.fog]),
      vertexShader: yn.meshbasic_vert,
      fragmentShader: yn.meshbasic_frag,
    },
    lambert: {
      uniforms: Nr([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new At(0) } },
      ]),
      vertexShader: yn.meshlambert_vert,
      fragmentShader: yn.meshlambert_frag,
    },
    phong: {
      uniforms: Nr([
        xt.common,
        xt.specularmap,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new At(0) },
          specular: { value: new At(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: yn.meshphong_vert,
      fragmentShader: yn.meshphong_frag,
    },
    standard: {
      uniforms: Nr([
        xt.common,
        xt.envmap,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.roughnessmap,
        xt.metalnessmap,
        xt.fog,
        xt.lights,
        {
          emissive: { value: new At(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: yn.meshphysical_vert,
      fragmentShader: yn.meshphysical_frag,
    },
    toon: {
      uniforms: Nr([
        xt.common,
        xt.aomap,
        xt.lightmap,
        xt.emissivemap,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.gradientmap,
        xt.fog,
        xt.lights,
        { emissive: { value: new At(0) } },
      ]),
      vertexShader: yn.meshtoon_vert,
      fragmentShader: yn.meshtoon_frag,
    },
    matcap: {
      uniforms: Nr([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        xt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: yn.meshmatcap_vert,
      fragmentShader: yn.meshmatcap_frag,
    },
    points: {
      uniforms: Nr([xt.points, xt.fog]),
      vertexShader: yn.points_vert,
      fragmentShader: yn.points_frag,
    },
    dashed: {
      uniforms: Nr([
        xt.common,
        xt.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } },
      ]),
      vertexShader: yn.linedashed_vert,
      fragmentShader: yn.linedashed_frag,
    },
    depth: {
      uniforms: Nr([xt.common, xt.displacementmap]),
      vertexShader: yn.depth_vert,
      fragmentShader: yn.depth_frag,
    },
    normal: {
      uniforms: Nr([
        xt.common,
        xt.bumpmap,
        xt.normalmap,
        xt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: yn.meshnormal_vert,
      fragmentShader: yn.meshnormal_frag,
    },
    sprite: {
      uniforms: Nr([xt.sprite, xt.fog]),
      vertexShader: yn.sprite_vert,
      fragmentShader: yn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new dn() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: yn.background_vert,
      fragmentShader: yn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new dn() },
      },
      vertexShader: yn.backgroundCube_vert,
      fragmentShader: yn.backgroundCube_frag,
    },
    cube: {
      uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
      vertexShader: yn.cube_vert,
      fragmentShader: yn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: yn.equirect_vert,
      fragmentShader: yn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Nr([
        xt.common,
        xt.displacementmap,
        {
          referencePosition: { value: new J() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: yn.distanceRGBA_vert,
      fragmentShader: yn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Nr([xt.lights, xt.fog, { color: { value: new At(0) }, opacity: { value: 1 } }]),
      vertexShader: yn.shadow_vert,
      fragmentShader: yn.shadow_frag,
    },
  };
fo.physical = {
  uniforms: Nr([
    fo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new dn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new dn() },
      clearcoatNormalScale: { value: new Ge(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new dn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new dn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new dn() },
      sheen: { value: 0 },
      sheenColor: { value: new At(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new dn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new dn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new dn() },
      transmissionSamplerSize: { value: new Ge() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new dn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new At(0) },
      specularColor: { value: new At(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new dn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new dn() },
      anisotropyVector: { value: new Ge() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new dn() },
    },
  ]),
  vertexShader: yn.meshphysical_vert,
  fragmentShader: yn.meshphysical_frag,
};
const Fm = { r: 0, b: 0, g: 0 },
  Iu = new ys(),
  kI = new Qt();
function zI(r, e, t, n, i, o, a) {
  const u = new At(0);
  let d = o === !0 ? 0 : 1,
    h,
    m,
    g = null,
    v = 0,
    x = null;
  function A(I) {
    let B = I.isScene === !0 ? I.background : null;
    return B && B.isTexture && (B = (I.backgroundBlurriness > 0 ? t : e).get(B)), B;
  }
  function C(I) {
    let B = !1;
    const z = A(I);
    z === null ? S(u, d) : z && z.isColor && (S(z, 1), (B = !0));
    const N = r.xr.getEnvironmentBlendMode();
    N === 'additive'
      ? n.buffers.color.setClear(0, 0, 0, 1, a)
      : N === 'alpha-blend' && n.buffers.color.setClear(0, 0, 0, 0, a),
      (r.autoClear || B) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function E(I, B) {
    const z = A(B);
    z && (z.isCubeTexture || z.mapping === Xf)
      ? (m === void 0 &&
          ((m = new oi(
            new oc(1, 1, 1),
            new is({
              name: 'BackgroundCubeMaterial',
              uniforms: Gf(fo.backgroundCube.uniforms),
              vertexShader: fo.backgroundCube.vertexShader,
              fragmentShader: fo.backgroundCube.fragmentShader,
              side: Or,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          m.geometry.deleteAttribute('normal'),
          m.geometry.deleteAttribute('uv'),
          (m.onBeforeRender = function (N, G, k) {
            this.matrixWorld.copyPosition(k.matrixWorld);
          }),
          Object.defineProperty(m.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(m)),
        Iu.copy(B.backgroundRotation),
        (Iu.x *= -1),
        (Iu.y *= -1),
        (Iu.z *= -1),
        z.isCubeTexture && z.isRenderTargetTexture === !1 && ((Iu.y *= -1), (Iu.z *= -1)),
        (m.material.uniforms.envMap.value = z),
        (m.material.uniforms.flipEnvMap.value =
          z.isCubeTexture && z.isRenderTargetTexture === !1 ? -1 : 1),
        (m.material.uniforms.backgroundBlurriness.value = B.backgroundBlurriness),
        (m.material.uniforms.backgroundIntensity.value = B.backgroundIntensity),
        m.material.uniforms.backgroundRotation.value.setFromMatrix4(kI.makeRotationFromEuler(Iu)),
        (m.material.toneMapped = bn.getTransfer(z.colorSpace) !== zn),
        (g !== z || v !== z.version || x !== r.toneMapping) &&
          ((m.material.needsUpdate = !0), (g = z), (v = z.version), (x = r.toneMapping)),
        m.layers.enableAll(),
        I.unshift(m, m.geometry, m.material, 0, 0, null))
      : z &&
        z.isTexture &&
        (h === void 0 &&
          ((h = new oi(
            new Pl(2, 2),
            new is({
              name: 'BackgroundMaterial',
              uniforms: Gf(fo.background.uniforms),
              vertexShader: fo.background.vertexShader,
              fragmentShader: fo.background.fragmentShader,
              side: Uo,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          h.geometry.deleteAttribute('normal'),
          Object.defineProperty(h.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(h)),
        (h.material.uniforms.t2D.value = z),
        (h.material.uniforms.backgroundIntensity.value = B.backgroundIntensity),
        (h.material.toneMapped = bn.getTransfer(z.colorSpace) !== zn),
        z.matrixAutoUpdate === !0 && z.updateMatrix(),
        h.material.uniforms.uvTransform.value.copy(z.matrix),
        (g !== z || v !== z.version || x !== r.toneMapping) &&
          ((h.material.needsUpdate = !0), (g = z), (v = z.version), (x = r.toneMapping)),
        h.layers.enableAll(),
        I.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function S(I, B) {
    I.getRGB(Fm, MM(r)), n.buffers.color.setClear(Fm.r, Fm.g, Fm.b, B, a);
  }
  function b() {
    m !== void 0 && (m.geometry.dispose(), m.material.dispose(), (m = void 0)),
      h !== void 0 && (h.geometry.dispose(), h.material.dispose(), (h = void 0));
  }
  return {
    getClearColor: function () {
      return u;
    },
    setClearColor: function (I, B = 1) {
      u.set(I), (d = B), S(u, d);
    },
    getClearAlpha: function () {
      return d;
    },
    setClearAlpha: function (I) {
      (d = I), S(u, d);
    },
    render: C,
    addToRenderList: E,
    dispose: b,
  };
}
function HI(r, e) {
  const t = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    n = {},
    i = v(null);
  let o = i,
    a = !1;
  function u(D, V, oe, ie, ce) {
    let xe = !1;
    const de = g(ie, oe, V);
    o !== de && ((o = de), h(o.object)),
      (xe = x(D, ie, oe, ce)),
      xe && A(D, ie, oe, ce),
      ce !== null && e.update(ce, r.ELEMENT_ARRAY_BUFFER),
      (xe || a) &&
        ((a = !1),
        B(D, V, oe, ie),
        ce !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(ce).buffer));
  }
  function d() {
    return r.createVertexArray();
  }
  function h(D) {
    return r.bindVertexArray(D);
  }
  function m(D) {
    return r.deleteVertexArray(D);
  }
  function g(D, V, oe) {
    const ie = oe.wireframe === !0;
    let ce = n[D.id];
    ce === void 0 && ((ce = {}), (n[D.id] = ce));
    let xe = ce[V.id];
    xe === void 0 && ((xe = {}), (ce[V.id] = xe));
    let de = xe[ie];
    return de === void 0 && ((de = v(d())), (xe[ie] = de)), de;
  }
  function v(D) {
    const V = [],
      oe = [],
      ie = [];
    for (let ce = 0; ce < t; ce++) (V[ce] = 0), (oe[ce] = 0), (ie[ce] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: V,
      enabledAttributes: oe,
      attributeDivisors: ie,
      object: D,
      attributes: {},
      index: null,
    };
  }
  function x(D, V, oe, ie) {
    const ce = o.attributes,
      xe = V.attributes;
    let de = 0;
    const Ce = oe.getAttributes();
    for (const X in Ce)
      if (Ce[X].location >= 0) {
        const te = ce[X];
        let Y = xe[X];
        if (
          (Y === void 0 &&
            (X === 'instanceMatrix' && D.instanceMatrix && (Y = D.instanceMatrix),
            X === 'instanceColor' && D.instanceColor && (Y = D.instanceColor)),
          te === void 0 || te.attribute !== Y || (Y && te.data !== Y.data))
        )
          return !0;
        de++;
      }
    return o.attributesNum !== de || o.index !== ie;
  }
  function A(D, V, oe, ie) {
    const ce = {},
      xe = V.attributes;
    let de = 0;
    const Ce = oe.getAttributes();
    for (const X in Ce)
      if (Ce[X].location >= 0) {
        let te = xe[X];
        te === void 0 &&
          (X === 'instanceMatrix' && D.instanceMatrix && (te = D.instanceMatrix),
          X === 'instanceColor' && D.instanceColor && (te = D.instanceColor));
        const Y = {};
        (Y.attribute = te), te && te.data && (Y.data = te.data), (ce[X] = Y), de++;
      }
    (o.attributes = ce), (o.attributesNum = de), (o.index = ie);
  }
  function C() {
    const D = o.newAttributes;
    for (let V = 0, oe = D.length; V < oe; V++) D[V] = 0;
  }
  function E(D) {
    S(D, 0);
  }
  function S(D, V) {
    const oe = o.newAttributes,
      ie = o.enabledAttributes,
      ce = o.attributeDivisors;
    (oe[D] = 1),
      ie[D] === 0 && (r.enableVertexAttribArray(D), (ie[D] = 1)),
      ce[D] !== V && (r.vertexAttribDivisor(D, V), (ce[D] = V));
  }
  function b() {
    const D = o.newAttributes,
      V = o.enabledAttributes;
    for (let oe = 0, ie = V.length; oe < ie; oe++)
      V[oe] !== D[oe] && (r.disableVertexAttribArray(oe), (V[oe] = 0));
  }
  function I(D, V, oe, ie, ce, xe, de) {
    de === !0
      ? r.vertexAttribIPointer(D, V, oe, ce, xe)
      : r.vertexAttribPointer(D, V, oe, ie, ce, xe);
  }
  function B(D, V, oe, ie) {
    C();
    const ce = ie.attributes,
      xe = oe.getAttributes(),
      de = V.defaultAttributeValues;
    for (const Ce in xe) {
      const X = xe[Ce];
      if (X.location >= 0) {
        let fe = ce[Ce];
        if (
          (fe === void 0 &&
            (Ce === 'instanceMatrix' && D.instanceMatrix && (fe = D.instanceMatrix),
            Ce === 'instanceColor' && D.instanceColor && (fe = D.instanceColor)),
          fe !== void 0)
        ) {
          const te = fe.normalized,
            Y = fe.itemSize,
            ue = e.get(fe);
          if (ue === void 0) continue;
          const He = ue.buffer,
            ge = ue.type,
            De = ue.bytesPerElement,
            Ie = ge === r.INT || ge === r.UNSIGNED_INT || fe.gpuType === Fh;
          if (fe.isInterleavedBufferAttribute) {
            const Ue = fe.data,
              et = Ue.stride,
              Bt = fe.offset;
            if (Ue.isInstancedInterleavedBuffer) {
              for (let ht = 0; ht < X.locationSize; ht++) S(X.location + ht, Ue.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                ie._maxInstanceCount === void 0 &&
                (ie._maxInstanceCount = Ue.meshPerAttribute * Ue.count);
            } else for (let ht = 0; ht < X.locationSize; ht++) E(X.location + ht);
            r.bindBuffer(r.ARRAY_BUFFER, He);
            for (let ht = 0; ht < X.locationSize; ht++)
              I(
                X.location + ht,
                Y / X.locationSize,
                ge,
                te,
                et * De,
                (Bt + (Y / X.locationSize) * ht) * De,
                Ie,
              );
          } else {
            if (fe.isInstancedBufferAttribute) {
              for (let Ue = 0; Ue < X.locationSize; Ue++) S(X.location + Ue, fe.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                ie._maxInstanceCount === void 0 &&
                (ie._maxInstanceCount = fe.meshPerAttribute * fe.count);
            } else for (let Ue = 0; Ue < X.locationSize; Ue++) E(X.location + Ue);
            r.bindBuffer(r.ARRAY_BUFFER, He);
            for (let Ue = 0; Ue < X.locationSize; Ue++)
              I(
                X.location + Ue,
                Y / X.locationSize,
                ge,
                te,
                Y * De,
                (Y / X.locationSize) * Ue * De,
                Ie,
              );
          }
        } else if (de !== void 0) {
          const te = de[Ce];
          if (te !== void 0)
            switch (te.length) {
              case 2:
                r.vertexAttrib2fv(X.location, te);
                break;
              case 3:
                r.vertexAttrib3fv(X.location, te);
                break;
              case 4:
                r.vertexAttrib4fv(X.location, te);
                break;
              default:
                r.vertexAttrib1fv(X.location, te);
            }
        }
      }
    }
    b();
  }
  function z() {
    k();
    for (const D in n) {
      const V = n[D];
      for (const oe in V) {
        const ie = V[oe];
        for (const ce in ie) m(ie[ce].object), delete ie[ce];
        delete V[oe];
      }
      delete n[D];
    }
  }
  function N(D) {
    if (n[D.id] === void 0) return;
    const V = n[D.id];
    for (const oe in V) {
      const ie = V[oe];
      for (const ce in ie) m(ie[ce].object), delete ie[ce];
      delete V[oe];
    }
    delete n[D.id];
  }
  function G(D) {
    for (const V in n) {
      const oe = n[V];
      if (oe[D.id] === void 0) continue;
      const ie = oe[D.id];
      for (const ce in ie) m(ie[ce].object), delete ie[ce];
      delete oe[D.id];
    }
  }
  function k() {
    L(), (a = !0), o !== i && ((o = i), h(o.object));
  }
  function L() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: u,
    reset: k,
    resetDefaultState: L,
    dispose: z,
    releaseStatesOfGeometry: N,
    releaseStatesOfProgram: G,
    initAttributes: C,
    enableAttribute: E,
    disableUnusedAttributes: b,
  };
}
function GI(r, e, t) {
  let n;
  function i(h) {
    n = h;
  }
  function o(h, m) {
    r.drawArrays(n, h, m), t.update(m, n, 1);
  }
  function a(h, m, g) {
    g !== 0 && (r.drawArraysInstanced(n, h, m, g), t.update(m, n, g));
  }
  function u(h, m, g) {
    if (g === 0) return;
    e.get('WEBGL_multi_draw').multiDrawArraysWEBGL(n, h, 0, m, 0, g);
    let x = 0;
    for (let A = 0; A < g; A++) x += m[A];
    t.update(x, n, 1);
  }
  function d(h, m, g, v) {
    if (g === 0) return;
    const x = e.get('WEBGL_multi_draw');
    if (x === null) for (let A = 0; A < h.length; A++) a(h[A], m[A], v[A]);
    else {
      x.multiDrawArraysInstancedWEBGL(n, h, 0, m, 0, v, 0, g);
      let A = 0;
      for (let C = 0; C < g; C++) A += m[C] * v[C];
      t.update(A, n, 1);
    }
  }
  (this.setMode = i),
    (this.render = o),
    (this.renderInstances = a),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = d);
}
function VI(r, e, t, n) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const G = e.get('EXT_texture_filter_anisotropic');
      i = r.getParameter(G.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function a(G) {
    return !(G !== Si && n.convert(G) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function u(G) {
    const k = G === Yi && (e.has('EXT_color_buffer_half_float') || e.has('EXT_color_buffer_float'));
    return !(
      G !== ns &&
      n.convert(G) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) &&
      G !== fi &&
      !k
    );
  }
  function d(G) {
    if (G === 'highp') {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0
      )
        return 'highp';
      G = 'mediump';
    }
    return G === 'mediump' &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0
      ? 'mediump'
      : 'lowp';
  }
  let h = t.precision !== void 0 ? t.precision : 'highp';
  const m = d(h);
  m !== h &&
    (console.warn('THREE.WebGLRenderer:', h, 'not supported, using', m, 'instead.'), (h = m));
  const g = t.logarithmicDepthBuffer === !0,
    v = t.reverseDepthBuffer === !0 && e.has('EXT_clip_control'),
    x = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    A = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    C = r.getParameter(r.MAX_TEXTURE_SIZE),
    E = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    S = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    b = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    I = r.getParameter(r.MAX_VARYING_VECTORS),
    B = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    z = A > 0,
    N = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: d,
    textureFormatReadable: a,
    textureTypeReadable: u,
    precision: h,
    logarithmicDepthBuffer: g,
    reverseDepthBuffer: v,
    maxTextures: x,
    maxVertexTextures: A,
    maxTextureSize: C,
    maxCubemapSize: E,
    maxAttributes: S,
    maxVertexUniforms: b,
    maxVaryings: I,
    maxFragmentUniforms: B,
    vertexTextures: z,
    maxSamples: N,
  };
}
function WI(r) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    o = !1;
  const a = new Ra(),
    u = new dn(),
    d = { value: null, needsUpdate: !1 };
  (this.uniform = d),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (g, v) {
      const x = g.length !== 0 || v || n !== 0 || i;
      return (i = v), (n = g.length), x;
    }),
    (this.beginShadows = function () {
      (o = !0), m(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (g, v) {
      t = m(g, v, 0);
    }),
    (this.setState = function (g, v, x) {
      const A = g.clippingPlanes,
        C = g.clipIntersection,
        E = g.clipShadows,
        S = r.get(g);
      if (!i || A === null || A.length === 0 || (o && !E)) o ? m(null) : h();
      else {
        const b = o ? 0 : n,
          I = b * 4;
        let B = S.clippingState || null;
        (d.value = B), (B = m(A, v, I, x));
        for (let z = 0; z !== I; ++z) B[z] = t[z];
        (S.clippingState = B),
          (this.numIntersection = C ? this.numPlanes : 0),
          (this.numPlanes += b);
      }
    });
  function h() {
    d.value !== t && ((d.value = t), (d.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function m(g, v, x, A) {
    const C = g !== null ? g.length : 0;
    let E = null;
    if (C !== 0) {
      if (((E = d.value), A !== !0 || E === null)) {
        const S = x + C * 4,
          b = v.matrixWorldInverse;
        u.getNormalMatrix(b), (E === null || E.length < S) && (E = new Float32Array(S));
        for (let I = 0, B = x; I !== C; ++I, B += 4)
          a.copy(g[I]).applyMatrix4(b, u), a.normal.toArray(E, B), (E[B + 3] = a.constant);
      }
      (d.value = E), (d.needsUpdate = !0);
    }
    return (e.numPlanes = C), (e.numIntersection = 0), E;
  }
}
function XI(r) {
  let e = new WeakMap();
  function t(a, u) {
    return u === Nf ? (a.mapping = Oo) : u === xh && (a.mapping = Tl), a;
  }
  function n(a) {
    if (a && a.isTexture) {
      const u = a.mapping;
      if (u === Nf || u === xh)
        if (e.has(a)) {
          const d = e.get(a).texture;
          return t(d, a.mapping);
        } else {
          const d = a.image;
          if (d && d.height > 0) {
            const h = new Hy(d.height);
            return (
              h.fromEquirectangularTexture(r, a),
              e.set(a, h),
              a.addEventListener('dispose', i),
              t(h.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const u = a.target;
    u.removeEventListener('dispose', i);
    const d = e.get(u);
    d !== void 0 && (e.delete(u), d.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: n, dispose: o };
}
const Bf = 4,
  TA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Uu = 20,
  B0 = new No(),
  RA = new At();
let P0 = null,
  D0 = 0,
  L0 = 0,
  F0 = !1;
const Nu = (1 + Math.sqrt(5)) / 2,
  Ef = 1 / Nu,
  bA = [
    new J(-Nu, Ef, 0),
    new J(Nu, Ef, 0),
    new J(-Ef, 0, Nu),
    new J(Ef, 0, Nu),
    new J(0, Nu, -Ef),
    new J(0, Nu, Ef),
    new J(-1, 1, -1),
    new J(1, 1, -1),
    new J(-1, 1, 1),
    new J(1, 1, 1),
  ];
class _y {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (P0 = this._renderer.getRenderTarget()),
      (D0 = this._renderer.getActiveCubeFace()),
      (L0 = this._renderer.getActiveMipmapLevel()),
      (F0 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, o),
      t > 0 && this._blur(o, 0, 0, t),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = PA()), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = BA()), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(P0, D0, L0),
      (this._renderer.xr.enabled = F0),
      (e.scissorTest = !1),
      Nm(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Oo || e.mapping === Tl
      ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width)
      : this._setSize(e.image.width / 4),
      (P0 = this._renderer.getRenderTarget()),
      (D0 = this._renderer.getActiveCubeFace()),
      (L0 = this._renderer.getActiveMipmapLevel()),
      (F0 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: Fn,
        minFilter: Fn,
        generateMipmaps: !1,
        type: Yi,
        format: Si,
        colorSpace: zo,
        depthBuffer: !1,
      },
      i = IA(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = IA(e, t, n));
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = JI(o)),
        (this._blurMaterial = YI(o, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new oi(this._lodPlanes[0], e);
    this._renderer.compile(t, B0);
  }
  _sceneToCubeUV(e, t, n, i) {
    const u = new gi(90, 1, t, n),
      d = [1, -1, 1, 1, 1, 1],
      h = [1, 1, 1, -1, -1, -1],
      m = this._renderer,
      g = m.autoClear,
      v = m.toneMapping;
    m.getClearColor(RA), (m.toneMapping = Lo), (m.autoClear = !1);
    const x = new ts({ name: 'PMREM.Background', side: Or, depthWrite: !1, depthTest: !1 }),
      A = new oi(new oc(), x);
    let C = !1;
    const E = e.background;
    E
      ? E.isColor && (x.color.copy(E), (e.background = null), (C = !0))
      : (x.color.copy(RA), (C = !0));
    for (let S = 0; S < 6; S++) {
      const b = S % 3;
      b === 0
        ? (u.up.set(0, d[S], 0), u.lookAt(h[S], 0, 0))
        : b === 1
        ? (u.up.set(0, 0, d[S]), u.lookAt(0, h[S], 0))
        : (u.up.set(0, d[S], 0), u.lookAt(0, 0, h[S]));
      const I = this._cubeSize;
      Nm(i, b * I, S > 2 ? I : 0, I, I), m.setRenderTarget(i), C && m.render(A, u), m.render(e, u);
    }
    A.geometry.dispose(),
      A.material.dispose(),
      (m.toneMapping = v),
      (m.autoClear = g),
      (e.background = E);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === Oo || e.mapping === Tl;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = PA()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = BA());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new oi(this._lodPlanes[0], o),
      u = o.uniforms;
    u.envMap.value = e;
    const d = this._cubeSize;
    Nm(t, 0, 0, 3 * d, 2 * d), n.setRenderTarget(t), n.render(a, B0);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const a = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1],
        ),
        u = bA[(i - o - 1) % bA.length];
      this._blur(e, o - 1, o, a, u);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, i, 'latitudinal', o),
      this._halfBlur(a, e, n, n, i, 'longitudinal', o);
  }
  _halfBlur(e, t, n, i, o, a, u) {
    const d = this._renderer,
      h = this._blurMaterial;
    a !== 'latitudinal' &&
      a !== 'longitudinal' &&
      console.error('blur direction must be either latitudinal or longitudinal!');
    const m = 3,
      g = new oi(this._lodPlanes[i], h),
      v = h.uniforms,
      x = this._sizeLods[n] - 1,
      A = isFinite(o) ? Math.PI / (2 * x) : (2 * Math.PI) / (2 * Uu - 1),
      C = o / A,
      E = isFinite(o) ? 1 + Math.floor(m * C) : Uu;
    E > Uu &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Uu}`,
      );
    const S = [];
    let b = 0;
    for (let G = 0; G < Uu; ++G) {
      const k = G / C,
        L = Math.exp((-k * k) / 2);
      S.push(L), G === 0 ? (b += L) : G < E && (b += 2 * L);
    }
    for (let G = 0; G < S.length; G++) S[G] = S[G] / b;
    (v.envMap.value = e.texture),
      (v.samples.value = E),
      (v.weights.value = S),
      (v.latitudinal.value = a === 'latitudinal'),
      u && (v.poleAxis.value = u);
    const { _lodMax: I } = this;
    (v.dTheta.value = A), (v.mipInt.value = I - n);
    const B = this._sizeLods[i],
      z = 3 * B * (i > I - Bf ? i - I + Bf : 0),
      N = 4 * (this._cubeSize - B);
    Nm(t, z, N, 3 * B, 2 * B), d.setRenderTarget(t), d.render(g, B0);
  }
}
function JI(r) {
  const e = [],
    t = [],
    n = [];
  let i = r;
  const o = r - Bf + 1 + TA.length;
  for (let a = 0; a < o; a++) {
    const u = Math.pow(2, i);
    t.push(u);
    let d = 1 / u;
    a > r - Bf ? (d = TA[a - r + Bf - 1]) : a === 0 && (d = 0), n.push(d);
    const h = 1 / (u - 2),
      m = -h,
      g = 1 + h,
      v = [m, m, g, m, g, g, m, m, g, g, m, g],
      x = 6,
      A = 6,
      C = 3,
      E = 2,
      S = 1,
      b = new Float32Array(C * A * x),
      I = new Float32Array(E * A * x),
      B = new Float32Array(S * A * x);
    for (let N = 0; N < x; N++) {
      const G = ((N % 3) * 2) / 3 - 1,
        k = N > 2 ? 0 : -1,
        L = [
          G,
          k,
          0,
          G + 2 / 3,
          k,
          0,
          G + 2 / 3,
          k + 1,
          0,
          G,
          k,
          0,
          G + 2 / 3,
          k + 1,
          0,
          G,
          k + 1,
          0,
        ];
      b.set(L, C * A * N), I.set(v, E * A * N);
      const D = [N, N, N, N, N, N];
      B.set(D, S * A * N);
    }
    const z = new hn();
    z.setAttribute('position', new Pn(b, C)),
      z.setAttribute('uv', new Pn(I, E)),
      z.setAttribute('faceIndex', new Pn(B, S)),
      e.push(z),
      i > Bf && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function IA(r, e, t) {
  const n = new Ls(r, e, t);
  return (n.texture.mapping = Xf), (n.texture.name = 'PMREM.cubeUv'), (n.scissorTest = !0), n;
}
function Nm(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function YI(r, e, t) {
  const n = new Float32Array(Uu),
    i = new J(0, 1, 0);
  return new is({
    name: 'SphericalGaussianBlur',
    defines: {
      n: Uu,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: v_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Do,
    depthTest: !1,
    depthWrite: !1,
  });
}
function BA() {
  return new is({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: v_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Do,
    depthTest: !1,
    depthWrite: !1,
  });
}
function PA() {
  return new is({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: v_(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Do,
    depthTest: !1,
    depthWrite: !1,
  });
}
function v_() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function KI(r) {
  let e = new WeakMap(),
    t = null;
  function n(u) {
    if (u && u.isTexture) {
      const d = u.mapping,
        h = d === Nf || d === xh,
        m = d === Oo || d === Tl;
      if (h || m) {
        let g = e.get(u);
        const v = g !== void 0 ? g.texture.pmremVersion : 0;
        if (u.isRenderTargetTexture && u.pmremVersion !== v)
          return (
            t === null && (t = new _y(r)),
            (g = h ? t.fromEquirectangular(u, g) : t.fromCubemap(u, g)),
            (g.texture.pmremVersion = u.pmremVersion),
            e.set(u, g),
            g.texture
          );
        if (g !== void 0) return g.texture;
        {
          const x = u.image;
          return (h && x && x.height > 0) || (m && x && i(x))
            ? (t === null && (t = new _y(r)),
              (g = h ? t.fromEquirectangular(u) : t.fromCubemap(u)),
              (g.texture.pmremVersion = u.pmremVersion),
              e.set(u, g),
              u.addEventListener('dispose', o),
              g.texture)
            : null;
        }
      }
    }
    return u;
  }
  function i(u) {
    let d = 0;
    const h = 6;
    for (let m = 0; m < h; m++) u[m] !== void 0 && d++;
    return d === h;
  }
  function o(u) {
    const d = u.target;
    d.removeEventListener('dispose', o);
    const h = e.get(d);
    h !== void 0 && (e.delete(d), h.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function jI(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case 'WEBGL_depth_texture':
        i =
          r.getExtension('WEBGL_depth_texture') ||
          r.getExtension('MOZ_WEBGL_depth_texture') ||
          r.getExtension('WEBKIT_WEBGL_depth_texture');
        break;
      case 'EXT_texture_filter_anisotropic':
        i =
          r.getExtension('EXT_texture_filter_anisotropic') ||
          r.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          r.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;
      case 'WEBGL_compressed_texture_s3tc':
        i =
          r.getExtension('WEBGL_compressed_texture_s3tc') ||
          r.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;
      case 'WEBGL_compressed_texture_pvrtc':
        i =
          r.getExtension('WEBGL_compressed_texture_pvrtc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;
      default:
        i = r.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function () {
      t('EXT_color_buffer_float'),
        t('WEBGL_clip_cull_distance'),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture'),
        t('WEBGL_render_shared_exponent');
    },
    get: function (n) {
      const i = t(n);
      return i === null && Cf('THREE.WebGLRenderer: ' + n + ' extension not supported.'), i;
    },
  };
}
function ZI(r, e, t, n) {
  const i = {},
    o = new WeakMap();
  function a(g) {
    const v = g.target;
    v.index !== null && e.remove(v.index);
    for (const A in v.attributes) e.remove(v.attributes[A]);
    v.removeEventListener('dispose', a), delete i[v.id];
    const x = o.get(v);
    x && (e.remove(x), o.delete(v)),
      n.releaseStatesOfGeometry(v),
      v.isInstancedBufferGeometry === !0 && delete v._maxInstanceCount,
      t.memory.geometries--;
  }
  function u(g, v) {
    return (
      i[v.id] === !0 || (v.addEventListener('dispose', a), (i[v.id] = !0), t.memory.geometries++), v
    );
  }
  function d(g) {
    const v = g.attributes;
    for (const x in v) e.update(v[x], r.ARRAY_BUFFER);
  }
  function h(g) {
    const v = [],
      x = g.index,
      A = g.attributes.position;
    let C = 0;
    if (x !== null) {
      const b = x.array;
      C = x.version;
      for (let I = 0, B = b.length; I < B; I += 3) {
        const z = b[I + 0],
          N = b[I + 1],
          G = b[I + 2];
        v.push(z, N, N, G, G, z);
      }
    } else if (A !== void 0) {
      const b = A.array;
      C = A.version;
      for (let I = 0, B = b.length / 3 - 1; I < B; I += 3) {
        const z = I + 0,
          N = I + 1,
          G = I + 2;
        v.push(z, N, N, G, G, z);
      }
    } else return;
    const E = new (_M(v) ? zy : ky)(v, 1);
    E.version = C;
    const S = o.get(g);
    S && e.remove(S), o.set(g, E);
  }
  function m(g) {
    const v = o.get(g);
    if (v) {
      const x = g.index;
      x !== null && v.version < x.version && h(g);
    } else h(g);
    return o.get(g);
  }
  return { get: u, update: d, getWireframeAttribute: m };
}
function QI(r, e, t) {
  let n;
  function i(v) {
    n = v;
  }
  let o, a;
  function u(v) {
    (o = v.type), (a = v.bytesPerElement);
  }
  function d(v, x) {
    r.drawElements(n, x, o, v * a), t.update(x, n, 1);
  }
  function h(v, x, A) {
    A !== 0 && (r.drawElementsInstanced(n, x, o, v * a, A), t.update(x, n, A));
  }
  function m(v, x, A) {
    if (A === 0) return;
    e.get('WEBGL_multi_draw').multiDrawElementsWEBGL(n, x, 0, o, v, 0, A);
    let E = 0;
    for (let S = 0; S < A; S++) E += x[S];
    t.update(E, n, 1);
  }
  function g(v, x, A, C) {
    if (A === 0) return;
    const E = e.get('WEBGL_multi_draw');
    if (E === null) for (let S = 0; S < v.length; S++) h(v[S] / a, x[S], C[S]);
    else {
      E.multiDrawElementsInstancedWEBGL(n, x, 0, o, v, 0, C, 0, A);
      let S = 0;
      for (let b = 0; b < A; b++) S += x[b] * C[b];
      t.update(S, n, 1);
    }
  }
  (this.setMode = i),
    (this.setIndex = u),
    (this.render = d),
    (this.renderInstances = h),
    (this.renderMultiDraw = m),
    (this.renderMultiDrawInstances = g);
}
function qI(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(o, a, u) {
    switch ((t.calls++, a)) {
      case r.TRIANGLES:
        t.triangles += u * (o / 3);
        break;
      case r.LINES:
        t.lines += u * (o / 2);
        break;
      case r.LINE_STRIP:
        t.lines += u * (o - 1);
        break;
      case r.LINE_LOOP:
        t.lines += u * o;
        break;
      case r.POINTS:
        t.points += u * o;
        break;
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', a);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return { memory: e, render: t, programs: null, autoReset: !0, reset: i, update: n };
}
function $I(r, e, t) {
  const n = new WeakMap(),
    i = new Bn();
  function o(a, u, d) {
    const h = a.morphTargetInfluences,
      m = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
      g = m !== void 0 ? m.length : 0;
    let v = n.get(u);
    if (v === void 0 || v.count !== g) {
      let D = function () {
        k.dispose(), n.delete(u), u.removeEventListener('dispose', D);
      };
      var x = D;
      v !== void 0 && v.texture.dispose();
      const A = u.morphAttributes.position !== void 0,
        C = u.morphAttributes.normal !== void 0,
        E = u.morphAttributes.color !== void 0,
        S = u.morphAttributes.position || [],
        b = u.morphAttributes.normal || [],
        I = u.morphAttributes.color || [];
      let B = 0;
      A === !0 && (B = 1), C === !0 && (B = 2), E === !0 && (B = 3);
      let z = u.attributes.position.count * B,
        N = 1;
      z > e.maxTextureSize && ((N = Math.ceil(z / e.maxTextureSize)), (z = e.maxTextureSize));
      const G = new Float32Array(z * N * 4 * g),
        k = new Oh(G, z, N, g);
      (k.type = fi), (k.needsUpdate = !0);
      const L = B * 4;
      for (let V = 0; V < g; V++) {
        const oe = S[V],
          ie = b[V],
          ce = I[V],
          xe = z * N * 4 * V;
        for (let de = 0; de < oe.count; de++) {
          const Ce = de * L;
          A === !0 &&
            (i.fromBufferAttribute(oe, de),
            (G[xe + Ce + 0] = i.x),
            (G[xe + Ce + 1] = i.y),
            (G[xe + Ce + 2] = i.z),
            (G[xe + Ce + 3] = 0)),
            C === !0 &&
              (i.fromBufferAttribute(ie, de),
              (G[xe + Ce + 4] = i.x),
              (G[xe + Ce + 5] = i.y),
              (G[xe + Ce + 6] = i.z),
              (G[xe + Ce + 7] = 0)),
            E === !0 &&
              (i.fromBufferAttribute(ce, de),
              (G[xe + Ce + 8] = i.x),
              (G[xe + Ce + 9] = i.y),
              (G[xe + Ce + 10] = i.z),
              (G[xe + Ce + 11] = ce.itemSize === 4 ? i.w : 1));
        }
      }
      (v = { count: g, texture: k, size: new Ge(z, N) }),
        n.set(u, v),
        u.addEventListener('dispose', D);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      d.getUniforms().setValue(r, 'morphTexture', a.morphTexture, t);
    else {
      let A = 0;
      for (let E = 0; E < h.length; E++) A += h[E];
      const C = u.morphTargetsRelative ? 1 : 1 - A;
      d.getUniforms().setValue(r, 'morphTargetBaseInfluence', C),
        d.getUniforms().setValue(r, 'morphTargetInfluences', h);
    }
    d.getUniforms().setValue(r, 'morphTargetsTexture', v.texture, t),
      d.getUniforms().setValue(r, 'morphTargetsTextureSize', v.size);
  }
  return { update: o };
}
function eB(r, e, t, n) {
  let i = new WeakMap();
  function o(d) {
    const h = n.render.frame,
      m = d.geometry,
      g = e.get(d, m);
    if (
      (i.get(g) !== h && (e.update(g), i.set(g, h)),
      d.isInstancedMesh &&
        (d.hasEventListener('dispose', u) === !1 && d.addEventListener('dispose', u),
        i.get(d) !== h &&
          (t.update(d.instanceMatrix, r.ARRAY_BUFFER),
          d.instanceColor !== null && t.update(d.instanceColor, r.ARRAY_BUFFER),
          i.set(d, h))),
      d.isSkinnedMesh)
    ) {
      const v = d.skeleton;
      i.get(v) !== h && (v.update(), i.set(v, h));
    }
    return g;
  }
  function a() {
    i = new WeakMap();
  }
  function u(d) {
    const h = d.target;
    h.removeEventListener('dispose', u),
      t.remove(h.instanceMatrix),
      h.instanceColor !== null && t.remove(h.instanceColor);
  }
  return { update: o, dispose: a };
}
const gE = new Ln(),
  DA = new Yy(1, 1),
  vE = new Oh(),
  yE = new Yg(),
  _E = new zh(),
  LA = [],
  FA = [],
  NA = new Float32Array(16),
  UA = new Float32Array(9),
  OA = new Float32Array(4);
function Kf(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let o = LA[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (LA[i] = o)), e !== 0)) {
    n.toArray(o, 0);
    for (let a = 1, u = 0; a !== e; ++a) (u += t), r[a].toArray(o, u);
  }
  return o;
}
function ki(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function zi(r, e) {
  for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function pv(r, e) {
  let t = FA[e];
  t === void 0 && ((t = new Int32Array(e)), (FA[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
  return t;
}
function tB(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function nB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ki(t, e)) return;
    r.uniform2fv(this.addr, e), zi(t, e);
  }
}
function iB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b));
  else {
    if (ki(t, e)) return;
    r.uniform3fv(this.addr, e), zi(t, e);
  }
}
function rB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ki(t, e)) return;
    r.uniform4fv(this.addr, e), zi(t, e);
  }
}
function sB(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ki(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), zi(t, e);
  } else {
    if (ki(t, n)) return;
    OA.set(n), r.uniformMatrix2fv(this.addr, !1, OA), zi(t, n);
  }
}
function oB(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ki(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), zi(t, e);
  } else {
    if (ki(t, n)) return;
    UA.set(n), r.uniformMatrix3fv(this.addr, !1, UA), zi(t, n);
  }
}
function aB(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (ki(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), zi(t, e);
  } else {
    if (ki(t, n)) return;
    NA.set(n), r.uniformMatrix4fv(this.addr, !1, NA), zi(t, n);
  }
}
function lB(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function uB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ki(t, e)) return;
    r.uniform2iv(this.addr, e), zi(t, e);
  }
}
function cB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
  else {
    if (ki(t, e)) return;
    r.uniform3iv(this.addr, e), zi(t, e);
  }
}
function fB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ki(t, e)) return;
    r.uniform4iv(this.addr, e), zi(t, e);
  }
}
function dB(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function hB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (ki(t, e)) return;
    r.uniform2uiv(this.addr, e), zi(t, e);
  }
}
function pB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
  else {
    if (ki(t, e)) return;
    r.uniform3uiv(this.addr, e), zi(t, e);
  }
}
function mB(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (ki(t, e)) return;
    r.uniform4uiv(this.addr, e), zi(t, e);
  }
}
function gB(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i));
  let o;
  this.type === r.SAMPLER_2D_SHADOW ? ((DA.compareFunction = Uy), (o = DA)) : (o = gE),
    t.setTexture2D(e || o, i);
}
function vB(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)), t.setTexture3D(e || yE, i);
}
function yB(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)), t.setTextureCube(e || _E, i);
}
function _B(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)), t.setTexture2DArray(e || vE, i);
}
function xB(r) {
  switch (r) {
    case 5126:
      return tB;
    case 35664:
      return nB;
    case 35665:
      return iB;
    case 35666:
      return rB;
    case 35674:
      return sB;
    case 35675:
      return oB;
    case 35676:
      return aB;
    case 5124:
    case 35670:
      return lB;
    case 35667:
    case 35671:
      return uB;
    case 35668:
    case 35672:
      return cB;
    case 35669:
    case 35673:
      return fB;
    case 5125:
      return dB;
    case 36294:
      return hB;
    case 36295:
      return pB;
    case 36296:
      return mB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gB;
    case 35679:
    case 36299:
    case 36307:
      return vB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return yB;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return _B;
  }
}
function AB(r, e) {
  r.uniform1fv(this.addr, e);
}
function SB(r, e) {
  const t = Kf(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function MB(r, e) {
  const t = Kf(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function EB(r, e) {
  const t = Kf(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function wB(r, e) {
  const t = Kf(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function CB(r, e) {
  const t = Kf(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function TB(r, e) {
  const t = Kf(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function RB(r, e) {
  r.uniform1iv(this.addr, e);
}
function bB(r, e) {
  r.uniform2iv(this.addr, e);
}
function IB(r, e) {
  r.uniform3iv(this.addr, e);
}
function BB(r, e) {
  r.uniform4iv(this.addr, e);
}
function PB(r, e) {
  r.uniform1uiv(this.addr, e);
}
function DB(r, e) {
  r.uniform2uiv(this.addr, e);
}
function LB(r, e) {
  r.uniform3uiv(this.addr, e);
}
function FB(r, e) {
  r.uniform4uiv(this.addr, e);
}
function NB(r, e, t) {
  const n = this.cache,
    i = e.length,
    o = pv(t, i);
  ki(n, o) || (r.uniform1iv(this.addr, o), zi(n, o));
  for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || gE, o[a]);
}
function UB(r, e, t) {
  const n = this.cache,
    i = e.length,
    o = pv(t, i);
  ki(n, o) || (r.uniform1iv(this.addr, o), zi(n, o));
  for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || yE, o[a]);
}
function OB(r, e, t) {
  const n = this.cache,
    i = e.length,
    o = pv(t, i);
  ki(n, o) || (r.uniform1iv(this.addr, o), zi(n, o));
  for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || _E, o[a]);
}
function kB(r, e, t) {
  const n = this.cache,
    i = e.length,
    o = pv(t, i);
  ki(n, o) || (r.uniform1iv(this.addr, o), zi(n, o));
  for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || vE, o[a]);
}
function zB(r) {
  switch (r) {
    case 5126:
      return AB;
    case 35664:
      return SB;
    case 35665:
      return MB;
    case 35666:
      return EB;
    case 35674:
      return wB;
    case 35675:
      return CB;
    case 35676:
      return TB;
    case 5124:
    case 35670:
      return RB;
    case 35667:
    case 35671:
      return bB;
    case 35668:
    case 35672:
      return IB;
    case 35669:
    case 35673:
      return BB;
    case 5125:
      return PB;
    case 36294:
      return DB;
    case 36295:
      return LB;
    case 36296:
      return FB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return NB;
    case 35679:
    case 36299:
    case 36307:
      return UB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return OB;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return kB;
  }
}
class HB {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = xB(t.type));
  }
}
class GB {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = zB(t.type));
  }
}
class VB {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let o = 0, a = i.length; o !== a; ++o) {
      const u = i[o];
      u.setValue(e, t[u.id], n);
    }
  }
}
const N0 = /(\w+)(\])?(\[|\.)?/g;
function kA(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function WB(r, e, t) {
  const n = r.name,
    i = n.length;
  for (N0.lastIndex = 0; ; ) {
    const o = N0.exec(n),
      a = N0.lastIndex;
    let u = o[1];
    const d = o[2] === ']',
      h = o[3];
    if ((d && (u = u | 0), h === void 0 || (h === '[' && a + 2 === i))) {
      kA(t, h === void 0 ? new HB(u, r, e) : new GB(u, r, e));
      break;
    } else {
      let g = t.map[u];
      g === void 0 && ((g = new VB(u)), kA(t, g)), (t = g);
    }
  }
}
class Ym {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const o = e.getActiveUniform(t, i),
        a = e.getUniformLocation(t, o.name);
      WB(o, a, this);
    }
  }
  setValue(e, t, n, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let o = 0, a = t.length; o !== a; ++o) {
      const u = t[o],
        d = n[u.id];
      d.needsUpdate !== !1 && u.setValue(e, d.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function zA(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
const XB = 37297;
let JB = 0;
function YB(r, e) {
  const t = r.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let a = i; a < o; a++) {
    const u = a + 1;
    n.push(`${u === e ? '>' : ' '} ${u}: ${t[a]}`);
  }
  return n.join(`
`);
}
const HA = new dn();
function KB(r) {
  bn._getMatrix(HA, bn.workingColorSpace, r);
  const e = `mat3( ${HA.elements.map((t) => t.toFixed(4))} )`;
  switch (bn.getTransfer(r)) {
    case Sh:
      return [e, 'LinearTransferOETF'];
    case zn:
      return [e, 'sRGBTransferOETF'];
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space: ', r), [e, 'LinearTransferOETF']
      );
  }
}
function GA(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(e).trim();
  if (n && i === '') return '';
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const a = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      YB(r.getShaderSource(e), a)
    );
  } else return i;
}
function jB(r, e) {
  const t = KB(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    '}',
  ].join(`
`);
}
function ZB(r, e) {
  let t;
  switch (e) {
    case QS:
      t = 'Linear';
      break;
    case qS:
      t = 'Reinhard';
      break;
    case $S:
      t = 'Cineon';
      break;
    case Ty:
      t = 'ACESFilmic';
      break;
    case tM:
      t = 'AgX';
      break;
    case nM:
      t = 'Neutral';
      break;
    case eM:
      t = 'Custom';
      break;
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (t = 'Linear');
  }
  return 'vec3 ' + r + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }';
}
const Um = new J();
function QB() {
  bn.getLuminanceCoefficients(Um);
  const r = Um.x.toFixed(4),
    e = Um.y.toFixed(4),
    t = Um.z.toFixed(4);
  return [
    'float luminance( const in vec3 rgb ) {',
    `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`,
    '	return dot( weights, rgb );',
    '}',
  ].join(`
`);
}
function qB(r) {
  return [
    r.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
    r.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ].filter(lh).join(`
`);
}
function $B(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push('#define ' + t + ' ' + n);
  }
  return e.join(`
`);
}
function eP(r, e) {
  const t = {},
    n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const o = r.getActiveAttrib(e, i),
      a = o.name;
    let u = 1;
    o.type === r.FLOAT_MAT2 && (u = 2),
      o.type === r.FLOAT_MAT3 && (u = 3),
      o.type === r.FLOAT_MAT4 && (u = 4),
      (t[a] = { type: o.type, location: r.getAttribLocation(e, a), locationSize: u });
  }
  return t;
}
function lh(r) {
  return r !== '';
}
function VA(r, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function WA(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const tP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function xy(r) {
  return r.replace(tP, iP);
}
const nP = new Map();
function iP(r, e) {
  let t = yn[e];
  if (t === void 0) {
    const n = nP.get(e);
    if (n !== void 0)
      (t = yn[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n,
        );
    else throw new Error('Can not resolve #include <' + e + '>');
  }
  return xy(t);
}
const rP =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function XA(r) {
  return r.replace(rP, sP);
}
function sP(r, e, t, n) {
  let i = '';
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += n.replace(/\[\s*i\s*\]/g, '[ ' + o + ' ]').replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function JA(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return (
    r.precision === 'highp'
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === 'mediump'
      ? (e += `
#define MEDIUM_PRECISION`)
      : r.precision === 'lowp' &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function oP(r) {
  let e = 'SHADOWMAP_TYPE_BASIC';
  return (
    r.shadowMapType === Ug
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : r.shadowMapType === ch
      ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
      : r.shadowMapType === co && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  );
}
function aP(r) {
  let e = 'ENVMAP_TYPE_CUBE';
  if (r.envMap)
    switch (r.envMapMode) {
      case Oo:
      case Tl:
        e = 'ENVMAP_TYPE_CUBE';
        break;
      case Xf:
        e = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  return e;
}
function lP(r) {
  let e = 'ENVMAP_MODE_REFLECTION';
  if (r.envMap)
    switch (r.envMapMode) {
      case Tl:
        e = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  return e;
}
function uP(r) {
  let e = 'ENVMAP_BLENDING_NONE';
  if (r.envMap)
    switch (r.combine) {
      case Lh:
        e = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case jS:
        e = 'ENVMAP_BLENDING_MIX';
        break;
      case ZS:
        e = 'ENVMAP_BLENDING_ADD';
        break;
    }
  return e;
}
function cP(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function fP(r, e, t, n) {
  const i = r.getContext(),
    o = t.defines;
  let a = t.vertexShader,
    u = t.fragmentShader;
  const d = oP(t),
    h = aP(t),
    m = lP(t),
    g = uP(t),
    v = cP(t),
    x = qB(t),
    A = $B(o),
    C = i.createProgram();
  let E,
    S,
    b = t.glslVersion
      ? '#version ' +
        t.glslVersion +
        `
`
      : '';
  t.isRawShaderMaterial
    ? ((E = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        A,
      ].filter(lh).join(`
`)),
      E.length > 0 &&
        (E += `
`),
      (S = ['#define SHADER_TYPE ' + t.shaderType, '#define SHADER_NAME ' + t.shaderName, A].filter(
        lh,
      ).join(`
`)),
      S.length > 0 &&
        (S += `
`))
    : ((E = [
        JA(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        A,
        t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        t.batching ? '#define USE_BATCHING' : '',
        t.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        t.instancing ? '#define USE_INSTANCING' : '',
        t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + m : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
        t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
        t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
        t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
        t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
        t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
        t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
        t.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv : '',
        t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
        t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
        t.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv : '',
        t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
        t.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv : '',
        t.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
          : '',
        t.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv : '',
        t.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
          : '',
        t.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv : '',
        t.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv : '',
        t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
        t.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv : '',
        t.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
          : '',
        t.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv : '',
        t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.skinning ? '#define USE_SKINNING' : '',
        t.morphTargets ? '#define USE_MORPHTARGETS' : '',
        t.morphNormals && t.flatShading === !1 ? '#define USE_MORPHNORMALS' : '',
        t.morphColors ? '#define USE_MORPHCOLORS' : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
          : '',
        t.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + d : '',
        t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`,
      ].filter(lh).join(`
`)),
      (S = [
        JA(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        A,
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        t.map ? '#define USE_MAP' : '',
        t.matcap ? '#define USE_MATCAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + h : '',
        t.envMap ? '#define ' + m : '',
        t.envMap ? '#define ' + g : '',
        v ? '#define CUBEUV_TEXEL_WIDTH ' + v.texelWidth : '',
        v ? '#define CUBEUV_TEXEL_HEIGHT ' + v.texelHeight : '',
        v ? '#define CUBEUV_MAX_MIP ' + v.maxMip + '.0' : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoat ? '#define USE_CLEARCOAT' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.dispersion ? '#define USE_DISPERSION' : '',
        t.iridescence ? '#define USE_IRIDESCENCE' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaTest ? '#define USE_ALPHATEST' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.sheen ? '#define USE_SHEEN' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors || t.instancingColor || t.batchingColor ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.gradientMap ? '#define USE_GRADIENTMAP' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + d : '',
        t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        t.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        t.reverseDepthBuffer ? '#define USE_REVERSEDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        t.toneMapping !== Lo ? '#define TONE_MAPPING' : '',
        t.toneMapping !== Lo ? yn.tonemapping_pars_fragment : '',
        t.toneMapping !== Lo ? ZB('toneMapping', t.toneMapping) : '',
        t.dithering ? '#define DITHERING' : '',
        t.opaque ? '#define OPAQUE' : '',
        yn.colorspace_pars_fragment,
        jB('linearToOutputTexel', t.outputColorSpace),
        QB(),
        t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
        `
`,
      ].filter(lh).join(`
`))),
    (a = xy(a)),
    (a = VA(a, t)),
    (a = WA(a, t)),
    (u = xy(u)),
    (u = VA(u, t)),
    (u = WA(u, t)),
    (a = XA(a)),
    (u = XA(u)),
    t.isRawShaderMaterial !== !0 &&
      ((b = `#version 300 es
`),
      (E =
        [x, '#define attribute in', '#define varying out', '#define texture2D texture'].join(`
`) +
        `
` +
        E),
      (S =
        [
          '#define varying in',
          t.glslVersion === fy ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
          t.glslVersion === fy ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join(`
`) +
        `
` +
        S));
  const I = b + E + a,
    B = b + S + u,
    z = zA(i, i.VERTEX_SHADER, I),
    N = zA(i, i.FRAGMENT_SHADER, B);
  i.attachShader(C, z),
    i.attachShader(C, N),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(C, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(C, 0, 'position'),
    i.linkProgram(C);
  function G(V) {
    if (r.debug.checkShaderErrors) {
      const oe = i.getProgramInfoLog(C).trim(),
        ie = i.getShaderInfoLog(z).trim(),
        ce = i.getShaderInfoLog(N).trim();
      let xe = !0,
        de = !0;
      if (i.getProgramParameter(C, i.LINK_STATUS) === !1)
        if (((xe = !1), typeof r.debug.onShaderError == 'function'))
          r.debug.onShaderError(i, C, z, N);
        else {
          const Ce = GA(i, z, 'vertex'),
            X = GA(i, N, 'fragment');
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              i.getError() +
              ' - VALIDATE_STATUS ' +
              i.getProgramParameter(C, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              V.name +
              `
Material Type: ` +
              V.type +
              `

Program Info Log: ` +
              oe +
              `
` +
              Ce +
              `
` +
              X,
          );
        }
      else
        oe !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', oe)
          : (ie === '' || ce === '') && (de = !1);
      de &&
        (V.diagnostics = {
          runnable: xe,
          programLog: oe,
          vertexShader: { log: ie, prefix: E },
          fragmentShader: { log: ce, prefix: S },
        });
    }
    i.deleteShader(z), i.deleteShader(N), (k = new Ym(i, C)), (L = eP(i, C));
  }
  let k;
  this.getUniforms = function () {
    return k === void 0 && G(this), k;
  };
  let L;
  this.getAttributes = function () {
    return L === void 0 && G(this), L;
  };
  let D = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return D === !1 && (D = i.getProgramParameter(C, XB)), D;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this), i.deleteProgram(C), (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = JB++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = C),
    (this.vertexShader = z),
    (this.fragmentShader = N),
    this
  );
}
let dP = 0;
class hP {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      o = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(o) === !1 && (a.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new pP(e)), t.set(e, n)), n;
  }
}
class pP {
  constructor(e) {
    (this.id = dP++), (this.code = e), (this.usedTimes = 0);
  }
}
function mP(r, e, t, n, i, o, a) {
  const u = new ju(),
    d = new hP(),
    h = new Set(),
    m = [],
    g = i.logarithmicDepthBuffer,
    v = i.vertexTextures;
  let x = i.precision;
  const A = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  };
  function C(L) {
    return h.add(L), L === 0 ? 'uv' : `uv${L}`;
  }
  function E(L, D, V, oe, ie) {
    const ce = oe.fog,
      xe = ie.geometry,
      de = L.isMeshStandardMaterial ? oe.environment : null,
      Ce = (L.isMeshStandardMaterial ? t : e).get(L.envMap || de),
      X = Ce && Ce.mapping === Xf ? Ce.image.height : null,
      fe = A[L.type];
    L.precision !== null &&
      ((x = i.getMaxPrecision(L.precision)),
      x !== L.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          L.precision,
          'not supported, using',
          x,
          'instead.',
        ));
    const te = xe.morphAttributes.position || xe.morphAttributes.normal || xe.morphAttributes.color,
      Y = te !== void 0 ? te.length : 0;
    let ue = 0;
    xe.morphAttributes.position !== void 0 && (ue = 1),
      xe.morphAttributes.normal !== void 0 && (ue = 2),
      xe.morphAttributes.color !== void 0 && (ue = 3);
    let He, ge, De, Ie;
    if (fe) {
      const an = fo[fe];
      (He = an.vertexShader), (ge = an.fragmentShader);
    } else
      (He = L.vertexShader),
        (ge = L.fragmentShader),
        d.update(L),
        (De = d.getVertexShaderID(L)),
        (Ie = d.getFragmentShaderID(L));
    const Ue = r.getRenderTarget(),
      et = r.state.buffers.depth.getReversed(),
      Bt = ie.isInstancedMesh === !0,
      ht = ie.isBatchedMesh === !0,
      Jt = !!L.map,
      Ye = !!L.matcap,
      ke = !!Ce,
      j = !!L.aoMap,
      It = !!L.lightMap,
      qe = !!L.bumpMap,
      yt = !!L.normalMap,
      rt = !!L.displacementMap,
      Ht = !!L.emissiveMap,
      lt = !!L.metalnessMap,
      K = !!L.roughnessMap,
      H = L.anisotropy > 0,
      ve = L.clearcoat > 0,
      Le = L.dispersion > 0,
      We = L.iridescence > 0,
      ze = L.sheen > 0,
      Ct = L.transmission > 0,
      at = H && !!L.anisotropyMap,
      pt = ve && !!L.clearcoatMap,
      $t = ve && !!L.clearcoatNormalMap,
      Ze = ve && !!L.clearcoatRoughnessMap,
      wt = We && !!L.iridescenceMap,
      Ft = We && !!L.iridescenceThicknessMap,
      Rt = ze && !!L.sheenColorMap,
      St = ze && !!L.sheenRoughnessMap,
      re = !!L.specularMap,
      Re = !!L.specularColorMap,
      tt = !!L.specularIntensityMap,
      ne = Ct && !!L.transmissionMap,
      ye = Ct && !!L.thicknessMap,
      we = !!L.gradientMap,
      Oe = !!L.alphaMap,
      vt = L.alphaTest > 0,
      dt = !!L.alphaHash,
      Gt = !!L.extensions;
    let _n = Lo;
    L.toneMapped && (Ue === null || Ue.isXRRenderTarget === !0) && (_n = r.toneMapping);
    const Nn = {
      shaderID: fe,
      shaderType: L.type,
      shaderName: L.name,
      vertexShader: He,
      fragmentShader: ge,
      defines: L.defines,
      customVertexShaderID: De,
      customFragmentShaderID: Ie,
      isRawShaderMaterial: L.isRawShaderMaterial === !0,
      glslVersion: L.glslVersion,
      precision: x,
      batching: ht,
      batchingColor: ht && ie._colorsTexture !== null,
      instancing: Bt,
      instancingColor: Bt && ie.instanceColor !== null,
      instancingMorph: Bt && ie.morphTexture !== null,
      supportsVertexTextures: v,
      outputColorSpace:
        Ue === null ? r.outputColorSpace : Ue.isXRRenderTarget === !0 ? Ue.texture.colorSpace : zo,
      alphaToCoverage: !!L.alphaToCoverage,
      map: Jt,
      matcap: Ye,
      envMap: ke,
      envMapMode: ke && Ce.mapping,
      envMapCubeUVHeight: X,
      aoMap: j,
      lightMap: It,
      bumpMap: qe,
      normalMap: yt,
      displacementMap: v && rt,
      emissiveMap: Ht,
      normalMapObjectSpace: yt && L.normalMapType === cM,
      normalMapTangentSpace: yt && L.normalMapType === Il,
      metalnessMap: lt,
      roughnessMap: K,
      anisotropy: H,
      anisotropyMap: at,
      clearcoat: ve,
      clearcoatMap: pt,
      clearcoatNormalMap: $t,
      clearcoatRoughnessMap: Ze,
      dispersion: Le,
      iridescence: We,
      iridescenceMap: wt,
      iridescenceThicknessMap: Ft,
      sheen: ze,
      sheenColorMap: Rt,
      sheenRoughnessMap: St,
      specularMap: re,
      specularColorMap: Re,
      specularIntensityMap: tt,
      transmission: Ct,
      transmissionMap: ne,
      thicknessMap: ye,
      gradientMap: we,
      opaque: L.transparent === !1 && L.blending === Ju && L.alphaToCoverage === !1,
      alphaMap: Oe,
      alphaTest: vt,
      alphaHash: dt,
      combine: L.combine,
      mapUv: Jt && C(L.map.channel),
      aoMapUv: j && C(L.aoMap.channel),
      lightMapUv: It && C(L.lightMap.channel),
      bumpMapUv: qe && C(L.bumpMap.channel),
      normalMapUv: yt && C(L.normalMap.channel),
      displacementMapUv: rt && C(L.displacementMap.channel),
      emissiveMapUv: Ht && C(L.emissiveMap.channel),
      metalnessMapUv: lt && C(L.metalnessMap.channel),
      roughnessMapUv: K && C(L.roughnessMap.channel),
      anisotropyMapUv: at && C(L.anisotropyMap.channel),
      clearcoatMapUv: pt && C(L.clearcoatMap.channel),
      clearcoatNormalMapUv: $t && C(L.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ze && C(L.clearcoatRoughnessMap.channel),
      iridescenceMapUv: wt && C(L.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ft && C(L.iridescenceThicknessMap.channel),
      sheenColorMapUv: Rt && C(L.sheenColorMap.channel),
      sheenRoughnessMapUv: St && C(L.sheenRoughnessMap.channel),
      specularMapUv: re && C(L.specularMap.channel),
      specularColorMapUv: Re && C(L.specularColorMap.channel),
      specularIntensityMapUv: tt && C(L.specularIntensityMap.channel),
      transmissionMapUv: ne && C(L.transmissionMap.channel),
      thicknessMapUv: ye && C(L.thicknessMap.channel),
      alphaMapUv: Oe && C(L.alphaMap.channel),
      vertexTangents: !!xe.attributes.tangent && (yt || H),
      vertexColors: L.vertexColors,
      vertexAlphas:
        L.vertexColors === !0 && !!xe.attributes.color && xe.attributes.color.itemSize === 4,
      pointsUvs: ie.isPoints === !0 && !!xe.attributes.uv && (Jt || Oe),
      fog: !!ce,
      useFog: L.fog === !0,
      fogExp2: !!ce && ce.isFogExp2,
      flatShading: L.flatShading === !0,
      sizeAttenuation: L.sizeAttenuation === !0,
      logarithmicDepthBuffer: g,
      reverseDepthBuffer: et,
      skinning: ie.isSkinnedMesh === !0,
      morphTargets: xe.morphAttributes.position !== void 0,
      morphNormals: xe.morphAttributes.normal !== void 0,
      morphColors: xe.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: ue,
      numDirLights: D.directional.length,
      numPointLights: D.point.length,
      numSpotLights: D.spot.length,
      numSpotLightMaps: D.spotLightMap.length,
      numRectAreaLights: D.rectArea.length,
      numHemiLights: D.hemi.length,
      numDirLightShadows: D.directionalShadowMap.length,
      numPointLightShadows: D.pointShadowMap.length,
      numSpotLightShadows: D.spotShadowMap.length,
      numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps,
      numLightProbes: D.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: L.dithering,
      shadowMapEnabled: r.shadowMap.enabled && V.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: _n,
      decodeVideoTexture:
        Jt && L.map.isVideoTexture === !0 && bn.getTransfer(L.map.colorSpace) === zn,
      decodeVideoTextureEmissive:
        Ht &&
        L.emissiveMap.isVideoTexture === !0 &&
        bn.getTransfer(L.emissiveMap.colorSpace) === zn,
      premultipliedAlpha: L.premultipliedAlpha,
      doubleSided: L.side === gs,
      flipSided: L.side === Or,
      useDepthPacking: L.depthPacking >= 0,
      depthPacking: L.depthPacking || 0,
      index0AttributeName: L.index0AttributeName,
      extensionClipCullDistance:
        Gt && L.extensions.clipCullDistance === !0 && n.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((Gt && L.extensions.multiDraw === !0) || ht) && n.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: n.has('KHR_parallel_shader_compile'),
      customProgramCacheKey: L.customProgramCacheKey(),
    };
    return (
      (Nn.vertexUv1s = h.has(1)),
      (Nn.vertexUv2s = h.has(2)),
      (Nn.vertexUv3s = h.has(3)),
      h.clear(),
      Nn
    );
  }
  function S(L) {
    const D = [];
    if (
      (L.shaderID
        ? D.push(L.shaderID)
        : (D.push(L.customVertexShaderID), D.push(L.customFragmentShaderID)),
      L.defines !== void 0)
    )
      for (const V in L.defines) D.push(V), D.push(L.defines[V]);
    return (
      L.isRawShaderMaterial === !1 && (b(D, L), I(D, L), D.push(r.outputColorSpace)),
      D.push(L.customProgramCacheKey),
      D.join()
    );
  }
  function b(L, D) {
    L.push(D.precision),
      L.push(D.outputColorSpace),
      L.push(D.envMapMode),
      L.push(D.envMapCubeUVHeight),
      L.push(D.mapUv),
      L.push(D.alphaMapUv),
      L.push(D.lightMapUv),
      L.push(D.aoMapUv),
      L.push(D.bumpMapUv),
      L.push(D.normalMapUv),
      L.push(D.displacementMapUv),
      L.push(D.emissiveMapUv),
      L.push(D.metalnessMapUv),
      L.push(D.roughnessMapUv),
      L.push(D.anisotropyMapUv),
      L.push(D.clearcoatMapUv),
      L.push(D.clearcoatNormalMapUv),
      L.push(D.clearcoatRoughnessMapUv),
      L.push(D.iridescenceMapUv),
      L.push(D.iridescenceThicknessMapUv),
      L.push(D.sheenColorMapUv),
      L.push(D.sheenRoughnessMapUv),
      L.push(D.specularMapUv),
      L.push(D.specularColorMapUv),
      L.push(D.specularIntensityMapUv),
      L.push(D.transmissionMapUv),
      L.push(D.thicknessMapUv),
      L.push(D.combine),
      L.push(D.fogExp2),
      L.push(D.sizeAttenuation),
      L.push(D.morphTargetsCount),
      L.push(D.morphAttributeCount),
      L.push(D.numDirLights),
      L.push(D.numPointLights),
      L.push(D.numSpotLights),
      L.push(D.numSpotLightMaps),
      L.push(D.numHemiLights),
      L.push(D.numRectAreaLights),
      L.push(D.numDirLightShadows),
      L.push(D.numPointLightShadows),
      L.push(D.numSpotLightShadows),
      L.push(D.numSpotLightShadowsWithMaps),
      L.push(D.numLightProbes),
      L.push(D.shadowMapType),
      L.push(D.toneMapping),
      L.push(D.numClippingPlanes),
      L.push(D.numClipIntersection),
      L.push(D.depthPacking);
  }
  function I(L, D) {
    u.disableAll(),
      D.supportsVertexTextures && u.enable(0),
      D.instancing && u.enable(1),
      D.instancingColor && u.enable(2),
      D.instancingMorph && u.enable(3),
      D.matcap && u.enable(4),
      D.envMap && u.enable(5),
      D.normalMapObjectSpace && u.enable(6),
      D.normalMapTangentSpace && u.enable(7),
      D.clearcoat && u.enable(8),
      D.iridescence && u.enable(9),
      D.alphaTest && u.enable(10),
      D.vertexColors && u.enable(11),
      D.vertexAlphas && u.enable(12),
      D.vertexUv1s && u.enable(13),
      D.vertexUv2s && u.enable(14),
      D.vertexUv3s && u.enable(15),
      D.vertexTangents && u.enable(16),
      D.anisotropy && u.enable(17),
      D.alphaHash && u.enable(18),
      D.batching && u.enable(19),
      D.dispersion && u.enable(20),
      D.batchingColor && u.enable(21),
      L.push(u.mask),
      u.disableAll(),
      D.fog && u.enable(0),
      D.useFog && u.enable(1),
      D.flatShading && u.enable(2),
      D.logarithmicDepthBuffer && u.enable(3),
      D.reverseDepthBuffer && u.enable(4),
      D.skinning && u.enable(5),
      D.morphTargets && u.enable(6),
      D.morphNormals && u.enable(7),
      D.morphColors && u.enable(8),
      D.premultipliedAlpha && u.enable(9),
      D.shadowMapEnabled && u.enable(10),
      D.doubleSided && u.enable(11),
      D.flipSided && u.enable(12),
      D.useDepthPacking && u.enable(13),
      D.dithering && u.enable(14),
      D.transmission && u.enable(15),
      D.sheen && u.enable(16),
      D.opaque && u.enable(17),
      D.pointsUvs && u.enable(18),
      D.decodeVideoTexture && u.enable(19),
      D.decodeVideoTextureEmissive && u.enable(20),
      D.alphaToCoverage && u.enable(21),
      L.push(u.mask);
  }
  function B(L) {
    const D = A[L.type];
    let V;
    if (D) {
      const oe = fo[D];
      V = EM.clone(oe.uniforms);
    } else V = L.uniforms;
    return V;
  }
  function z(L, D) {
    let V;
    for (let oe = 0, ie = m.length; oe < ie; oe++) {
      const ce = m[oe];
      if (ce.cacheKey === D) {
        (V = ce), ++V.usedTimes;
        break;
      }
    }
    return V === void 0 && ((V = new fP(r, D, L, o)), m.push(V)), V;
  }
  function N(L) {
    if (--L.usedTimes === 0) {
      const D = m.indexOf(L);
      (m[D] = m[m.length - 1]), m.pop(), L.destroy();
    }
  }
  function G(L) {
    d.remove(L);
  }
  function k() {
    d.dispose();
  }
  return {
    getParameters: E,
    getProgramCacheKey: S,
    getUniforms: B,
    acquireProgram: z,
    releaseProgram: N,
    releaseShaderCache: G,
    programs: m,
    dispose: k,
  };
}
function gP() {
  let r = new WeakMap();
  function e(a) {
    return r.has(a);
  }
  function t(a) {
    let u = r.get(a);
    return u === void 0 && ((u = {}), r.set(a, u)), u;
  }
  function n(a) {
    r.delete(a);
  }
  function i(a, u, d) {
    r.get(a)[u] = d;
  }
  function o() {
    r = new WeakMap();
  }
  return { has: e, get: t, remove: n, update: i, dispose: o };
}
function vP(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.material.id !== e.material.id
    ? r.material.id - e.material.id
    : r.z !== e.z
    ? r.z - e.z
    : r.id - e.id;
}
function YA(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.z !== e.z
    ? e.z - r.z
    : r.id - e.id;
}
function KA() {
  const r = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function o() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function a(g, v, x, A, C, E) {
    let S = r[e];
    return (
      S === void 0
        ? ((S = {
            id: g.id,
            object: g,
            geometry: v,
            material: x,
            groupOrder: A,
            renderOrder: g.renderOrder,
            z: C,
            group: E,
          }),
          (r[e] = S))
        : ((S.id = g.id),
          (S.object = g),
          (S.geometry = v),
          (S.material = x),
          (S.groupOrder = A),
          (S.renderOrder = g.renderOrder),
          (S.z = C),
          (S.group = E)),
      e++,
      S
    );
  }
  function u(g, v, x, A, C, E) {
    const S = a(g, v, x, A, C, E);
    x.transmission > 0 ? n.push(S) : x.transparent === !0 ? i.push(S) : t.push(S);
  }
  function d(g, v, x, A, C, E) {
    const S = a(g, v, x, A, C, E);
    x.transmission > 0 ? n.unshift(S) : x.transparent === !0 ? i.unshift(S) : t.unshift(S);
  }
  function h(g, v) {
    t.length > 1 && t.sort(g || vP),
      n.length > 1 && n.sort(v || YA),
      i.length > 1 && i.sort(v || YA);
  }
  function m() {
    for (let g = e, v = r.length; g < v; g++) {
      const x = r[g];
      if (x.id === null) break;
      (x.id = null), (x.object = null), (x.geometry = null), (x.material = null), (x.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: o,
    push: u,
    unshift: d,
    finish: m,
    sort: h,
  };
}
function yP() {
  let r = new WeakMap();
  function e(n, i) {
    const o = r.get(n);
    let a;
    return (
      o === void 0
        ? ((a = new KA()), r.set(n, [a]))
        : i >= o.length
        ? ((a = new KA()), o.push(a))
        : (a = o[i]),
      a
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function _P() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = { direction: new J(), color: new At() };
          break;
        case 'SpotLight':
          t = {
            position: new J(),
            direction: new J(),
            color: new At(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case 'PointLight':
          t = { position: new J(), color: new At(), distance: 0, decay: 0 };
          break;
        case 'HemisphereLight':
          t = { direction: new J(), skyColor: new At(), groundColor: new At() };
          break;
        case 'RectAreaLight':
          t = { color: new At(), position: new J(), halfWidth: new J(), halfHeight: new J() };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
function xP() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case 'SpotLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case 'PointLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
let AP = 0;
function SP(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function MP(r) {
  const e = new _P(),
    t = xP(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let h = 0; h < 9; h++) n.probe.push(new J());
  const i = new J(),
    o = new Qt(),
    a = new Qt();
  function u(h) {
    let m = 0,
      g = 0,
      v = 0;
    for (let L = 0; L < 9; L++) n.probe[L].set(0, 0, 0);
    let x = 0,
      A = 0,
      C = 0,
      E = 0,
      S = 0,
      b = 0,
      I = 0,
      B = 0,
      z = 0,
      N = 0,
      G = 0;
    h.sort(SP);
    for (let L = 0, D = h.length; L < D; L++) {
      const V = h[L],
        oe = V.color,
        ie = V.intensity,
        ce = V.distance,
        xe = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
      if (V.isAmbientLight) (m += oe.r * ie), (g += oe.g * ie), (v += oe.b * ie);
      else if (V.isLightProbe) {
        for (let de = 0; de < 9; de++) n.probe[de].addScaledVector(V.sh.coefficients[de], ie);
        G++;
      } else if (V.isDirectionalLight) {
        const de = e.get(V);
        if ((de.color.copy(V.color).multiplyScalar(V.intensity), V.castShadow)) {
          const Ce = V.shadow,
            X = t.get(V);
          (X.shadowIntensity = Ce.intensity),
            (X.shadowBias = Ce.bias),
            (X.shadowNormalBias = Ce.normalBias),
            (X.shadowRadius = Ce.radius),
            (X.shadowMapSize = Ce.mapSize),
            (n.directionalShadow[x] = X),
            (n.directionalShadowMap[x] = xe),
            (n.directionalShadowMatrix[x] = V.shadow.matrix),
            b++;
        }
        (n.directional[x] = de), x++;
      } else if (V.isSpotLight) {
        const de = e.get(V);
        de.position.setFromMatrixPosition(V.matrixWorld),
          de.color.copy(oe).multiplyScalar(ie),
          (de.distance = ce),
          (de.coneCos = Math.cos(V.angle)),
          (de.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
          (de.decay = V.decay),
          (n.spot[C] = de);
        const Ce = V.shadow;
        if (
          (V.map && ((n.spotLightMap[z] = V.map), z++, Ce.updateMatrices(V), V.castShadow && N++),
          (n.spotLightMatrix[C] = Ce.matrix),
          V.castShadow)
        ) {
          const X = t.get(V);
          (X.shadowIntensity = Ce.intensity),
            (X.shadowBias = Ce.bias),
            (X.shadowNormalBias = Ce.normalBias),
            (X.shadowRadius = Ce.radius),
            (X.shadowMapSize = Ce.mapSize),
            (n.spotShadow[C] = X),
            (n.spotShadowMap[C] = xe),
            B++;
        }
        C++;
      } else if (V.isRectAreaLight) {
        const de = e.get(V);
        de.color.copy(oe).multiplyScalar(ie),
          de.halfWidth.set(V.width * 0.5, 0, 0),
          de.halfHeight.set(0, V.height * 0.5, 0),
          (n.rectArea[E] = de),
          E++;
      } else if (V.isPointLight) {
        const de = e.get(V);
        if (
          (de.color.copy(V.color).multiplyScalar(V.intensity),
          (de.distance = V.distance),
          (de.decay = V.decay),
          V.castShadow)
        ) {
          const Ce = V.shadow,
            X = t.get(V);
          (X.shadowIntensity = Ce.intensity),
            (X.shadowBias = Ce.bias),
            (X.shadowNormalBias = Ce.normalBias),
            (X.shadowRadius = Ce.radius),
            (X.shadowMapSize = Ce.mapSize),
            (X.shadowCameraNear = Ce.camera.near),
            (X.shadowCameraFar = Ce.camera.far),
            (n.pointShadow[A] = X),
            (n.pointShadowMap[A] = xe),
            (n.pointShadowMatrix[A] = V.shadow.matrix),
            I++;
        }
        (n.point[A] = de), A++;
      } else if (V.isHemisphereLight) {
        const de = e.get(V);
        de.skyColor.copy(V.color).multiplyScalar(ie),
          de.groundColor.copy(V.groundColor).multiplyScalar(ie),
          (n.hemi[S] = de),
          S++;
      }
    }
    E > 0 &&
      (r.has('OES_texture_float_linear') === !0
        ? ((n.rectAreaLTC1 = xt.LTC_FLOAT_1), (n.rectAreaLTC2 = xt.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = xt.LTC_HALF_1), (n.rectAreaLTC2 = xt.LTC_HALF_2))),
      (n.ambient[0] = m),
      (n.ambient[1] = g),
      (n.ambient[2] = v);
    const k = n.hash;
    (k.directionalLength !== x ||
      k.pointLength !== A ||
      k.spotLength !== C ||
      k.rectAreaLength !== E ||
      k.hemiLength !== S ||
      k.numDirectionalShadows !== b ||
      k.numPointShadows !== I ||
      k.numSpotShadows !== B ||
      k.numSpotMaps !== z ||
      k.numLightProbes !== G) &&
      ((n.directional.length = x),
      (n.spot.length = C),
      (n.rectArea.length = E),
      (n.point.length = A),
      (n.hemi.length = S),
      (n.directionalShadow.length = b),
      (n.directionalShadowMap.length = b),
      (n.pointShadow.length = I),
      (n.pointShadowMap.length = I),
      (n.spotShadow.length = B),
      (n.spotShadowMap.length = B),
      (n.directionalShadowMatrix.length = b),
      (n.pointShadowMatrix.length = I),
      (n.spotLightMatrix.length = B + z - N),
      (n.spotLightMap.length = z),
      (n.numSpotLightShadowsWithMaps = N),
      (n.numLightProbes = G),
      (k.directionalLength = x),
      (k.pointLength = A),
      (k.spotLength = C),
      (k.rectAreaLength = E),
      (k.hemiLength = S),
      (k.numDirectionalShadows = b),
      (k.numPointShadows = I),
      (k.numSpotShadows = B),
      (k.numSpotMaps = z),
      (k.numLightProbes = G),
      (n.version = AP++));
  }
  function d(h, m) {
    let g = 0,
      v = 0,
      x = 0,
      A = 0,
      C = 0;
    const E = m.matrixWorldInverse;
    for (let S = 0, b = h.length; S < b; S++) {
      const I = h[S];
      if (I.isDirectionalLight) {
        const B = n.directional[g];
        B.direction.setFromMatrixPosition(I.matrixWorld),
          i.setFromMatrixPosition(I.target.matrixWorld),
          B.direction.sub(i),
          B.direction.transformDirection(E),
          g++;
      } else if (I.isSpotLight) {
        const B = n.spot[x];
        B.position.setFromMatrixPosition(I.matrixWorld),
          B.position.applyMatrix4(E),
          B.direction.setFromMatrixPosition(I.matrixWorld),
          i.setFromMatrixPosition(I.target.matrixWorld),
          B.direction.sub(i),
          B.direction.transformDirection(E),
          x++;
      } else if (I.isRectAreaLight) {
        const B = n.rectArea[A];
        B.position.setFromMatrixPosition(I.matrixWorld),
          B.position.applyMatrix4(E),
          a.identity(),
          o.copy(I.matrixWorld),
          o.premultiply(E),
          a.extractRotation(o),
          B.halfWidth.set(I.width * 0.5, 0, 0),
          B.halfHeight.set(0, I.height * 0.5, 0),
          B.halfWidth.applyMatrix4(a),
          B.halfHeight.applyMatrix4(a),
          A++;
      } else if (I.isPointLight) {
        const B = n.point[v];
        B.position.setFromMatrixPosition(I.matrixWorld), B.position.applyMatrix4(E), v++;
      } else if (I.isHemisphereLight) {
        const B = n.hemi[C];
        B.direction.setFromMatrixPosition(I.matrixWorld), B.direction.transformDirection(E), C++;
      }
    }
  }
  return { setup: u, setupView: d, state: n };
}
function jA(r) {
  const e = new MP(r),
    t = [],
    n = [];
  function i(m) {
    (h.camera = m), (t.length = 0), (n.length = 0);
  }
  function o(m) {
    t.push(m);
  }
  function a(m) {
    n.push(m);
  }
  function u() {
    e.setup(t);
  }
  function d(m) {
    e.setupView(t, m);
  }
  const h = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return { init: i, state: h, setupLights: u, setupLightsView: d, pushLight: o, pushShadow: a };
}
function EP(r) {
  let e = new WeakMap();
  function t(i, o = 0) {
    const a = e.get(i);
    let u;
    return (
      a === void 0
        ? ((u = new jA(r)), e.set(i, [u]))
        : o >= a.length
        ? ((u = new jA(r)), a.push(u))
        : (u = a[o]),
      u
    );
  }
  function n() {
    e = new WeakMap();
  }
  return { get: t, dispose: n };
}
const wP = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  CP = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function TP(r, e, t) {
  let n = new Wh();
  const i = new Ge(),
    o = new Ge(),
    a = new Bn(),
    u = new e_({ depthPacking: uM }),
    d = new t_(),
    h = {},
    m = t.maxTextureSize,
    g = { [Uo]: Or, [Or]: Uo, [gs]: gs },
    v = new is({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ge() },
        radius: { value: 4 },
      },
      vertexShader: wP,
      fragmentShader: CP,
    }),
    x = v.clone();
  x.defines.HORIZONTAL_PASS = 1;
  const A = new hn();
  A.setAttribute('position', new Pn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const C = new oi(A, v),
    E = this;
  (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = Ug);
  let S = this.type;
  this.render = function (N, G, k) {
    if (E.enabled === !1 || (E.autoUpdate === !1 && E.needsUpdate === !1) || N.length === 0) return;
    const L = r.getRenderTarget(),
      D = r.getActiveCubeFace(),
      V = r.getActiveMipmapLevel(),
      oe = r.state;
    oe.setBlending(Do),
      oe.buffers.color.setClear(1, 1, 1, 1),
      oe.buffers.depth.setTest(!0),
      oe.setScissorTest(!1);
    const ie = S !== co && this.type === co,
      ce = S === co && this.type !== co;
    for (let xe = 0, de = N.length; xe < de; xe++) {
      const Ce = N[xe],
        X = Ce.shadow;
      if (X === void 0) {
        console.warn('THREE.WebGLShadowMap:', Ce, 'has no shadow.');
        continue;
      }
      if (X.autoUpdate === !1 && X.needsUpdate === !1) continue;
      i.copy(X.mapSize);
      const fe = X.getFrameExtents();
      if (
        (i.multiply(fe),
        o.copy(X.mapSize),
        (i.x > m || i.y > m) &&
          (i.x > m && ((o.x = Math.floor(m / fe.x)), (i.x = o.x * fe.x), (X.mapSize.x = o.x)),
          i.y > m && ((o.y = Math.floor(m / fe.y)), (i.y = o.y * fe.y), (X.mapSize.y = o.y))),
        X.map === null || ie === !0 || ce === !0)
      ) {
        const Y = this.type !== co ? { minFilter: Ki, magFilter: Ki } : {};
        X.map !== null && X.map.dispose(),
          (X.map = new Ls(i.x, i.y, Y)),
          (X.map.texture.name = Ce.name + '.shadowMap'),
          X.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(X.map), r.clear();
      const te = X.getViewportCount();
      for (let Y = 0; Y < te; Y++) {
        const ue = X.getViewport(Y);
        a.set(o.x * ue.x, o.y * ue.y, o.x * ue.z, o.y * ue.w),
          oe.viewport(a),
          X.updateMatrices(Ce, Y),
          (n = X.getFrustum()),
          B(G, k, X.camera, Ce, this.type);
      }
      X.isPointLightShadow !== !0 && this.type === co && b(X, k), (X.needsUpdate = !1);
    }
    (S = this.type), (E.needsUpdate = !1), r.setRenderTarget(L, D, V);
  };
  function b(N, G) {
    const k = e.update(C);
    v.defines.VSM_SAMPLES !== N.blurSamples &&
      ((v.defines.VSM_SAMPLES = N.blurSamples),
      (x.defines.VSM_SAMPLES = N.blurSamples),
      (v.needsUpdate = !0),
      (x.needsUpdate = !0)),
      N.mapPass === null && (N.mapPass = new Ls(i.x, i.y)),
      (v.uniforms.shadow_pass.value = N.map.texture),
      (v.uniforms.resolution.value = N.mapSize),
      (v.uniforms.radius.value = N.radius),
      r.setRenderTarget(N.mapPass),
      r.clear(),
      r.renderBufferDirect(G, null, k, v, C, null),
      (x.uniforms.shadow_pass.value = N.mapPass.texture),
      (x.uniforms.resolution.value = N.mapSize),
      (x.uniforms.radius.value = N.radius),
      r.setRenderTarget(N.map),
      r.clear(),
      r.renderBufferDirect(G, null, k, x, C, null);
  }
  function I(N, G, k, L) {
    let D = null;
    const V = k.isPointLight === !0 ? N.customDistanceMaterial : N.customDepthMaterial;
    if (V !== void 0) D = V;
    else if (
      ((D = k.isPointLight === !0 ? d : u),
      (r.localClippingEnabled &&
        G.clipShadows === !0 &&
        Array.isArray(G.clippingPlanes) &&
        G.clippingPlanes.length !== 0) ||
        (G.displacementMap && G.displacementScale !== 0) ||
        (G.alphaMap && G.alphaTest > 0) ||
        (G.map && G.alphaTest > 0))
    ) {
      const oe = D.uuid,
        ie = G.uuid;
      let ce = h[oe];
      ce === void 0 && ((ce = {}), (h[oe] = ce));
      let xe = ce[ie];
      xe === void 0 && ((xe = D.clone()), (ce[ie] = xe), G.addEventListener('dispose', z)),
        (D = xe);
    }
    if (
      ((D.visible = G.visible),
      (D.wireframe = G.wireframe),
      L === co
        ? (D.side = G.shadowSide !== null ? G.shadowSide : G.side)
        : (D.side = G.shadowSide !== null ? G.shadowSide : g[G.side]),
      (D.alphaMap = G.alphaMap),
      (D.alphaTest = G.alphaTest),
      (D.map = G.map),
      (D.clipShadows = G.clipShadows),
      (D.clippingPlanes = G.clippingPlanes),
      (D.clipIntersection = G.clipIntersection),
      (D.displacementMap = G.displacementMap),
      (D.displacementScale = G.displacementScale),
      (D.displacementBias = G.displacementBias),
      (D.wireframeLinewidth = G.wireframeLinewidth),
      (D.linewidth = G.linewidth),
      k.isPointLight === !0 && D.isMeshDistanceMaterial === !0)
    ) {
      const oe = r.properties.get(D);
      oe.light = k;
    }
    return D;
  }
  function B(N, G, k, L, D) {
    if (N.visible === !1) return;
    if (
      N.layers.test(G.layers) &&
      (N.isMesh || N.isLine || N.isPoints) &&
      (N.castShadow || (N.receiveShadow && D === co)) &&
      (!N.frustumCulled || n.intersectsObject(N))
    ) {
      N.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, N.matrixWorld);
      const ie = e.update(N),
        ce = N.material;
      if (Array.isArray(ce)) {
        const xe = ie.groups;
        for (let de = 0, Ce = xe.length; de < Ce; de++) {
          const X = xe[de],
            fe = ce[X.materialIndex];
          if (fe && fe.visible) {
            const te = I(N, fe, L, D);
            N.onBeforeShadow(r, N, G, k, ie, te, X),
              r.renderBufferDirect(k, null, ie, te, N, X),
              N.onAfterShadow(r, N, G, k, ie, te, X);
          }
        }
      } else if (ce.visible) {
        const xe = I(N, ce, L, D);
        N.onBeforeShadow(r, N, G, k, ie, xe, null),
          r.renderBufferDirect(k, null, ie, xe, N, null),
          N.onAfterShadow(r, N, G, k, ie, xe, null);
      }
    }
    const oe = N.children;
    for (let ie = 0, ce = oe.length; ie < ce; ie++) B(oe[ie], G, k, L, D);
  }
  function z(N) {
    N.target.removeEventListener('dispose', z);
    for (const k in h) {
      const L = h[k],
        D = N.target.uuid;
      D in L && (L[D].dispose(), delete L[D]);
    }
  }
}
const RP = { [Qm]: qm, [$m]: ng, [eg]: ig, [Qu]: tg, [qm]: Qm, [ng]: $m, [ig]: eg, [tg]: Qu };
function bP(r, e) {
  function t() {
    let ne = !1;
    const ye = new Bn();
    let we = null;
    const Oe = new Bn(0, 0, 0, 0);
    return {
      setMask: function (vt) {
        we !== vt && !ne && (r.colorMask(vt, vt, vt, vt), (we = vt));
      },
      setLocked: function (vt) {
        ne = vt;
      },
      setClear: function (vt, dt, Gt, _n, Nn) {
        Nn === !0 && ((vt *= _n), (dt *= _n), (Gt *= _n)),
          ye.set(vt, dt, Gt, _n),
          Oe.equals(ye) === !1 && (r.clearColor(vt, dt, Gt, _n), Oe.copy(ye));
      },
      reset: function () {
        (ne = !1), (we = null), Oe.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let ne = !1,
      ye = !1,
      we = null,
      Oe = null,
      vt = null;
    return {
      setReversed: function (dt) {
        if (ye !== dt) {
          const Gt = e.get('EXT_clip_control');
          ye
            ? Gt.clipControlEXT(Gt.LOWER_LEFT_EXT, Gt.ZERO_TO_ONE_EXT)
            : Gt.clipControlEXT(Gt.LOWER_LEFT_EXT, Gt.NEGATIVE_ONE_TO_ONE_EXT);
          const _n = vt;
          (vt = null), this.setClear(_n);
        }
        ye = dt;
      },
      getReversed: function () {
        return ye;
      },
      setTest: function (dt) {
        dt ? Ue(r.DEPTH_TEST) : et(r.DEPTH_TEST);
      },
      setMask: function (dt) {
        we !== dt && !ne && (r.depthMask(dt), (we = dt));
      },
      setFunc: function (dt) {
        if ((ye && (dt = RP[dt]), Oe !== dt)) {
          switch (dt) {
            case Qm:
              r.depthFunc(r.NEVER);
              break;
            case qm:
              r.depthFunc(r.ALWAYS);
              break;
            case $m:
              r.depthFunc(r.LESS);
              break;
            case Qu:
              r.depthFunc(r.LEQUAL);
              break;
            case eg:
              r.depthFunc(r.EQUAL);
              break;
            case tg:
              r.depthFunc(r.GEQUAL);
              break;
            case ng:
              r.depthFunc(r.GREATER);
              break;
            case ig:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          Oe = dt;
        }
      },
      setLocked: function (dt) {
        ne = dt;
      },
      setClear: function (dt) {
        vt !== dt && (ye && (dt = 1 - dt), r.clearDepth(dt), (vt = dt));
      },
      reset: function () {
        (ne = !1), (we = null), (Oe = null), (vt = null), (ye = !1);
      },
    };
  }
  function i() {
    let ne = !1,
      ye = null,
      we = null,
      Oe = null,
      vt = null,
      dt = null,
      Gt = null,
      _n = null,
      Nn = null;
    return {
      setTest: function (an) {
        ne || (an ? Ue(r.STENCIL_TEST) : et(r.STENCIL_TEST));
      },
      setMask: function (an) {
        ye !== an && !ne && (r.stencilMask(an), (ye = an));
      },
      setFunc: function (an, qn, ni) {
        (we !== an || Oe !== qn || vt !== ni) &&
          (r.stencilFunc(an, qn, ni), (we = an), (Oe = qn), (vt = ni));
      },
      setOp: function (an, qn, ni) {
        (dt !== an || Gt !== qn || _n !== ni) &&
          (r.stencilOp(an, qn, ni), (dt = an), (Gt = qn), (_n = ni));
      },
      setLocked: function (an) {
        ne = an;
      },
      setClear: function (an) {
        Nn !== an && (r.clearStencil(an), (Nn = an));
      },
      reset: function () {
        (ne = !1),
          (ye = null),
          (we = null),
          (Oe = null),
          (vt = null),
          (dt = null),
          (Gt = null),
          (_n = null),
          (Nn = null);
      },
    };
  }
  const o = new t(),
    a = new n(),
    u = new i(),
    d = new WeakMap(),
    h = new WeakMap();
  let m = {},
    g = {},
    v = new WeakMap(),
    x = [],
    A = null,
    C = !1,
    E = null,
    S = null,
    b = null,
    I = null,
    B = null,
    z = null,
    N = null,
    G = new At(0, 0, 0),
    k = 0,
    L = !1,
    D = null,
    V = null,
    oe = null,
    ie = null,
    ce = null;
  const xe = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let de = !1,
    Ce = 0;
  const X = r.getParameter(r.VERSION);
  X.indexOf('WebGL') !== -1
    ? ((Ce = parseFloat(/^WebGL (\d)/.exec(X)[1])), (de = Ce >= 1))
    : X.indexOf('OpenGL ES') !== -1 &&
      ((Ce = parseFloat(/^OpenGL ES (\d)/.exec(X)[1])), (de = Ce >= 2));
  let fe = null,
    te = {};
  const Y = r.getParameter(r.SCISSOR_BOX),
    ue = r.getParameter(r.VIEWPORT),
    He = new Bn().fromArray(Y),
    ge = new Bn().fromArray(ue);
  function De(ne, ye, we, Oe) {
    const vt = new Uint8Array(4),
      dt = r.createTexture();
    r.bindTexture(ne, dt),
      r.texParameteri(ne, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(ne, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Gt = 0; Gt < we; Gt++)
      ne === r.TEXTURE_3D || ne === r.TEXTURE_2D_ARRAY
        ? r.texImage3D(ye, 0, r.RGBA, 1, 1, Oe, 0, r.RGBA, r.UNSIGNED_BYTE, vt)
        : r.texImage2D(ye + Gt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, vt);
    return dt;
  }
  const Ie = {};
  (Ie[r.TEXTURE_2D] = De(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (Ie[r.TEXTURE_CUBE_MAP] = De(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
    (Ie[r.TEXTURE_2D_ARRAY] = De(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1)),
    (Ie[r.TEXTURE_3D] = De(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)),
    o.setClear(0, 0, 0, 1),
    a.setClear(1),
    u.setClear(0),
    Ue(r.DEPTH_TEST),
    a.setFunc(Qu),
    qe(!1),
    yt(ry),
    Ue(r.CULL_FACE),
    j(Do);
  function Ue(ne) {
    m[ne] !== !0 && (r.enable(ne), (m[ne] = !0));
  }
  function et(ne) {
    m[ne] !== !1 && (r.disable(ne), (m[ne] = !1));
  }
  function Bt(ne, ye) {
    return g[ne] !== ye
      ? (r.bindFramebuffer(ne, ye),
        (g[ne] = ye),
        ne === r.DRAW_FRAMEBUFFER && (g[r.FRAMEBUFFER] = ye),
        ne === r.FRAMEBUFFER && (g[r.DRAW_FRAMEBUFFER] = ye),
        !0)
      : !1;
  }
  function ht(ne, ye) {
    let we = x,
      Oe = !1;
    if (ne) {
      (we = v.get(ye)), we === void 0 && ((we = []), v.set(ye, we));
      const vt = ne.textures;
      if (we.length !== vt.length || we[0] !== r.COLOR_ATTACHMENT0) {
        for (let dt = 0, Gt = vt.length; dt < Gt; dt++) we[dt] = r.COLOR_ATTACHMENT0 + dt;
        (we.length = vt.length), (Oe = !0);
      }
    } else we[0] !== r.BACK && ((we[0] = r.BACK), (Oe = !0));
    Oe && r.drawBuffers(we);
  }
  function Jt(ne) {
    return A !== ne ? (r.useProgram(ne), (A = ne), !0) : !1;
  }
  const Ye = { [Ml]: r.FUNC_ADD, [PS]: r.FUNC_SUBTRACT, [DS]: r.FUNC_REVERSE_SUBTRACT };
  (Ye[LS] = r.MIN), (Ye[FS] = r.MAX);
  const ke = {
    [NS]: r.ZERO,
    [US]: r.ONE,
    [OS]: r.SRC_COLOR,
    [jm]: r.SRC_ALPHA,
    [WS]: r.SRC_ALPHA_SATURATE,
    [GS]: r.DST_COLOR,
    [zS]: r.DST_ALPHA,
    [kS]: r.ONE_MINUS_SRC_COLOR,
    [Zm]: r.ONE_MINUS_SRC_ALPHA,
    [VS]: r.ONE_MINUS_DST_COLOR,
    [HS]: r.ONE_MINUS_DST_ALPHA,
    [XS]: r.CONSTANT_COLOR,
    [JS]: r.ONE_MINUS_CONSTANT_COLOR,
    [YS]: r.CONSTANT_ALPHA,
    [KS]: r.ONE_MINUS_CONSTANT_ALPHA,
  };
  function j(ne, ye, we, Oe, vt, dt, Gt, _n, Nn, an) {
    if (ne === Do) {
      C === !0 && (et(r.BLEND), (C = !1));
      return;
    }
    if ((C === !1 && (Ue(r.BLEND), (C = !0)), ne !== BS)) {
      if (ne !== E || an !== L) {
        if (((S !== Ml || B !== Ml) && (r.blendEquation(r.FUNC_ADD), (S = Ml), (B = Ml)), an))
          switch (ne) {
            case Ju:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case sy:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case oy:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case ay:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', ne);
              break;
          }
        else
          switch (ne) {
            case Ju:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case sy:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case oy:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case ay:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', ne);
              break;
          }
        (b = null), (I = null), (z = null), (N = null), G.set(0, 0, 0), (k = 0), (E = ne), (L = an);
      }
      return;
    }
    (vt = vt || ye),
      (dt = dt || we),
      (Gt = Gt || Oe),
      (ye !== S || vt !== B) && (r.blendEquationSeparate(Ye[ye], Ye[vt]), (S = ye), (B = vt)),
      (we !== b || Oe !== I || dt !== z || Gt !== N) &&
        (r.blendFuncSeparate(ke[we], ke[Oe], ke[dt], ke[Gt]),
        (b = we),
        (I = Oe),
        (z = dt),
        (N = Gt)),
      (_n.equals(G) === !1 || Nn !== k) &&
        (r.blendColor(_n.r, _n.g, _n.b, Nn), G.copy(_n), (k = Nn)),
      (E = ne),
      (L = !1);
  }
  function It(ne, ye) {
    ne.side === gs ? et(r.CULL_FACE) : Ue(r.CULL_FACE);
    let we = ne.side === Or;
    ye && (we = !we),
      qe(we),
      ne.blending === Ju && ne.transparent === !1
        ? j(Do)
        : j(
            ne.blending,
            ne.blendEquation,
            ne.blendSrc,
            ne.blendDst,
            ne.blendEquationAlpha,
            ne.blendSrcAlpha,
            ne.blendDstAlpha,
            ne.blendColor,
            ne.blendAlpha,
            ne.premultipliedAlpha,
          ),
      a.setFunc(ne.depthFunc),
      a.setTest(ne.depthTest),
      a.setMask(ne.depthWrite),
      o.setMask(ne.colorWrite);
    const Oe = ne.stencilWrite;
    u.setTest(Oe),
      Oe &&
        (u.setMask(ne.stencilWriteMask),
        u.setFunc(ne.stencilFunc, ne.stencilRef, ne.stencilFuncMask),
        u.setOp(ne.stencilFail, ne.stencilZFail, ne.stencilZPass)),
      Ht(ne.polygonOffset, ne.polygonOffsetFactor, ne.polygonOffsetUnits),
      ne.alphaToCoverage === !0 ? Ue(r.SAMPLE_ALPHA_TO_COVERAGE) : et(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function qe(ne) {
    D !== ne && (ne ? r.frontFace(r.CW) : r.frontFace(r.CCW), (D = ne));
  }
  function yt(ne) {
    ne !== RS
      ? (Ue(r.CULL_FACE),
        ne !== V &&
          (ne === ry
            ? r.cullFace(r.BACK)
            : ne === bS
            ? r.cullFace(r.FRONT)
            : r.cullFace(r.FRONT_AND_BACK)))
      : et(r.CULL_FACE),
      (V = ne);
  }
  function rt(ne) {
    ne !== oe && (de && r.lineWidth(ne), (oe = ne));
  }
  function Ht(ne, ye, we) {
    ne
      ? (Ue(r.POLYGON_OFFSET_FILL),
        (ie !== ye || ce !== we) && (r.polygonOffset(ye, we), (ie = ye), (ce = we)))
      : et(r.POLYGON_OFFSET_FILL);
  }
  function lt(ne) {
    ne ? Ue(r.SCISSOR_TEST) : et(r.SCISSOR_TEST);
  }
  function K(ne) {
    ne === void 0 && (ne = r.TEXTURE0 + xe - 1), fe !== ne && (r.activeTexture(ne), (fe = ne));
  }
  function H(ne, ye, we) {
    we === void 0 && (fe === null ? (we = r.TEXTURE0 + xe - 1) : (we = fe));
    let Oe = te[we];
    Oe === void 0 && ((Oe = { type: void 0, texture: void 0 }), (te[we] = Oe)),
      (Oe.type !== ne || Oe.texture !== ye) &&
        (fe !== we && (r.activeTexture(we), (fe = we)),
        r.bindTexture(ne, ye || Ie[ne]),
        (Oe.type = ne),
        (Oe.texture = ye));
  }
  function ve() {
    const ne = te[fe];
    ne !== void 0 &&
      ne.type !== void 0 &&
      (r.bindTexture(ne.type, null), (ne.type = void 0), (ne.texture = void 0));
  }
  function Le() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function We() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function ze() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function Ct() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function at() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function pt() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function $t() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function Ze() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function wt() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function Ft() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (ne) {
      console.error('THREE.WebGLState:', ne);
    }
  }
  function Rt(ne) {
    He.equals(ne) === !1 && (r.scissor(ne.x, ne.y, ne.z, ne.w), He.copy(ne));
  }
  function St(ne) {
    ge.equals(ne) === !1 && (r.viewport(ne.x, ne.y, ne.z, ne.w), ge.copy(ne));
  }
  function re(ne, ye) {
    let we = h.get(ye);
    we === void 0 && ((we = new WeakMap()), h.set(ye, we));
    let Oe = we.get(ne);
    Oe === void 0 && ((Oe = r.getUniformBlockIndex(ye, ne.name)), we.set(ne, Oe));
  }
  function Re(ne, ye) {
    const Oe = h.get(ye).get(ne);
    d.get(ye) !== Oe && (r.uniformBlockBinding(ye, Oe, ne.__bindingPointIndex), d.set(ye, Oe));
  }
  function tt() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.blendColor(0, 0, 0, 0),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      a.setReversed(!1),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
      r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (m = {}),
      (fe = null),
      (te = {}),
      (g = {}),
      (v = new WeakMap()),
      (x = []),
      (A = null),
      (C = !1),
      (E = null),
      (S = null),
      (b = null),
      (I = null),
      (B = null),
      (z = null),
      (N = null),
      (G = new At(0, 0, 0)),
      (k = 0),
      (L = !1),
      (D = null),
      (V = null),
      (oe = null),
      (ie = null),
      (ce = null),
      He.set(0, 0, r.canvas.width, r.canvas.height),
      ge.set(0, 0, r.canvas.width, r.canvas.height),
      o.reset(),
      a.reset(),
      u.reset();
  }
  return {
    buffers: { color: o, depth: a, stencil: u },
    enable: Ue,
    disable: et,
    bindFramebuffer: Bt,
    drawBuffers: ht,
    useProgram: Jt,
    setBlending: j,
    setMaterial: It,
    setFlipSided: qe,
    setCullFace: yt,
    setLineWidth: rt,
    setPolygonOffset: Ht,
    setScissorTest: lt,
    activeTexture: K,
    bindTexture: H,
    unbindTexture: ve,
    compressedTexImage2D: Le,
    compressedTexImage3D: We,
    texImage2D: wt,
    texImage3D: Ft,
    updateUBOMapping: re,
    uniformBlockBinding: Re,
    texStorage2D: $t,
    texStorage3D: Ze,
    texSubImage2D: ze,
    texSubImage3D: Ct,
    compressedTexSubImage2D: at,
    compressedTexSubImage3D: pt,
    scissor: Rt,
    viewport: St,
    reset: tt,
  };
}
function IP(r, e, t, n, i, o, a) {
  const u = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    d = typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    h = new Ge(),
    m = new WeakMap();
  let g;
  const v = new WeakMap();
  let x = !1;
  try {
    x = typeof OffscreenCanvas < 'u' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch {}
  function A(K, H) {
    return x ? new OffscreenCanvas(K, H) : wh('canvas');
  }
  function C(K, H, ve) {
    let Le = 1;
    const We = lt(K);
    if (((We.width > ve || We.height > ve) && (Le = ve / Math.max(We.width, We.height)), Le < 1))
      if (
        (typeof HTMLImageElement < 'u' && K instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && K instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && K instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && K instanceof VideoFrame)
      ) {
        const ze = Math.floor(Le * We.width),
          Ct = Math.floor(Le * We.height);
        g === void 0 && (g = A(ze, Ct));
        const at = H ? A(ze, Ct) : g;
        return (
          (at.width = ze),
          (at.height = Ct),
          at.getContext('2d').drawImage(K, 0, 0, ze, Ct),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              We.width +
              'x' +
              We.height +
              ') to (' +
              ze +
              'x' +
              Ct +
              ').',
          ),
          at
        );
      } else
        return (
          'data' in K &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                We.width +
                'x' +
                We.height +
                ').',
            ),
          K
        );
    return K;
  }
  function E(K) {
    return K.generateMipmaps;
  }
  function S(K) {
    r.generateMipmap(K);
  }
  function b(K) {
    return K.isWebGLCubeRenderTarget
      ? r.TEXTURE_CUBE_MAP
      : K.isWebGL3DRenderTarget
      ? r.TEXTURE_3D
      : K.isWebGLArrayRenderTarget || K.isCompressedArrayTexture
      ? r.TEXTURE_2D_ARRAY
      : r.TEXTURE_2D;
  }
  function I(K, H, ve, Le, We = !1) {
    if (K !== null) {
      if (r[K] !== void 0) return r[K];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + K + "'",
      );
    }
    let ze = H;
    if (
      (H === r.RED &&
        (ve === r.FLOAT && (ze = r.R32F),
        ve === r.HALF_FLOAT && (ze = r.R16F),
        ve === r.UNSIGNED_BYTE && (ze = r.R8)),
      H === r.RED_INTEGER &&
        (ve === r.UNSIGNED_BYTE && (ze = r.R8UI),
        ve === r.UNSIGNED_SHORT && (ze = r.R16UI),
        ve === r.UNSIGNED_INT && (ze = r.R32UI),
        ve === r.BYTE && (ze = r.R8I),
        ve === r.SHORT && (ze = r.R16I),
        ve === r.INT && (ze = r.R32I)),
      H === r.RG &&
        (ve === r.FLOAT && (ze = r.RG32F),
        ve === r.HALF_FLOAT && (ze = r.RG16F),
        ve === r.UNSIGNED_BYTE && (ze = r.RG8)),
      H === r.RG_INTEGER &&
        (ve === r.UNSIGNED_BYTE && (ze = r.RG8UI),
        ve === r.UNSIGNED_SHORT && (ze = r.RG16UI),
        ve === r.UNSIGNED_INT && (ze = r.RG32UI),
        ve === r.BYTE && (ze = r.RG8I),
        ve === r.SHORT && (ze = r.RG16I),
        ve === r.INT && (ze = r.RG32I)),
      H === r.RGB_INTEGER &&
        (ve === r.UNSIGNED_BYTE && (ze = r.RGB8UI),
        ve === r.UNSIGNED_SHORT && (ze = r.RGB16UI),
        ve === r.UNSIGNED_INT && (ze = r.RGB32UI),
        ve === r.BYTE && (ze = r.RGB8I),
        ve === r.SHORT && (ze = r.RGB16I),
        ve === r.INT && (ze = r.RGB32I)),
      H === r.RGBA_INTEGER &&
        (ve === r.UNSIGNED_BYTE && (ze = r.RGBA8UI),
        ve === r.UNSIGNED_SHORT && (ze = r.RGBA16UI),
        ve === r.UNSIGNED_INT && (ze = r.RGBA32UI),
        ve === r.BYTE && (ze = r.RGBA8I),
        ve === r.SHORT && (ze = r.RGBA16I),
        ve === r.INT && (ze = r.RGBA32I)),
      H === r.RGB && ve === r.UNSIGNED_INT_5_9_9_9_REV && (ze = r.RGB9_E5),
      H === r.RGBA)
    ) {
      const Ct = We ? Sh : bn.getTransfer(Le);
      ve === r.FLOAT && (ze = r.RGBA32F),
        ve === r.HALF_FLOAT && (ze = r.RGBA16F),
        ve === r.UNSIGNED_BYTE && (ze = Ct === zn ? r.SRGB8_ALPHA8 : r.RGBA8),
        ve === r.UNSIGNED_SHORT_4_4_4_4 && (ze = r.RGBA4),
        ve === r.UNSIGNED_SHORT_5_5_5_1 && (ze = r.RGB5_A1);
    }
    return (
      (ze === r.R16F ||
        ze === r.R32F ||
        ze === r.RG16F ||
        ze === r.RG32F ||
        ze === r.RGBA16F ||
        ze === r.RGBA32F) &&
        e.get('EXT_color_buffer_float'),
      ze
    );
  }
  function B(K, H) {
    let ve;
    return (
      K
        ? H === null || H === ko || H === qu
          ? (ve = r.DEPTH24_STENCIL8)
          : H === fi
          ? (ve = r.DEPTH32F_STENCIL8)
          : H === Of &&
            ((ve = r.DEPTH24_STENCIL8),
            console.warn(
              'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.',
            ))
        : H === null || H === ko || H === qu
        ? (ve = r.DEPTH_COMPONENT24)
        : H === fi
        ? (ve = r.DEPTH_COMPONENT32F)
        : H === Of && (ve = r.DEPTH_COMPONENT16),
      ve
    );
  }
  function z(K, H) {
    return E(K) === !0 || (K.isFramebufferTexture && K.minFilter !== Ki && K.minFilter !== Fn)
      ? Math.log2(Math.max(H.width, H.height)) + 1
      : K.mipmaps !== void 0 && K.mipmaps.length > 0
      ? K.mipmaps.length
      : K.isCompressedTexture && Array.isArray(K.image)
      ? H.mipmaps.length
      : 1;
  }
  function N(K) {
    const H = K.target;
    H.removeEventListener('dispose', N), k(H), H.isVideoTexture && m.delete(H);
  }
  function G(K) {
    const H = K.target;
    H.removeEventListener('dispose', G), D(H);
  }
  function k(K) {
    const H = n.get(K);
    if (H.__webglInit === void 0) return;
    const ve = K.source,
      Le = v.get(ve);
    if (Le) {
      const We = Le[H.__cacheKey];
      We.usedTimes--, We.usedTimes === 0 && L(K), Object.keys(Le).length === 0 && v.delete(ve);
    }
    n.remove(K);
  }
  function L(K) {
    const H = n.get(K);
    r.deleteTexture(H.__webglTexture);
    const ve = K.source,
      Le = v.get(ve);
    delete Le[H.__cacheKey], a.memory.textures--;
  }
  function D(K) {
    const H = n.get(K);
    if (
      (K.depthTexture && (K.depthTexture.dispose(), n.remove(K.depthTexture)),
      K.isWebGLCubeRenderTarget)
    )
      for (let Le = 0; Le < 6; Le++) {
        if (Array.isArray(H.__webglFramebuffer[Le]))
          for (let We = 0; We < H.__webglFramebuffer[Le].length; We++)
            r.deleteFramebuffer(H.__webglFramebuffer[Le][We]);
        else r.deleteFramebuffer(H.__webglFramebuffer[Le]);
        H.__webglDepthbuffer && r.deleteRenderbuffer(H.__webglDepthbuffer[Le]);
      }
    else {
      if (Array.isArray(H.__webglFramebuffer))
        for (let Le = 0; Le < H.__webglFramebuffer.length; Le++)
          r.deleteFramebuffer(H.__webglFramebuffer[Le]);
      else r.deleteFramebuffer(H.__webglFramebuffer);
      if (
        (H.__webglDepthbuffer && r.deleteRenderbuffer(H.__webglDepthbuffer),
        H.__webglMultisampledFramebuffer && r.deleteFramebuffer(H.__webglMultisampledFramebuffer),
        H.__webglColorRenderbuffer)
      )
        for (let Le = 0; Le < H.__webglColorRenderbuffer.length; Le++)
          H.__webglColorRenderbuffer[Le] && r.deleteRenderbuffer(H.__webglColorRenderbuffer[Le]);
      H.__webglDepthRenderbuffer && r.deleteRenderbuffer(H.__webglDepthRenderbuffer);
    }
    const ve = K.textures;
    for (let Le = 0, We = ve.length; Le < We; Le++) {
      const ze = n.get(ve[Le]);
      ze.__webglTexture && (r.deleteTexture(ze.__webglTexture), a.memory.textures--),
        n.remove(ve[Le]);
    }
    n.remove(K);
  }
  let V = 0;
  function oe() {
    V = 0;
  }
  function ie() {
    const K = V;
    return (
      K >= i.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            K +
            ' texture units while this GPU supports only ' +
            i.maxTextures,
        ),
      (V += 1),
      K
    );
  }
  function ce(K) {
    const H = [];
    return (
      H.push(K.wrapS),
      H.push(K.wrapT),
      H.push(K.wrapR || 0),
      H.push(K.magFilter),
      H.push(K.minFilter),
      H.push(K.anisotropy),
      H.push(K.internalFormat),
      H.push(K.format),
      H.push(K.type),
      H.push(K.generateMipmaps),
      H.push(K.premultiplyAlpha),
      H.push(K.flipY),
      H.push(K.unpackAlignment),
      H.push(K.colorSpace),
      H.join()
    );
  }
  function xe(K, H) {
    const ve = n.get(K);
    if (
      (K.isVideoTexture && rt(K),
      K.isRenderTargetTexture === !1 && K.version > 0 && ve.__version !== K.version)
    ) {
      const Le = K.image;
      if (Le === null)
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
      else if (Le.complete === !1)
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      else {
        ge(ve, K, H);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, ve.__webglTexture, r.TEXTURE0 + H);
  }
  function de(K, H) {
    const ve = n.get(K);
    if (K.version > 0 && ve.__version !== K.version) {
      ge(ve, K, H);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, ve.__webglTexture, r.TEXTURE0 + H);
  }
  function Ce(K, H) {
    const ve = n.get(K);
    if (K.version > 0 && ve.__version !== K.version) {
      ge(ve, K, H);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, ve.__webglTexture, r.TEXTURE0 + H);
  }
  function X(K, H) {
    const ve = n.get(K);
    if (K.version > 0 && ve.__version !== K.version) {
      De(ve, K, H);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, ve.__webglTexture, r.TEXTURE0 + H);
  }
  const fe = { [Rl]: r.REPEAT, [Ai]: r.CLAMP_TO_EDGE, [Uf]: r.MIRRORED_REPEAT },
    te = {
      [Ki]: r.NEAREST,
      [Og]: r.NEAREST_MIPMAP_NEAREST,
      [Ou]: r.NEAREST_MIPMAP_LINEAR,
      [Fn]: r.LINEAR,
      [Pf]: r.LINEAR_MIPMAP_NEAREST,
      [Ds]: r.LINEAR_MIPMAP_LINEAR,
    },
    Y = {
      [fM]: r.NEVER,
      [vM]: r.ALWAYS,
      [dM]: r.LESS,
      [Uy]: r.LEQUAL,
      [hM]: r.EQUAL,
      [gM]: r.GEQUAL,
      [pM]: r.GREATER,
      [mM]: r.NOTEQUAL,
    };
  function ue(K, H) {
    if (
      (H.type === fi &&
        e.has('OES_texture_float_linear') === !1 &&
        (H.magFilter === Fn ||
          H.magFilter === Pf ||
          H.magFilter === Ou ||
          H.magFilter === Ds ||
          H.minFilter === Fn ||
          H.minFilter === Pf ||
          H.minFilter === Ou ||
          H.minFilter === Ds) &&
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.',
        ),
      r.texParameteri(K, r.TEXTURE_WRAP_S, fe[H.wrapS]),
      r.texParameteri(K, r.TEXTURE_WRAP_T, fe[H.wrapT]),
      (K === r.TEXTURE_3D || K === r.TEXTURE_2D_ARRAY) &&
        r.texParameteri(K, r.TEXTURE_WRAP_R, fe[H.wrapR]),
      r.texParameteri(K, r.TEXTURE_MAG_FILTER, te[H.magFilter]),
      r.texParameteri(K, r.TEXTURE_MIN_FILTER, te[H.minFilter]),
      H.compareFunction &&
        (r.texParameteri(K, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(K, r.TEXTURE_COMPARE_FUNC, Y[H.compareFunction])),
      e.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        H.magFilter === Ki ||
        (H.minFilter !== Ou && H.minFilter !== Ds) ||
        (H.type === fi && e.has('OES_texture_float_linear') === !1)
      )
        return;
      if (H.anisotropy > 1 || n.get(H).__currentAnisotropy) {
        const ve = e.get('EXT_texture_filter_anisotropic');
        r.texParameterf(
          K,
          ve.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(H.anisotropy, i.getMaxAnisotropy()),
        ),
          (n.get(H).__currentAnisotropy = H.anisotropy);
      }
    }
  }
  function He(K, H) {
    let ve = !1;
    K.__webglInit === void 0 && ((K.__webglInit = !0), H.addEventListener('dispose', N));
    const Le = H.source;
    let We = v.get(Le);
    We === void 0 && ((We = {}), v.set(Le, We));
    const ze = ce(H);
    if (ze !== K.__cacheKey) {
      We[ze] === void 0 &&
        ((We[ze] = { texture: r.createTexture(), usedTimes: 0 }), a.memory.textures++, (ve = !0)),
        We[ze].usedTimes++;
      const Ct = We[K.__cacheKey];
      Ct !== void 0 && (We[K.__cacheKey].usedTimes--, Ct.usedTimes === 0 && L(H)),
        (K.__cacheKey = ze),
        (K.__webglTexture = We[ze].texture);
    }
    return ve;
  }
  function ge(K, H, ve) {
    let Le = r.TEXTURE_2D;
    (H.isDataArrayTexture || H.isCompressedArrayTexture) && (Le = r.TEXTURE_2D_ARRAY),
      H.isData3DTexture && (Le = r.TEXTURE_3D);
    const We = He(K, H),
      ze = H.source;
    t.bindTexture(Le, K.__webglTexture, r.TEXTURE0 + ve);
    const Ct = n.get(ze);
    if (ze.version !== Ct.__version || We === !0) {
      t.activeTexture(r.TEXTURE0 + ve);
      const at = bn.getPrimaries(bn.workingColorSpace),
        pt = H.colorSpace === ba ? null : bn.getPrimaries(H.colorSpace),
        $t = H.colorSpace === ba || at === pt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, H.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, H.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, $t);
      let Ze = C(H.image, !1, i.maxTextureSize);
      Ze = Ht(H, Ze);
      const wt = o.convert(H.format, H.colorSpace),
        Ft = o.convert(H.type);
      let Rt = I(H.internalFormat, wt, Ft, H.colorSpace, H.isVideoTexture);
      ue(Le, H);
      let St;
      const re = H.mipmaps,
        Re = H.isVideoTexture !== !0,
        tt = Ct.__version === void 0 || We === !0,
        ne = ze.dataReady,
        ye = z(H, Ze);
      if (H.isDepthTexture)
        (Rt = B(H.format === $u, H.type)),
          tt &&
            (Re
              ? t.texStorage2D(r.TEXTURE_2D, 1, Rt, Ze.width, Ze.height)
              : t.texImage2D(r.TEXTURE_2D, 0, Rt, Ze.width, Ze.height, 0, wt, Ft, null));
      else if (H.isDataTexture)
        if (re.length > 0) {
          Re && tt && t.texStorage2D(r.TEXTURE_2D, ye, Rt, re[0].width, re[0].height);
          for (let we = 0, Oe = re.length; we < Oe; we++)
            (St = re[we]),
              Re
                ? ne &&
                  t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, St.width, St.height, wt, Ft, St.data)
                : t.texImage2D(r.TEXTURE_2D, we, Rt, St.width, St.height, 0, wt, Ft, St.data);
          H.generateMipmaps = !1;
        } else
          Re
            ? (tt && t.texStorage2D(r.TEXTURE_2D, ye, Rt, Ze.width, Ze.height),
              ne && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ze.width, Ze.height, wt, Ft, Ze.data))
            : t.texImage2D(r.TEXTURE_2D, 0, Rt, Ze.width, Ze.height, 0, wt, Ft, Ze.data);
      else if (H.isCompressedTexture)
        if (H.isCompressedArrayTexture) {
          Re &&
            tt &&
            t.texStorage3D(r.TEXTURE_2D_ARRAY, ye, Rt, re[0].width, re[0].height, Ze.depth);
          for (let we = 0, Oe = re.length; we < Oe; we++)
            if (((St = re[we]), H.format !== Si))
              if (wt !== null)
                if (Re) {
                  if (ne)
                    if (H.layerUpdates.size > 0) {
                      const vt = yy(St.width, St.height, H.format, H.type);
                      for (const dt of H.layerUpdates) {
                        const Gt = St.data.subarray(
                          (dt * vt) / St.data.BYTES_PER_ELEMENT,
                          ((dt + 1) * vt) / St.data.BYTES_PER_ELEMENT,
                        );
                        t.compressedTexSubImage3D(
                          r.TEXTURE_2D_ARRAY,
                          we,
                          0,
                          0,
                          dt,
                          St.width,
                          St.height,
                          1,
                          wt,
                          Gt,
                        );
                      }
                      H.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        we,
                        0,
                        0,
                        0,
                        St.width,
                        St.height,
                        Ze.depth,
                        wt,
                        St.data,
                      );
                } else
                  t.compressedTexImage3D(
                    r.TEXTURE_2D_ARRAY,
                    we,
                    Rt,
                    St.width,
                    St.height,
                    Ze.depth,
                    0,
                    St.data,
                    0,
                    0,
                  );
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                );
            else
              Re
                ? ne &&
                  t.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    we,
                    0,
                    0,
                    0,
                    St.width,
                    St.height,
                    Ze.depth,
                    wt,
                    Ft,
                    St.data,
                  )
                : t.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    we,
                    Rt,
                    St.width,
                    St.height,
                    Ze.depth,
                    0,
                    wt,
                    Ft,
                    St.data,
                  );
        } else {
          Re && tt && t.texStorage2D(r.TEXTURE_2D, ye, Rt, re[0].width, re[0].height);
          for (let we = 0, Oe = re.length; we < Oe; we++)
            (St = re[we]),
              H.format !== Si
                ? wt !== null
                  ? Re
                    ? ne &&
                      t.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        we,
                        0,
                        0,
                        St.width,
                        St.height,
                        wt,
                        St.data,
                      )
                    : t.compressedTexImage2D(r.TEXTURE_2D, we, Rt, St.width, St.height, 0, St.data)
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                    )
                : Re
                ? ne &&
                  t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, St.width, St.height, wt, Ft, St.data)
                : t.texImage2D(r.TEXTURE_2D, we, Rt, St.width, St.height, 0, wt, Ft, St.data);
        }
      else if (H.isDataArrayTexture)
        if (Re) {
          if ((tt && t.texStorage3D(r.TEXTURE_2D_ARRAY, ye, Rt, Ze.width, Ze.height, Ze.depth), ne))
            if (H.layerUpdates.size > 0) {
              const we = yy(Ze.width, Ze.height, H.format, H.type);
              for (const Oe of H.layerUpdates) {
                const vt = Ze.data.subarray(
                  (Oe * we) / Ze.data.BYTES_PER_ELEMENT,
                  ((Oe + 1) * we) / Ze.data.BYTES_PER_ELEMENT,
                );
                t.texSubImage3D(
                  r.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  Oe,
                  Ze.width,
                  Ze.height,
                  1,
                  wt,
                  Ft,
                  vt,
                );
              }
              H.clearLayerUpdates();
            } else
              t.texSubImage3D(
                r.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ze.width,
                Ze.height,
                Ze.depth,
                wt,
                Ft,
                Ze.data,
              );
        } else
          t.texImage3D(
            r.TEXTURE_2D_ARRAY,
            0,
            Rt,
            Ze.width,
            Ze.height,
            Ze.depth,
            0,
            wt,
            Ft,
            Ze.data,
          );
      else if (H.isData3DTexture)
        Re
          ? (tt && t.texStorage3D(r.TEXTURE_3D, ye, Rt, Ze.width, Ze.height, Ze.depth),
            ne &&
              t.texSubImage3D(
                r.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ze.width,
                Ze.height,
                Ze.depth,
                wt,
                Ft,
                Ze.data,
              ))
          : t.texImage3D(r.TEXTURE_3D, 0, Rt, Ze.width, Ze.height, Ze.depth, 0, wt, Ft, Ze.data);
      else if (H.isFramebufferTexture) {
        if (tt)
          if (Re) t.texStorage2D(r.TEXTURE_2D, ye, Rt, Ze.width, Ze.height);
          else {
            let we = Ze.width,
              Oe = Ze.height;
            for (let vt = 0; vt < ye; vt++)
              t.texImage2D(r.TEXTURE_2D, vt, Rt, we, Oe, 0, wt, Ft, null), (we >>= 1), (Oe >>= 1);
          }
      } else if (re.length > 0) {
        if (Re && tt) {
          const we = lt(re[0]);
          t.texStorage2D(r.TEXTURE_2D, ye, Rt, we.width, we.height);
        }
        for (let we = 0, Oe = re.length; we < Oe; we++)
          (St = re[we]),
            Re
              ? ne && t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, wt, Ft, St)
              : t.texImage2D(r.TEXTURE_2D, we, Rt, wt, Ft, St);
        H.generateMipmaps = !1;
      } else if (Re) {
        if (tt) {
          const we = lt(Ze);
          t.texStorage2D(r.TEXTURE_2D, ye, Rt, we.width, we.height);
        }
        ne && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, wt, Ft, Ze);
      } else t.texImage2D(r.TEXTURE_2D, 0, Rt, wt, Ft, Ze);
      E(H) && S(Le), (Ct.__version = ze.version), H.onUpdate && H.onUpdate(H);
    }
    K.__version = H.version;
  }
  function De(K, H, ve) {
    if (H.image.length !== 6) return;
    const Le = He(K, H),
      We = H.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, K.__webglTexture, r.TEXTURE0 + ve);
    const ze = n.get(We);
    if (We.version !== ze.__version || Le === !0) {
      t.activeTexture(r.TEXTURE0 + ve);
      const Ct = bn.getPrimaries(bn.workingColorSpace),
        at = H.colorSpace === ba ? null : bn.getPrimaries(H.colorSpace),
        pt = H.colorSpace === ba || Ct === at ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, H.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, H.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, pt);
      const $t = H.isCompressedTexture || H.image[0].isCompressedTexture,
        Ze = H.image[0] && H.image[0].isDataTexture,
        wt = [];
      for (let Oe = 0; Oe < 6; Oe++)
        !$t && !Ze
          ? (wt[Oe] = C(H.image[Oe], !0, i.maxCubemapSize))
          : (wt[Oe] = Ze ? H.image[Oe].image : H.image[Oe]),
          (wt[Oe] = Ht(H, wt[Oe]));
      const Ft = wt[0],
        Rt = o.convert(H.format, H.colorSpace),
        St = o.convert(H.type),
        re = I(H.internalFormat, Rt, St, H.colorSpace),
        Re = H.isVideoTexture !== !0,
        tt = ze.__version === void 0 || Le === !0,
        ne = We.dataReady;
      let ye = z(H, Ft);
      ue(r.TEXTURE_CUBE_MAP, H);
      let we;
      if ($t) {
        Re && tt && t.texStorage2D(r.TEXTURE_CUBE_MAP, ye, re, Ft.width, Ft.height);
        for (let Oe = 0; Oe < 6; Oe++) {
          we = wt[Oe].mipmaps;
          for (let vt = 0; vt < we.length; vt++) {
            const dt = we[vt];
            H.format !== Si
              ? Rt !== null
                ? Re
                  ? ne &&
                    t.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                      vt,
                      0,
                      0,
                      dt.width,
                      dt.height,
                      Rt,
                      dt.data,
                    )
                  : t.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                      vt,
                      re,
                      dt.width,
                      dt.height,
                      0,
                      dt.data,
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                  )
              : Re
              ? ne &&
                t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                  vt,
                  0,
                  0,
                  dt.width,
                  dt.height,
                  Rt,
                  St,
                  dt.data,
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                  vt,
                  re,
                  dt.width,
                  dt.height,
                  0,
                  Rt,
                  St,
                  dt.data,
                );
          }
        }
      } else {
        if (((we = H.mipmaps), Re && tt)) {
          we.length > 0 && ye++;
          const Oe = lt(wt[0]);
          t.texStorage2D(r.TEXTURE_CUBE_MAP, ye, re, Oe.width, Oe.height);
        }
        for (let Oe = 0; Oe < 6; Oe++)
          if (Ze) {
            Re
              ? ne &&
                t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                  0,
                  0,
                  0,
                  wt[Oe].width,
                  wt[Oe].height,
                  Rt,
                  St,
                  wt[Oe].data,
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                  0,
                  re,
                  wt[Oe].width,
                  wt[Oe].height,
                  0,
                  Rt,
                  St,
                  wt[Oe].data,
                );
            for (let vt = 0; vt < we.length; vt++) {
              const Gt = we[vt].image[Oe].image;
              Re
                ? ne &&
                  t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                    vt + 1,
                    0,
                    0,
                    Gt.width,
                    Gt.height,
                    Rt,
                    St,
                    Gt.data,
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                    vt + 1,
                    re,
                    Gt.width,
                    Gt.height,
                    0,
                    Rt,
                    St,
                    Gt.data,
                  );
            }
          } else {
            Re
              ? ne && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, 0, 0, 0, Rt, St, wt[Oe])
              : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe, 0, re, Rt, St, wt[Oe]);
            for (let vt = 0; vt < we.length; vt++) {
              const dt = we[vt];
              Re
                ? ne &&
                  t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                    vt + 1,
                    0,
                    0,
                    Rt,
                    St,
                    dt.image[Oe],
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                    vt + 1,
                    re,
                    Rt,
                    St,
                    dt.image[Oe],
                  );
            }
          }
      }
      E(H) && S(r.TEXTURE_CUBE_MAP), (ze.__version = We.version), H.onUpdate && H.onUpdate(H);
    }
    K.__version = H.version;
  }
  function Ie(K, H, ve, Le, We, ze) {
    const Ct = o.convert(ve.format, ve.colorSpace),
      at = o.convert(ve.type),
      pt = I(ve.internalFormat, Ct, at, ve.colorSpace),
      $t = n.get(H),
      Ze = n.get(ve);
    if (((Ze.__renderTarget = H), !$t.__hasExternalTextures)) {
      const wt = Math.max(1, H.width >> ze),
        Ft = Math.max(1, H.height >> ze);
      We === r.TEXTURE_3D || We === r.TEXTURE_2D_ARRAY
        ? t.texImage3D(We, ze, pt, wt, Ft, H.depth, 0, Ct, at, null)
        : t.texImage2D(We, ze, pt, wt, Ft, 0, Ct, at, null);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, K),
      yt(H)
        ? u.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Le, We, Ze.__webglTexture, 0, qe(H))
        : (We === r.TEXTURE_2D ||
            (We >= r.TEXTURE_CUBE_MAP_POSITIVE_X && We <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(r.FRAMEBUFFER, Le, We, Ze.__webglTexture, ze),
      t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Ue(K, H, ve) {
    if ((r.bindRenderbuffer(r.RENDERBUFFER, K), H.depthBuffer)) {
      const Le = H.depthTexture,
        We = Le && Le.isDepthTexture ? Le.type : null,
        ze = B(H.stencilBuffer, We),
        Ct = H.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        at = qe(H);
      yt(H)
        ? u.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, at, ze, H.width, H.height)
        : ve
        ? r.renderbufferStorageMultisample(r.RENDERBUFFER, at, ze, H.width, H.height)
        : r.renderbufferStorage(r.RENDERBUFFER, ze, H.width, H.height),
        r.framebufferRenderbuffer(r.FRAMEBUFFER, Ct, r.RENDERBUFFER, K);
    } else {
      const Le = H.textures;
      for (let We = 0; We < Le.length; We++) {
        const ze = Le[We],
          Ct = o.convert(ze.format, ze.colorSpace),
          at = o.convert(ze.type),
          pt = I(ze.internalFormat, Ct, at, ze.colorSpace),
          $t = qe(H);
        ve && yt(H) === !1
          ? r.renderbufferStorageMultisample(r.RENDERBUFFER, $t, pt, H.width, H.height)
          : yt(H)
          ? u.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, $t, pt, H.width, H.height)
          : r.renderbufferStorage(r.RENDERBUFFER, pt, H.width, H.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function et(K, H) {
    if (H && H.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported');
    if ((t.bindFramebuffer(r.FRAMEBUFFER, K), !(H.depthTexture && H.depthTexture.isDepthTexture)))
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    const Le = n.get(H.depthTexture);
    (Le.__renderTarget = H),
      (!Le.__webglTexture ||
        H.depthTexture.image.width !== H.width ||
        H.depthTexture.image.height !== H.height) &&
        ((H.depthTexture.image.width = H.width),
        (H.depthTexture.image.height = H.height),
        (H.depthTexture.needsUpdate = !0)),
      xe(H.depthTexture, 0);
    const We = Le.__webglTexture,
      ze = qe(H);
    if (H.depthTexture.format === Yu)
      yt(H)
        ? u.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            We,
            0,
            ze,
          )
        : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, We, 0);
    else if (H.depthTexture.format === $u)
      yt(H)
        ? u.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            We,
            0,
            ze,
          )
        : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, We, 0);
    else throw new Error('Unknown depthTexture format');
  }
  function Bt(K) {
    const H = n.get(K),
      ve = K.isWebGLCubeRenderTarget === !0;
    if (H.__boundDepthTexture !== K.depthTexture) {
      const Le = K.depthTexture;
      if ((H.__depthDisposeCallback && H.__depthDisposeCallback(), Le)) {
        const We = () => {
          delete H.__boundDepthTexture,
            delete H.__depthDisposeCallback,
            Le.removeEventListener('dispose', We);
        };
        Le.addEventListener('dispose', We), (H.__depthDisposeCallback = We);
      }
      H.__boundDepthTexture = Le;
    }
    if (K.depthTexture && !H.__autoAllocateDepthBuffer) {
      if (ve) throw new Error('target.depthTexture not supported in Cube render targets');
      et(H.__webglFramebuffer, K);
    } else if (ve) {
      H.__webglDepthbuffer = [];
      for (let Le = 0; Le < 6; Le++)
        if (
          (t.bindFramebuffer(r.FRAMEBUFFER, H.__webglFramebuffer[Le]),
          H.__webglDepthbuffer[Le] === void 0)
        )
          (H.__webglDepthbuffer[Le] = r.createRenderbuffer()), Ue(H.__webglDepthbuffer[Le], K, !1);
        else {
          const We = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
            ze = H.__webglDepthbuffer[Le];
          r.bindRenderbuffer(r.RENDERBUFFER, ze),
            r.framebufferRenderbuffer(r.FRAMEBUFFER, We, r.RENDERBUFFER, ze);
        }
    } else if (
      (t.bindFramebuffer(r.FRAMEBUFFER, H.__webglFramebuffer), H.__webglDepthbuffer === void 0)
    )
      (H.__webglDepthbuffer = r.createRenderbuffer()), Ue(H.__webglDepthbuffer, K, !1);
    else {
      const Le = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        We = H.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, We),
        r.framebufferRenderbuffer(r.FRAMEBUFFER, Le, r.RENDERBUFFER, We);
    }
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function ht(K, H, ve) {
    const Le = n.get(K);
    H !== void 0 && Ie(Le.__webglFramebuffer, K, K.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0),
      ve !== void 0 && Bt(K);
  }
  function Jt(K) {
    const H = K.texture,
      ve = n.get(K),
      Le = n.get(H);
    K.addEventListener('dispose', G);
    const We = K.textures,
      ze = K.isWebGLCubeRenderTarget === !0,
      Ct = We.length > 1;
    if (
      (Ct ||
        (Le.__webglTexture === void 0 && (Le.__webglTexture = r.createTexture()),
        (Le.__version = H.version),
        a.memory.textures++),
      ze)
    ) {
      ve.__webglFramebuffer = [];
      for (let at = 0; at < 6; at++)
        if (H.mipmaps && H.mipmaps.length > 0) {
          ve.__webglFramebuffer[at] = [];
          for (let pt = 0; pt < H.mipmaps.length; pt++)
            ve.__webglFramebuffer[at][pt] = r.createFramebuffer();
        } else ve.__webglFramebuffer[at] = r.createFramebuffer();
    } else {
      if (H.mipmaps && H.mipmaps.length > 0) {
        ve.__webglFramebuffer = [];
        for (let at = 0; at < H.mipmaps.length; at++)
          ve.__webglFramebuffer[at] = r.createFramebuffer();
      } else ve.__webglFramebuffer = r.createFramebuffer();
      if (Ct)
        for (let at = 0, pt = We.length; at < pt; at++) {
          const $t = n.get(We[at]);
          $t.__webglTexture === void 0 &&
            (($t.__webglTexture = r.createTexture()), a.memory.textures++);
        }
      if (K.samples > 0 && yt(K) === !1) {
        (ve.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (ve.__webglColorRenderbuffer = []),
          t.bindFramebuffer(r.FRAMEBUFFER, ve.__webglMultisampledFramebuffer);
        for (let at = 0; at < We.length; at++) {
          const pt = We[at];
          (ve.__webglColorRenderbuffer[at] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, ve.__webglColorRenderbuffer[at]);
          const $t = o.convert(pt.format, pt.colorSpace),
            Ze = o.convert(pt.type),
            wt = I(pt.internalFormat, $t, Ze, pt.colorSpace, K.isXRRenderTarget === !0),
            Ft = qe(K);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, Ft, wt, K.width, K.height),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + at,
              r.RENDERBUFFER,
              ve.__webglColorRenderbuffer[at],
            );
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          K.depthBuffer &&
            ((ve.__webglDepthRenderbuffer = r.createRenderbuffer()),
            Ue(ve.__webglDepthRenderbuffer, K, !0)),
          t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (ze) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, Le.__webglTexture), ue(r.TEXTURE_CUBE_MAP, H);
      for (let at = 0; at < 6; at++)
        if (H.mipmaps && H.mipmaps.length > 0)
          for (let pt = 0; pt < H.mipmaps.length; pt++)
            Ie(
              ve.__webglFramebuffer[at][pt],
              K,
              H,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_CUBE_MAP_POSITIVE_X + at,
              pt,
            );
        else
          Ie(
            ve.__webglFramebuffer[at],
            K,
            H,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_CUBE_MAP_POSITIVE_X + at,
            0,
          );
      E(H) && S(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Ct) {
      for (let at = 0, pt = We.length; at < pt; at++) {
        const $t = We[at],
          Ze = n.get($t);
        t.bindTexture(r.TEXTURE_2D, Ze.__webglTexture),
          ue(r.TEXTURE_2D, $t),
          Ie(ve.__webglFramebuffer, K, $t, r.COLOR_ATTACHMENT0 + at, r.TEXTURE_2D, 0),
          E($t) && S(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let at = r.TEXTURE_2D;
      if (
        ((K.isWebGL3DRenderTarget || K.isWebGLArrayRenderTarget) &&
          (at = K.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
        t.bindTexture(at, Le.__webglTexture),
        ue(at, H),
        H.mipmaps && H.mipmaps.length > 0)
      )
        for (let pt = 0; pt < H.mipmaps.length; pt++)
          Ie(ve.__webglFramebuffer[pt], K, H, r.COLOR_ATTACHMENT0, at, pt);
      else Ie(ve.__webglFramebuffer, K, H, r.COLOR_ATTACHMENT0, at, 0);
      E(H) && S(at), t.unbindTexture();
    }
    K.depthBuffer && Bt(K);
  }
  function Ye(K) {
    const H = K.textures;
    for (let ve = 0, Le = H.length; ve < Le; ve++) {
      const We = H[ve];
      if (E(We)) {
        const ze = b(K),
          Ct = n.get(We).__webglTexture;
        t.bindTexture(ze, Ct), S(ze), t.unbindTexture();
      }
    }
  }
  const ke = [],
    j = [];
  function It(K) {
    if (K.samples > 0) {
      if (yt(K) === !1) {
        const H = K.textures,
          ve = K.width,
          Le = K.height;
        let We = r.COLOR_BUFFER_BIT;
        const ze = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
          Ct = n.get(K),
          at = H.length > 1;
        if (at)
          for (let pt = 0; pt < H.length; pt++)
            t.bindFramebuffer(r.FRAMEBUFFER, Ct.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + pt,
                r.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(r.FRAMEBUFFER, Ct.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + pt,
                r.TEXTURE_2D,
                null,
                0,
              );
        t.bindFramebuffer(r.READ_FRAMEBUFFER, Ct.__webglMultisampledFramebuffer),
          t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Ct.__webglFramebuffer);
        for (let pt = 0; pt < H.length; pt++) {
          if (
            (K.resolveDepthBuffer &&
              (K.depthBuffer && (We |= r.DEPTH_BUFFER_BIT),
              K.stencilBuffer && K.resolveStencilBuffer && (We |= r.STENCIL_BUFFER_BIT)),
            at)
          ) {
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              Ct.__webglColorRenderbuffer[pt],
            );
            const $t = n.get(H[pt]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, $t, 0);
          }
          r.blitFramebuffer(0, 0, ve, Le, 0, 0, ve, Le, We, r.NEAREST),
            d === !0 &&
              ((ke.length = 0),
              (j.length = 0),
              ke.push(r.COLOR_ATTACHMENT0 + pt),
              K.depthBuffer &&
                K.resolveDepthBuffer === !1 &&
                (ke.push(ze), j.push(ze), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, j)),
              r.invalidateFramebuffer(r.READ_FRAMEBUFFER, ke));
        }
        if (
          (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
          at)
        )
          for (let pt = 0; pt < H.length; pt++) {
            t.bindFramebuffer(r.FRAMEBUFFER, Ct.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + pt,
                r.RENDERBUFFER,
                Ct.__webglColorRenderbuffer[pt],
              );
            const $t = n.get(H[pt]).__webglTexture;
            t.bindFramebuffer(r.FRAMEBUFFER, Ct.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + pt,
                r.TEXTURE_2D,
                $t,
                0,
              );
          }
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Ct.__webglMultisampledFramebuffer);
      } else if (K.depthBuffer && K.resolveDepthBuffer === !1 && d) {
        const H = K.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [H]);
      }
    }
  }
  function qe(K) {
    return Math.min(i.maxSamples, K.samples);
  }
  function yt(K) {
    const H = n.get(K);
    return (
      K.samples > 0 &&
      e.has('WEBGL_multisampled_render_to_texture') === !0 &&
      H.__useRenderToTexture !== !1
    );
  }
  function rt(K) {
    const H = a.render.frame;
    m.get(K) !== H && (m.set(K, H), K.update());
  }
  function Ht(K, H) {
    const ve = K.colorSpace,
      Le = K.format,
      We = K.type;
    return (
      K.isCompressedTexture === !0 ||
        K.isVideoTexture === !0 ||
        (ve !== zo &&
          ve !== ba &&
          (bn.getTransfer(ve) === zn
            ? (Le !== Si || We !== ns) &&
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.',
              )
            : console.error('THREE.WebGLTextures: Unsupported texture color space:', ve))),
      H
    );
  }
  function lt(K) {
    return (
      typeof HTMLImageElement < 'u' && K instanceof HTMLImageElement
        ? ((h.width = K.naturalWidth || K.width), (h.height = K.naturalHeight || K.height))
        : typeof VideoFrame < 'u' && K instanceof VideoFrame
        ? ((h.width = K.displayWidth), (h.height = K.displayHeight))
        : ((h.width = K.width), (h.height = K.height)),
      h
    );
  }
  (this.allocateTextureUnit = ie),
    (this.resetTextureUnits = oe),
    (this.setTexture2D = xe),
    (this.setTexture2DArray = de),
    (this.setTexture3D = Ce),
    (this.setTextureCube = X),
    (this.rebindTextures = ht),
    (this.setupRenderTarget = Jt),
    (this.updateRenderTargetMipmap = Ye),
    (this.updateMultisampleRenderTarget = It),
    (this.setupDepthRenderbuffer = Bt),
    (this.setupFrameBufferTexture = Ie),
    (this.useMultisampledRTT = yt);
}
function xE(r, e) {
  function t(n, i = ba) {
    let o;
    const a = bn.getTransfer(i);
    if (n === ns) return r.UNSIGNED_BYTE;
    if (n === Hg) return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === Gg) return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === Ry) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === kg) return r.BYTE;
    if (n === zg) return r.SHORT;
    if (n === Of) return r.UNSIGNED_SHORT;
    if (n === Fh) return r.INT;
    if (n === ko) return r.UNSIGNED_INT;
    if (n === fi) return r.FLOAT;
    if (n === Yi) return r.HALF_FLOAT;
    if (n === by) return r.ALPHA;
    if (n === Iy) return r.RGB;
    if (n === Si) return r.RGBA;
    if (n === By) return r.LUMINANCE;
    if (n === Py) return r.LUMINANCE_ALPHA;
    if (n === Yu) return r.DEPTH_COMPONENT;
    if (n === $u) return r.DEPTH_STENCIL;
    if (n === Nh) return r.RED;
    if (n === Uh) return r.RED_INTEGER;
    if (n === Dy) return r.RG;
    if (n === Vg) return r.RG_INTEGER;
    if (n === Wg) return r.RGBA_INTEGER;
    if (n === fh || n === dh || n === hh || n === ph)
      if (a === zn)
        if (((o = e.get('WEBGL_compressed_texture_s3tc_srgb')), o !== null)) {
          if (n === fh) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === dh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === hh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === ph) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get('WEBGL_compressed_texture_s3tc')), o !== null)) {
        if (n === fh) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === dh) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === hh) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === ph) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (n === rg || n === sg || n === og || n === ag)
      if (((o = e.get('WEBGL_compressed_texture_pvrtc')), o !== null)) {
        if (n === rg) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === sg) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === og) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === ag) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (n === lg || n === ug || n === cg)
      if (((o = e.get('WEBGL_compressed_texture_etc')), o !== null)) {
        if (n === lg || n === ug)
          return a === zn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (n === cg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      n === fg ||
      n === dg ||
      n === hg ||
      n === pg ||
      n === mg ||
      n === gg ||
      n === vg ||
      n === yg ||
      n === _g ||
      n === xg ||
      n === Ag ||
      n === Sg ||
      n === Mg ||
      n === Eg
    )
      if (((o = e.get('WEBGL_compressed_texture_astc')), o !== null)) {
        if (n === fg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === dg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === hg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === pg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === mg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === gg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === vg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === yg)
          return a === zn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === _g)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === xg)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Ag)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Sg)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Mg)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Eg)
          return a === zn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (n === mh || n === wg || n === Cg)
      if (((o = e.get('EXT_texture_compression_bptc')), o !== null)) {
        if (n === mh)
          return a === zn
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === wg) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Cg) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (n === Ly || n === Tg || n === Rg || n === bg)
      if (((o = e.get('EXT_texture_compression_rgtc')), o !== null)) {
        if (n === mh) return o.COMPRESSED_RED_RGTC1_EXT;
        if (n === Tg) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Rg) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === bg) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return n === qu ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: t };
}
const BP = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  PP = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class DP {
  constructor() {
    (this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
  }
  init(e, t, n) {
    if (this.texture === null) {
      const i = new Ln(),
        o = e.properties.get(i);
      (o.__webglTexture = t.texture),
        (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        n = new is({
          vertexShader: BP,
          fragmentShader: PP,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new oi(new Pl(20, 20), n);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class LP extends Ho {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      o = 1,
      a = null,
      u = 'local-floor',
      d = 1,
      h = null,
      m = null,
      g = null,
      v = null,
      x = null,
      A = null;
    const C = new DP(),
      E = t.getContextAttributes();
    let S = null,
      b = null;
    const I = [],
      B = [],
      z = new Ge();
    let N = null;
    const G = new gi();
    G.viewport = new Bn();
    const k = new gi();
    k.viewport = new Bn();
    const L = [G, k],
      D = new cE();
    let V = null,
      oe = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ge) {
        let De = I[ge];
        return De === void 0 && ((De = new Jm()), (I[ge] = De)), De.getTargetRaySpace();
      }),
      (this.getControllerGrip = function (ge) {
        let De = I[ge];
        return De === void 0 && ((De = new Jm()), (I[ge] = De)), De.getGripSpace();
      }),
      (this.getHand = function (ge) {
        let De = I[ge];
        return De === void 0 && ((De = new Jm()), (I[ge] = De)), De.getHandSpace();
      });
    function ie(ge) {
      const De = B.indexOf(ge.inputSource);
      if (De === -1) return;
      const Ie = I[De];
      Ie !== void 0 &&
        (Ie.update(ge.inputSource, ge.frame, h || a),
        Ie.dispatchEvent({ type: ge.type, data: ge.inputSource }));
    }
    function ce() {
      i.removeEventListener('select', ie),
        i.removeEventListener('selectstart', ie),
        i.removeEventListener('selectend', ie),
        i.removeEventListener('squeeze', ie),
        i.removeEventListener('squeezestart', ie),
        i.removeEventListener('squeezeend', ie),
        i.removeEventListener('end', ce),
        i.removeEventListener('inputsourceschange', xe);
      for (let ge = 0; ge < I.length; ge++) {
        const De = B[ge];
        De !== null && ((B[ge] = null), I[ge].disconnect(De));
      }
      (V = null),
        (oe = null),
        C.reset(),
        e.setRenderTarget(S),
        (x = null),
        (v = null),
        (g = null),
        (i = null),
        (b = null),
        He.stop(),
        (n.isPresenting = !1),
        e.setPixelRatio(N),
        e.setSize(z.width, z.height, !1),
        n.dispatchEvent({ type: 'sessionend' });
    }
    (this.setFramebufferScaleFactor = function (ge) {
      (o = ge),
        n.isPresenting === !0 &&
          console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    }),
      (this.setReferenceSpaceType = function (ge) {
        (u = ge),
          n.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.',
            );
      }),
      (this.getReferenceSpace = function () {
        return h || a;
      }),
      (this.setReferenceSpace = function (ge) {
        h = ge;
      }),
      (this.getBaseLayer = function () {
        return v !== null ? v : x;
      }),
      (this.getBinding = function () {
        return g;
      }),
      (this.getFrame = function () {
        return A;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (ge) {
        if (((i = ge), i !== null)) {
          if (
            ((S = e.getRenderTarget()),
            i.addEventListener('select', ie),
            i.addEventListener('selectstart', ie),
            i.addEventListener('selectend', ie),
            i.addEventListener('squeeze', ie),
            i.addEventListener('squeezestart', ie),
            i.addEventListener('squeezeend', ie),
            i.addEventListener('end', ce),
            i.addEventListener('inputsourceschange', xe),
            E.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (N = e.getPixelRatio()),
            e.getSize(z),
            typeof XRWebGLBinding < 'u' && 'createProjectionLayer' in XRWebGLBinding.prototype)
          ) {
            let Ie = null,
              Ue = null,
              et = null;
            E.depth &&
              ((et = E.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Ie = E.stencil ? $u : Yu),
              (Ue = E.stencil ? qu : ko));
            const Bt = { colorFormat: t.RGBA8, depthFormat: et, scaleFactor: o };
            (g = new XRWebGLBinding(i, t)),
              (v = g.createProjectionLayer(Bt)),
              i.updateRenderState({ layers: [v] }),
              e.setPixelRatio(1),
              e.setSize(v.textureWidth, v.textureHeight, !1),
              (b = new Ls(v.textureWidth, v.textureHeight, {
                format: Si,
                type: ns,
                depthTexture: new Yy(
                  v.textureWidth,
                  v.textureHeight,
                  Ue,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Ie,
                ),
                stencilBuffer: E.stencil,
                colorSpace: e.outputColorSpace,
                samples: E.antialias ? 4 : 0,
                resolveDepthBuffer: v.ignoreDepthValues === !1,
              }));
          } else {
            const Ie = {
              antialias: E.antialias,
              alpha: !0,
              depth: E.depth,
              stencil: E.stencil,
              framebufferScaleFactor: o,
            };
            (x = new XRWebGLLayer(i, t, Ie)),
              i.updateRenderState({ baseLayer: x }),
              e.setPixelRatio(1),
              e.setSize(x.framebufferWidth, x.framebufferHeight, !1),
              (b = new Ls(x.framebufferWidth, x.framebufferHeight, {
                format: Si,
                type: ns,
                colorSpace: e.outputColorSpace,
                stencilBuffer: E.stencil,
              }));
          }
          (b.isXRRenderTarget = !0),
            this.setFoveation(d),
            (h = null),
            (a = await i.requestReferenceSpace(u)),
            He.setContext(i),
            He.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: 'sessionstart' });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return C.getDepthTexture();
      });
    function xe(ge) {
      for (let De = 0; De < ge.removed.length; De++) {
        const Ie = ge.removed[De],
          Ue = B.indexOf(Ie);
        Ue >= 0 && ((B[Ue] = null), I[Ue].disconnect(Ie));
      }
      for (let De = 0; De < ge.added.length; De++) {
        const Ie = ge.added[De];
        let Ue = B.indexOf(Ie);
        if (Ue === -1) {
          for (let Bt = 0; Bt < I.length; Bt++)
            if (Bt >= B.length) {
              B.push(Ie), (Ue = Bt);
              break;
            } else if (B[Bt] === null) {
              (B[Bt] = Ie), (Ue = Bt);
              break;
            }
          if (Ue === -1) break;
        }
        const et = I[Ue];
        et && et.connect(Ie);
      }
    }
    const de = new J(),
      Ce = new J();
    function X(ge, De, Ie) {
      de.setFromMatrixPosition(De.matrixWorld), Ce.setFromMatrixPosition(Ie.matrixWorld);
      const Ue = de.distanceTo(Ce),
        et = De.projectionMatrix.elements,
        Bt = Ie.projectionMatrix.elements,
        ht = et[14] / (et[10] - 1),
        Jt = et[14] / (et[10] + 1),
        Ye = (et[9] + 1) / et[5],
        ke = (et[9] - 1) / et[5],
        j = (et[8] - 1) / et[0],
        It = (Bt[8] + 1) / Bt[0],
        qe = ht * j,
        yt = ht * It,
        rt = Ue / (-j + It),
        Ht = rt * -j;
      if (
        (De.matrixWorld.decompose(ge.position, ge.quaternion, ge.scale),
        ge.translateX(Ht),
        ge.translateZ(rt),
        ge.matrixWorld.compose(ge.position, ge.quaternion, ge.scale),
        ge.matrixWorldInverse.copy(ge.matrixWorld).invert(),
        et[10] === -1)
      )
        ge.projectionMatrix.copy(De.projectionMatrix),
          ge.projectionMatrixInverse.copy(De.projectionMatrixInverse);
      else {
        const lt = ht + rt,
          K = Jt + rt,
          H = qe - Ht,
          ve = yt + (Ue - Ht),
          Le = ((Ye * Jt) / K) * lt,
          We = ((ke * Jt) / K) * lt;
        ge.projectionMatrix.makePerspective(H, ve, Le, We, lt, K),
          ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert();
      }
    }
    function fe(ge, De) {
      De === null
        ? ge.matrixWorld.copy(ge.matrix)
        : ge.matrixWorld.multiplyMatrices(De.matrixWorld, ge.matrix),
        ge.matrixWorldInverse.copy(ge.matrixWorld).invert();
    }
    this.updateCamera = function (ge) {
      if (i === null) return;
      let De = ge.near,
        Ie = ge.far;
      C.texture !== null &&
        (C.depthNear > 0 && (De = C.depthNear), C.depthFar > 0 && (Ie = C.depthFar)),
        (D.near = k.near = G.near = De),
        (D.far = k.far = G.far = Ie),
        (V !== D.near || oe !== D.far) &&
          (i.updateRenderState({ depthNear: D.near, depthFar: D.far }), (V = D.near), (oe = D.far)),
        (G.layers.mask = ge.layers.mask | 2),
        (k.layers.mask = ge.layers.mask | 4),
        (D.layers.mask = G.layers.mask | k.layers.mask);
      const Ue = ge.parent,
        et = D.cameras;
      fe(D, Ue);
      for (let Bt = 0; Bt < et.length; Bt++) fe(et[Bt], Ue);
      et.length === 2 ? X(D, G, k) : D.projectionMatrix.copy(G.projectionMatrix), te(ge, D, Ue);
    };
    function te(ge, De, Ie) {
      Ie === null
        ? ge.matrix.copy(De.matrixWorld)
        : (ge.matrix.copy(Ie.matrixWorld), ge.matrix.invert(), ge.matrix.multiply(De.matrixWorld)),
        ge.matrix.decompose(ge.position, ge.quaternion, ge.scale),
        ge.updateMatrixWorld(!0),
        ge.projectionMatrix.copy(De.projectionMatrix),
        ge.projectionMatrixInverse.copy(De.projectionMatrixInverse),
        ge.isPerspectiveCamera &&
          ((ge.fov = Hf * 2 * Math.atan(1 / ge.projectionMatrix.elements[5])), (ge.zoom = 1));
    }
    (this.getCamera = function () {
      return D;
    }),
      (this.getFoveation = function () {
        if (!(v === null && x === null)) return d;
      }),
      (this.setFoveation = function (ge) {
        (d = ge),
          v !== null && (v.fixedFoveation = ge),
          x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = ge);
      }),
      (this.hasDepthSensing = function () {
        return C.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return C.getMesh(D);
      });
    let Y = null;
    function ue(ge, De) {
      if (((m = De.getViewerPose(h || a)), (A = De), m !== null)) {
        const Ie = m.views;
        x !== null && (e.setRenderTargetFramebuffer(b, x.framebuffer), e.setRenderTarget(b));
        let Ue = !1;
        Ie.length !== D.cameras.length && ((D.cameras.length = 0), (Ue = !0));
        for (let ht = 0; ht < Ie.length; ht++) {
          const Jt = Ie[ht];
          let Ye = null;
          if (x !== null) Ye = x.getViewport(Jt);
          else {
            const j = g.getViewSubImage(v, Jt);
            (Ye = j.viewport),
              ht === 0 &&
                (e.setRenderTargetTextures(
                  b,
                  j.colorTexture,
                  v.ignoreDepthValues ? void 0 : j.depthStencilTexture,
                ),
                e.setRenderTarget(b));
          }
          let ke = L[ht];
          ke === void 0 &&
            ((ke = new gi()), ke.layers.enable(ht), (ke.viewport = new Bn()), (L[ht] = ke)),
            ke.matrix.fromArray(Jt.transform.matrix),
            ke.matrix.decompose(ke.position, ke.quaternion, ke.scale),
            ke.projectionMatrix.fromArray(Jt.projectionMatrix),
            ke.projectionMatrixInverse.copy(ke.projectionMatrix).invert(),
            ke.viewport.set(Ye.x, Ye.y, Ye.width, Ye.height),
            ht === 0 &&
              (D.matrix.copy(ke.matrix), D.matrix.decompose(D.position, D.quaternion, D.scale)),
            Ue === !0 && D.cameras.push(ke);
        }
        const et = i.enabledFeatures;
        if (et && et.includes('depth-sensing') && i.depthUsage == 'gpu-optimized' && g) {
          const ht = g.getDepthInformation(Ie[0]);
          ht && ht.isValid && ht.texture && C.init(e, ht, i.renderState);
        }
      }
      for (let Ie = 0; Ie < I.length; Ie++) {
        const Ue = B[Ie],
          et = I[Ie];
        Ue !== null && et !== void 0 && et.update(Ue, De, h || a);
      }
      Y && Y(ge, De),
        De.detectedPlanes && n.dispatchEvent({ type: 'planesdetected', data: De }),
        (A = null);
    }
    const He = new mE();
    He.setAnimationLoop(ue),
      (this.setAnimationLoop = function (ge) {
        Y = ge;
      }),
      (this.dispose = function () {});
  }
}
const Bu = new ys(),
  FP = new Qt();
function NP(r, e) {
  function t(E, S) {
    E.matrixAutoUpdate === !0 && E.updateMatrix(), S.value.copy(E.matrix);
  }
  function n(E, S) {
    S.color.getRGB(E.fogColor.value, MM(r)),
      S.isFog
        ? ((E.fogNear.value = S.near), (E.fogFar.value = S.far))
        : S.isFogExp2 && (E.fogDensity.value = S.density);
  }
  function i(E, S, b, I, B) {
    S.isMeshBasicMaterial || S.isMeshLambertMaterial
      ? o(E, S)
      : S.isMeshToonMaterial
      ? (o(E, S), g(E, S))
      : S.isMeshPhongMaterial
      ? (o(E, S), m(E, S))
      : S.isMeshStandardMaterial
      ? (o(E, S), v(E, S), S.isMeshPhysicalMaterial && x(E, S, B))
      : S.isMeshMatcapMaterial
      ? (o(E, S), A(E, S))
      : S.isMeshDepthMaterial
      ? o(E, S)
      : S.isMeshDistanceMaterial
      ? (o(E, S), C(E, S))
      : S.isMeshNormalMaterial
      ? o(E, S)
      : S.isLineBasicMaterial
      ? (a(E, S), S.isLineDashedMaterial && u(E, S))
      : S.isPointsMaterial
      ? d(E, S, b, I)
      : S.isSpriteMaterial
      ? h(E, S)
      : S.isShadowMaterial
      ? (E.color.value.copy(S.color), (E.opacity.value = S.opacity))
      : S.isShaderMaterial && (S.uniformsNeedUpdate = !1);
  }
  function o(E, S) {
    (E.opacity.value = S.opacity),
      S.color && E.diffuse.value.copy(S.color),
      S.emissive && E.emissive.value.copy(S.emissive).multiplyScalar(S.emissiveIntensity),
      S.map && ((E.map.value = S.map), t(S.map, E.mapTransform)),
      S.alphaMap && ((E.alphaMap.value = S.alphaMap), t(S.alphaMap, E.alphaMapTransform)),
      S.bumpMap &&
        ((E.bumpMap.value = S.bumpMap),
        t(S.bumpMap, E.bumpMapTransform),
        (E.bumpScale.value = S.bumpScale),
        S.side === Or && (E.bumpScale.value *= -1)),
      S.normalMap &&
        ((E.normalMap.value = S.normalMap),
        t(S.normalMap, E.normalMapTransform),
        E.normalScale.value.copy(S.normalScale),
        S.side === Or && E.normalScale.value.negate()),
      S.displacementMap &&
        ((E.displacementMap.value = S.displacementMap),
        t(S.displacementMap, E.displacementMapTransform),
        (E.displacementScale.value = S.displacementScale),
        (E.displacementBias.value = S.displacementBias)),
      S.emissiveMap &&
        ((E.emissiveMap.value = S.emissiveMap), t(S.emissiveMap, E.emissiveMapTransform)),
      S.specularMap &&
        ((E.specularMap.value = S.specularMap), t(S.specularMap, E.specularMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
    const b = e.get(S),
      I = b.envMap,
      B = b.envMapRotation;
    I &&
      ((E.envMap.value = I),
      Bu.copy(B),
      (Bu.x *= -1),
      (Bu.y *= -1),
      (Bu.z *= -1),
      I.isCubeTexture && I.isRenderTargetTexture === !1 && ((Bu.y *= -1), (Bu.z *= -1)),
      E.envMapRotation.value.setFromMatrix4(FP.makeRotationFromEuler(Bu)),
      (E.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1),
      (E.reflectivity.value = S.reflectivity),
      (E.ior.value = S.ior),
      (E.refractionRatio.value = S.refractionRatio)),
      S.lightMap &&
        ((E.lightMap.value = S.lightMap),
        (E.lightMapIntensity.value = S.lightMapIntensity),
        t(S.lightMap, E.lightMapTransform)),
      S.aoMap &&
        ((E.aoMap.value = S.aoMap),
        (E.aoMapIntensity.value = S.aoMapIntensity),
        t(S.aoMap, E.aoMapTransform));
  }
  function a(E, S) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      S.map && ((E.map.value = S.map), t(S.map, E.mapTransform));
  }
  function u(E, S) {
    (E.dashSize.value = S.dashSize),
      (E.totalSize.value = S.dashSize + S.gapSize),
      (E.scale.value = S.scale);
  }
  function d(E, S, b, I) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      (E.size.value = S.size * b),
      (E.scale.value = I * 0.5),
      S.map && ((E.map.value = S.map), t(S.map, E.uvTransform)),
      S.alphaMap && ((E.alphaMap.value = S.alphaMap), t(S.alphaMap, E.alphaMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
  }
  function h(E, S) {
    E.diffuse.value.copy(S.color),
      (E.opacity.value = S.opacity),
      (E.rotation.value = S.rotation),
      S.map && ((E.map.value = S.map), t(S.map, E.mapTransform)),
      S.alphaMap && ((E.alphaMap.value = S.alphaMap), t(S.alphaMap, E.alphaMapTransform)),
      S.alphaTest > 0 && (E.alphaTest.value = S.alphaTest);
  }
  function m(E, S) {
    E.specular.value.copy(S.specular), (E.shininess.value = Math.max(S.shininess, 1e-4));
  }
  function g(E, S) {
    S.gradientMap && (E.gradientMap.value = S.gradientMap);
  }
  function v(E, S) {
    (E.metalness.value = S.metalness),
      S.metalnessMap &&
        ((E.metalnessMap.value = S.metalnessMap), t(S.metalnessMap, E.metalnessMapTransform)),
      (E.roughness.value = S.roughness),
      S.roughnessMap &&
        ((E.roughnessMap.value = S.roughnessMap), t(S.roughnessMap, E.roughnessMapTransform)),
      S.envMap && (E.envMapIntensity.value = S.envMapIntensity);
  }
  function x(E, S, b) {
    (E.ior.value = S.ior),
      S.sheen > 0 &&
        (E.sheenColor.value.copy(S.sheenColor).multiplyScalar(S.sheen),
        (E.sheenRoughness.value = S.sheenRoughness),
        S.sheenColorMap &&
          ((E.sheenColorMap.value = S.sheenColorMap), t(S.sheenColorMap, E.sheenColorMapTransform)),
        S.sheenRoughnessMap &&
          ((E.sheenRoughnessMap.value = S.sheenRoughnessMap),
          t(S.sheenRoughnessMap, E.sheenRoughnessMapTransform))),
      S.clearcoat > 0 &&
        ((E.clearcoat.value = S.clearcoat),
        (E.clearcoatRoughness.value = S.clearcoatRoughness),
        S.clearcoatMap &&
          ((E.clearcoatMap.value = S.clearcoatMap), t(S.clearcoatMap, E.clearcoatMapTransform)),
        S.clearcoatRoughnessMap &&
          ((E.clearcoatRoughnessMap.value = S.clearcoatRoughnessMap),
          t(S.clearcoatRoughnessMap, E.clearcoatRoughnessMapTransform)),
        S.clearcoatNormalMap &&
          ((E.clearcoatNormalMap.value = S.clearcoatNormalMap),
          t(S.clearcoatNormalMap, E.clearcoatNormalMapTransform),
          E.clearcoatNormalScale.value.copy(S.clearcoatNormalScale),
          S.side === Or && E.clearcoatNormalScale.value.negate())),
      S.dispersion > 0 && (E.dispersion.value = S.dispersion),
      S.iridescence > 0 &&
        ((E.iridescence.value = S.iridescence),
        (E.iridescenceIOR.value = S.iridescenceIOR),
        (E.iridescenceThicknessMinimum.value = S.iridescenceThicknessRange[0]),
        (E.iridescenceThicknessMaximum.value = S.iridescenceThicknessRange[1]),
        S.iridescenceMap &&
          ((E.iridescenceMap.value = S.iridescenceMap),
          t(S.iridescenceMap, E.iridescenceMapTransform)),
        S.iridescenceThicknessMap &&
          ((E.iridescenceThicknessMap.value = S.iridescenceThicknessMap),
          t(S.iridescenceThicknessMap, E.iridescenceThicknessMapTransform))),
      S.transmission > 0 &&
        ((E.transmission.value = S.transmission),
        (E.transmissionSamplerMap.value = b.texture),
        E.transmissionSamplerSize.value.set(b.width, b.height),
        S.transmissionMap &&
          ((E.transmissionMap.value = S.transmissionMap),
          t(S.transmissionMap, E.transmissionMapTransform)),
        (E.thickness.value = S.thickness),
        S.thicknessMap &&
          ((E.thicknessMap.value = S.thicknessMap), t(S.thicknessMap, E.thicknessMapTransform)),
        (E.attenuationDistance.value = S.attenuationDistance),
        E.attenuationColor.value.copy(S.attenuationColor)),
      S.anisotropy > 0 &&
        (E.anisotropyVector.value.set(
          S.anisotropy * Math.cos(S.anisotropyRotation),
          S.anisotropy * Math.sin(S.anisotropyRotation),
        ),
        S.anisotropyMap &&
          ((E.anisotropyMap.value = S.anisotropyMap),
          t(S.anisotropyMap, E.anisotropyMapTransform))),
      (E.specularIntensity.value = S.specularIntensity),
      E.specularColor.value.copy(S.specularColor),
      S.specularColorMap &&
        ((E.specularColorMap.value = S.specularColorMap),
        t(S.specularColorMap, E.specularColorMapTransform)),
      S.specularIntensityMap &&
        ((E.specularIntensityMap.value = S.specularIntensityMap),
        t(S.specularIntensityMap, E.specularIntensityMapTransform));
  }
  function A(E, S) {
    S.matcap && (E.matcap.value = S.matcap);
  }
  function C(E, S) {
    const b = e.get(S).light;
    E.referencePosition.value.setFromMatrixPosition(b.matrixWorld),
      (E.nearDistance.value = b.shadow.camera.near),
      (E.farDistance.value = b.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function UP(r, e, t, n) {
  let i = {},
    o = {},
    a = [];
  const u = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function d(b, I) {
    const B = I.program;
    n.uniformBlockBinding(b, B);
  }
  function h(b, I) {
    let B = i[b.id];
    B === void 0 && (A(b), (B = m(b)), (i[b.id] = B), b.addEventListener('dispose', E));
    const z = I.program;
    n.updateUBOMapping(b, z);
    const N = e.render.frame;
    o[b.id] !== N && (v(b), (o[b.id] = N));
  }
  function m(b) {
    const I = g();
    b.__bindingPointIndex = I;
    const B = r.createBuffer(),
      z = b.__size,
      N = b.usage;
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, B),
      r.bufferData(r.UNIFORM_BUFFER, z, N),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, I, B),
      B
    );
  }
  function g() {
    for (let b = 0; b < u; b++) if (a.indexOf(b) === -1) return a.push(b), b;
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.',
      ),
      0
    );
  }
  function v(b) {
    const I = i[b.id],
      B = b.uniforms,
      z = b.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, I);
    for (let N = 0, G = B.length; N < G; N++) {
      const k = Array.isArray(B[N]) ? B[N] : [B[N]];
      for (let L = 0, D = k.length; L < D; L++) {
        const V = k[L];
        if (x(V, N, L, z) === !0) {
          const oe = V.__offset,
            ie = Array.isArray(V.value) ? V.value : [V.value];
          let ce = 0;
          for (let xe = 0; xe < ie.length; xe++) {
            const de = ie[xe],
              Ce = C(de);
            typeof de == 'number' || typeof de == 'boolean'
              ? ((V.__data[0] = de), r.bufferSubData(r.UNIFORM_BUFFER, oe + ce, V.__data))
              : de.isMatrix3
              ? ((V.__data[0] = de.elements[0]),
                (V.__data[1] = de.elements[1]),
                (V.__data[2] = de.elements[2]),
                (V.__data[3] = 0),
                (V.__data[4] = de.elements[3]),
                (V.__data[5] = de.elements[4]),
                (V.__data[6] = de.elements[5]),
                (V.__data[7] = 0),
                (V.__data[8] = de.elements[6]),
                (V.__data[9] = de.elements[7]),
                (V.__data[10] = de.elements[8]),
                (V.__data[11] = 0))
              : (de.toArray(V.__data, ce), (ce += Ce.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          r.bufferSubData(r.UNIFORM_BUFFER, oe, V.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function x(b, I, B, z) {
    const N = b.value,
      G = I + '_' + B;
    if (z[G] === void 0)
      return typeof N == 'number' || typeof N == 'boolean' ? (z[G] = N) : (z[G] = N.clone()), !0;
    {
      const k = z[G];
      if (typeof N == 'number' || typeof N == 'boolean') {
        if (k !== N) return (z[G] = N), !0;
      } else if (k.equals(N) === !1) return k.copy(N), !0;
    }
    return !1;
  }
  function A(b) {
    const I = b.uniforms;
    let B = 0;
    const z = 16;
    for (let G = 0, k = I.length; G < k; G++) {
      const L = Array.isArray(I[G]) ? I[G] : [I[G]];
      for (let D = 0, V = L.length; D < V; D++) {
        const oe = L[D],
          ie = Array.isArray(oe.value) ? oe.value : [oe.value];
        for (let ce = 0, xe = ie.length; ce < xe; ce++) {
          const de = ie[ce],
            Ce = C(de),
            X = B % z,
            fe = X % Ce.boundary,
            te = X + fe;
          (B += fe),
            te !== 0 && z - te < Ce.storage && (B += z - te),
            (oe.__data = new Float32Array(Ce.storage / Float32Array.BYTES_PER_ELEMENT)),
            (oe.__offset = B),
            (B += Ce.storage);
        }
      }
    }
    const N = B % z;
    return N > 0 && (B += z - N), (b.__size = B), (b.__cache = {}), this;
  }
  function C(b) {
    const I = { boundary: 0, storage: 0 };
    return (
      typeof b == 'number' || typeof b == 'boolean'
        ? ((I.boundary = 4), (I.storage = 4))
        : b.isVector2
        ? ((I.boundary = 8), (I.storage = 8))
        : b.isVector3 || b.isColor
        ? ((I.boundary = 16), (I.storage = 12))
        : b.isVector4
        ? ((I.boundary = 16), (I.storage = 16))
        : b.isMatrix3
        ? ((I.boundary = 48), (I.storage = 48))
        : b.isMatrix4
        ? ((I.boundary = 64), (I.storage = 64))
        : b.isTexture
        ? console.warn(
            'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.',
          )
        : console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', b),
      I
    );
  }
  function E(b) {
    const I = b.target;
    I.removeEventListener('dispose', E);
    const B = a.indexOf(I.__bindingPointIndex);
    a.splice(B, 1), r.deleteBuffer(i[I.id]), delete i[I.id], delete o[I.id];
  }
  function S() {
    for (const b in i) r.deleteBuffer(i[b]);
    (a = []), (i = {}), (o = {});
  }
  return { bind: d, update: h, dispose: S };
}
class y_ {
  constructor(e = {}) {
    const {
      canvas: t = xM(),
      context: n = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: u = !1,
      premultipliedAlpha: d = !0,
      preserveDrawingBuffer: h = !1,
      powerPreference: m = 'default',
      failIfMajorPerformanceCaveat: g = !1,
      reverseDepthBuffer: v = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let x;
    if (n !== null) {
      if (typeof WebGLRenderingContext < 'u' && n instanceof WebGLRenderingContext)
        throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
      x = n.getContextAttributes().alpha;
    } else x = a;
    const A = new Uint32Array(4),
      C = new Int32Array(4);
    let E = null,
      S = null;
    const b = [],
      I = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = xr),
      (this.toneMapping = Lo),
      (this.toneMappingExposure = 1);
    const B = this;
    let z = !1,
      N = 0,
      G = 0,
      k = null,
      L = -1,
      D = null;
    const V = new Bn(),
      oe = new Bn();
    let ie = null;
    const ce = new At(0);
    let xe = 0,
      de = t.width,
      Ce = t.height,
      X = 1,
      fe = null,
      te = null;
    const Y = new Bn(0, 0, de, Ce),
      ue = new Bn(0, 0, de, Ce);
    let He = !1;
    const ge = new Wh();
    let De = !1,
      Ie = !1;
    this.transmissionResolutionScale = 1;
    const Ue = new Qt(),
      et = new Qt(),
      Bt = new J(),
      ht = new Bn(),
      Jt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Ye = !1;
    function ke() {
      return k === null ? X : 1;
    }
    let j = n;
    function It(U, Q) {
      return t.getContext(U, Q);
    }
    try {
      const U = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: u,
        premultipliedAlpha: d,
        preserveDrawingBuffer: h,
        powerPreference: m,
        failIfMajorPerformanceCaveat: g,
      };
      if (
        ('setAttribute' in t && t.setAttribute('data-engine', `three.js r${Dh}`),
        t.addEventListener('webglcontextlost', Oe, !1),
        t.addEventListener('webglcontextrestored', vt, !1),
        t.addEventListener('webglcontextcreationerror', dt, !1),
        j === null)
      ) {
        const Q = 'webgl2';
        if (((j = It(Q, U)), j === null))
          throw It(Q)
            ? new Error('Error creating WebGL context with your selected attributes.')
            : new Error('Error creating WebGL context.');
      }
    } catch (U) {
      throw (console.error('THREE.WebGLRenderer: ' + U.message), U);
    }
    let qe,
      yt,
      rt,
      Ht,
      lt,
      K,
      H,
      ve,
      Le,
      We,
      ze,
      Ct,
      at,
      pt,
      $t,
      Ze,
      wt,
      Ft,
      Rt,
      St,
      re,
      Re,
      tt,
      ne;
    function ye() {
      (qe = new jI(j)),
        qe.init(),
        (Re = new xE(j, qe)),
        (yt = new VI(j, qe, e, Re)),
        (rt = new bP(j, qe)),
        yt.reverseDepthBuffer && v && rt.buffers.depth.setReversed(!0),
        (Ht = new qI(j)),
        (lt = new gP()),
        (K = new IP(j, qe, rt, lt, yt, Re, Ht)),
        (H = new XI(B)),
        (ve = new KI(B)),
        (Le = new sR(j)),
        (tt = new HI(j, Le)),
        (We = new ZI(j, Le, Ht, tt)),
        (ze = new eB(j, We, Le, Ht)),
        (Rt = new $I(j, yt, K)),
        (Ze = new WI(lt)),
        (Ct = new mP(B, H, ve, qe, yt, tt, Ze)),
        (at = new NP(B, lt)),
        (pt = new yP()),
        ($t = new EP(qe)),
        (Ft = new zI(B, H, ve, rt, ze, x, d)),
        (wt = new TP(B, ze, yt)),
        (ne = new UP(j, Ht, yt, rt)),
        (St = new GI(j, qe, Ht)),
        (re = new QI(j, qe, Ht)),
        (Ht.programs = Ct.programs),
        (B.capabilities = yt),
        (B.extensions = qe),
        (B.properties = lt),
        (B.renderLists = pt),
        (B.shadowMap = wt),
        (B.state = rt),
        (B.info = Ht);
    }
    ye();
    const we = new LP(B, j);
    (this.xr = we),
      (this.getContext = function () {
        return j;
      }),
      (this.getContextAttributes = function () {
        return j.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const U = qe.get('WEBGL_lose_context');
        U && U.loseContext();
      }),
      (this.forceContextRestore = function () {
        const U = qe.get('WEBGL_lose_context');
        U && U.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return X;
      }),
      (this.setPixelRatio = function (U) {
        U !== void 0 && ((X = U), this.setSize(de, Ce, !1));
      }),
      (this.getSize = function (U) {
        return U.set(de, Ce);
      }),
      (this.setSize = function (U, Q, ee = !0) {
        if (we.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        (de = U),
          (Ce = Q),
          (t.width = Math.floor(U * X)),
          (t.height = Math.floor(Q * X)),
          ee === !0 && ((t.style.width = U + 'px'), (t.style.height = Q + 'px')),
          this.setViewport(0, 0, U, Q);
      }),
      (this.getDrawingBufferSize = function (U) {
        return U.set(de * X, Ce * X).floor();
      }),
      (this.setDrawingBufferSize = function (U, Q, ee) {
        (de = U),
          (Ce = Q),
          (X = ee),
          (t.width = Math.floor(U * ee)),
          (t.height = Math.floor(Q * ee)),
          this.setViewport(0, 0, U, Q);
      }),
      (this.getCurrentViewport = function (U) {
        return U.copy(V);
      }),
      (this.getViewport = function (U) {
        return U.copy(Y);
      }),
      (this.setViewport = function (U, Q, ee, q) {
        U.isVector4 ? Y.set(U.x, U.y, U.z, U.w) : Y.set(U, Q, ee, q),
          rt.viewport(V.copy(Y).multiplyScalar(X).round());
      }),
      (this.getScissor = function (U) {
        return U.copy(ue);
      }),
      (this.setScissor = function (U, Q, ee, q) {
        U.isVector4 ? ue.set(U.x, U.y, U.z, U.w) : ue.set(U, Q, ee, q),
          rt.scissor(oe.copy(ue).multiplyScalar(X).round());
      }),
      (this.getScissorTest = function () {
        return He;
      }),
      (this.setScissorTest = function (U) {
        rt.setScissorTest((He = U));
      }),
      (this.setOpaqueSort = function (U) {
        fe = U;
      }),
      (this.setTransparentSort = function (U) {
        te = U;
      }),
      (this.getClearColor = function (U) {
        return U.copy(Ft.getClearColor());
      }),
      (this.setClearColor = function () {
        Ft.setClearColor.apply(Ft, arguments);
      }),
      (this.getClearAlpha = function () {
        return Ft.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ft.setClearAlpha.apply(Ft, arguments);
      }),
      (this.clear = function (U = !0, Q = !0, ee = !0) {
        let q = 0;
        if (U) {
          let le = !1;
          if (k !== null) {
            const Ae = k.texture.format;
            le = Ae === Wg || Ae === Vg || Ae === Uh;
          }
          if (le) {
            const Ae = k.texture.type,
              Fe = Ae === ns || Ae === ko || Ae === Of || Ae === qu || Ae === Hg || Ae === Gg,
              Ve = Ft.getClearColor(),
              Je = Ft.getClearAlpha(),
              ft = Ve.r,
              ut = Ve.g,
              Xe = Ve.b;
            Fe
              ? ((A[0] = ft),
                (A[1] = ut),
                (A[2] = Xe),
                (A[3] = Je),
                j.clearBufferuiv(j.COLOR, 0, A))
              : ((C[0] = ft),
                (C[1] = ut),
                (C[2] = Xe),
                (C[3] = Je),
                j.clearBufferiv(j.COLOR, 0, C));
          } else q |= j.COLOR_BUFFER_BIT;
        }
        Q && (q |= j.DEPTH_BUFFER_BIT),
          ee && ((q |= j.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
          j.clear(q);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener('webglcontextlost', Oe, !1),
          t.removeEventListener('webglcontextrestored', vt, !1),
          t.removeEventListener('webglcontextcreationerror', dt, !1),
          Ft.dispose(),
          pt.dispose(),
          $t.dispose(),
          lt.dispose(),
          H.dispose(),
          ve.dispose(),
          ze.dispose(),
          tt.dispose(),
          ne.dispose(),
          Ct.dispose(),
          we.dispose(),
          we.removeEventListener('sessionstart', yo),
          we.removeEventListener('sessionend', _s),
          Zi.stop();
      });
    function Oe(U) {
      U.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (z = !0);
    }
    function vt() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (z = !1);
      const U = Ht.autoReset,
        Q = wt.enabled,
        ee = wt.autoUpdate,
        q = wt.needsUpdate,
        le = wt.type;
      ye(),
        (Ht.autoReset = U),
        (wt.enabled = Q),
        (wt.autoUpdate = ee),
        (wt.needsUpdate = q),
        (wt.type = le);
    }
    function dt(U) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        U.statusMessage,
      );
    }
    function Gt(U) {
      const Q = U.target;
      Q.removeEventListener('dispose', Gt), _n(Q);
    }
    function _n(U) {
      Nn(U), lt.remove(U);
    }
    function Nn(U) {
      const Q = lt.get(U).programs;
      Q !== void 0 &&
        (Q.forEach(function (ee) {
          Ct.releaseProgram(ee);
        }),
        U.isShaderMaterial && Ct.releaseShaderCache(U));
    }
    this.renderBufferDirect = function (U, Q, ee, q, le, Ae) {
      Q === null && (Q = Jt);
      const Fe = le.isMesh && le.matrixWorld.determinant() < 0,
        Ve = se(U, Q, ee, q, le);
      rt.setMaterial(q, Fe);
      let Je = ee.index,
        ft = 1;
      if (q.wireframe === !0) {
        if (((Je = We.getWireframeAttribute(ee)), Je === void 0)) return;
        ft = 2;
      }
      const ut = ee.drawRange,
        Xe = ee.attributes.position;
      let mt = ut.start * ft,
        gt = (ut.start + ut.count) * ft;
      Ae !== null &&
        ((mt = Math.max(mt, Ae.start * ft)), (gt = Math.min(gt, (Ae.start + Ae.count) * ft))),
        Je !== null
          ? ((mt = Math.max(mt, 0)), (gt = Math.min(gt, Je.count)))
          : Xe != null && ((mt = Math.max(mt, 0)), (gt = Math.min(gt, Xe.count)));
      const qt = gt - mt;
      if (qt < 0 || qt === 1 / 0) return;
      tt.setup(le, q, Ve, ee, Je);
      let Dt,
        Ut = St;
      if ((Je !== null && ((Dt = Le.get(Je)), (Ut = re), Ut.setIndex(Dt)), le.isMesh))
        q.wireframe === !0
          ? (rt.setLineWidth(q.wireframeLinewidth * ke()), Ut.setMode(j.LINES))
          : Ut.setMode(j.TRIANGLES);
      else if (le.isLine) {
        let Mt = q.linewidth;
        Mt === void 0 && (Mt = 1),
          rt.setLineWidth(Mt * ke()),
          le.isLineSegments
            ? Ut.setMode(j.LINES)
            : le.isLineLoop
            ? Ut.setMode(j.LINE_LOOP)
            : Ut.setMode(j.LINE_STRIP);
      } else le.isPoints ? Ut.setMode(j.POINTS) : le.isSprite && Ut.setMode(j.TRIANGLES);
      if (le.isBatchedMesh)
        if (le._multiDrawInstances !== null)
          Ut.renderMultiDrawInstances(
            le._multiDrawStarts,
            le._multiDrawCounts,
            le._multiDrawCount,
            le._multiDrawInstances,
          );
        else if (qe.get('WEBGL_multi_draw'))
          Ut.renderMultiDraw(le._multiDrawStarts, le._multiDrawCounts, le._multiDrawCount);
        else {
          const Mt = le._multiDrawStarts,
            cn = le._multiDrawCounts,
            Wt = le._multiDrawCount,
            en = Je ? Le.get(Je).bytesPerElement : 1,
            Hn = lt.get(q).currentProgram.getUniforms();
          for (let on = 0; on < Wt; on++)
            Hn.setValue(j, '_gl_DrawID', on), Ut.render(Mt[on] / en, cn[on]);
        }
      else if (le.isInstancedMesh) Ut.renderInstances(mt, qt, le.count);
      else if (ee.isInstancedBufferGeometry) {
        const Mt = ee._maxInstanceCount !== void 0 ? ee._maxInstanceCount : 1 / 0,
          cn = Math.min(ee.instanceCount, Mt);
        Ut.renderInstances(mt, qt, cn);
      } else Ut.render(mt, qt);
    };
    function an(U, Q, ee) {
      U.transparent === !0 && U.side === gs && U.forceSinglePass === !1
        ? ((U.side = Or),
          (U.needsUpdate = !0),
          _o(U, Q, ee),
          (U.side = Uo),
          (U.needsUpdate = !0),
          _o(U, Q, ee),
          (U.side = gs))
        : _o(U, Q, ee);
    }
    (this.compile = function (U, Q, ee = null) {
      ee === null && (ee = U),
        (S = $t.get(ee)),
        S.init(Q),
        I.push(S),
        ee.traverseVisible(function (le) {
          le.isLight &&
            le.layers.test(Q.layers) &&
            (S.pushLight(le), le.castShadow && S.pushShadow(le));
        }),
        U !== ee &&
          U.traverseVisible(function (le) {
            le.isLight &&
              le.layers.test(Q.layers) &&
              (S.pushLight(le), le.castShadow && S.pushShadow(le));
          }),
        S.setupLights();
      const q = new Set();
      return (
        U.traverse(function (le) {
          if (!(le.isMesh || le.isPoints || le.isLine || le.isSprite)) return;
          const Ae = le.material;
          if (Ae)
            if (Array.isArray(Ae))
              for (let Fe = 0; Fe < Ae.length; Fe++) {
                const Ve = Ae[Fe];
                an(Ve, ee, le), q.add(Ve);
              }
            else an(Ae, ee, le), q.add(Ae);
        }),
        I.pop(),
        (S = null),
        q
      );
    }),
      (this.compileAsync = function (U, Q, ee = null) {
        const q = this.compile(U, Q, ee);
        return new Promise((le) => {
          function Ae() {
            if (
              (q.forEach(function (Fe) {
                lt.get(Fe).currentProgram.isReady() && q.delete(Fe);
              }),
              q.size === 0)
            ) {
              le(U);
              return;
            }
            setTimeout(Ae, 10);
          }
          qe.get('KHR_parallel_shader_compile') !== null ? Ae() : setTimeout(Ae, 10);
        });
      });
    let qn = null;
    function ni(U) {
      qn && qn(U);
    }
    function yo() {
      Zi.stop();
    }
    function _s() {
      Zi.start();
    }
    const Zi = new mE();
    Zi.setAnimationLoop(ni),
      typeof self < 'u' && Zi.setContext(self),
      (this.setAnimationLoop = function (U) {
        (qn = U), we.setAnimationLoop(U), U === null ? Zi.stop() : Zi.start();
      }),
      we.addEventListener('sessionstart', yo),
      we.addEventListener('sessionend', _s),
      (this.render = function (U, Q) {
        if (Q !== void 0 && Q.isCamera !== !0) {
          console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return;
        }
        if (z === !0) return;
        if (
          (U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(),
          Q.parent === null && Q.matrixWorldAutoUpdate === !0 && Q.updateMatrixWorld(),
          we.enabled === !0 &&
            we.isPresenting === !0 &&
            (we.cameraAutoUpdate === !0 && we.updateCamera(Q), (Q = we.getCamera())),
          U.isScene === !0 && U.onBeforeRender(B, U, Q, k),
          (S = $t.get(U, I.length)),
          S.init(Q),
          I.push(S),
          et.multiplyMatrices(Q.projectionMatrix, Q.matrixWorldInverse),
          ge.setFromProjectionMatrix(et),
          (Ie = this.localClippingEnabled),
          (De = Ze.init(this.clippingPlanes, Ie)),
          (E = pt.get(U, b.length)),
          E.init(),
          b.push(E),
          we.enabled === !0 && we.isPresenting === !0)
        ) {
          const Ae = B.xr.getDepthSensingMesh();
          Ae !== null && Mr(Ae, Q, -1 / 0, B.sortObjects);
        }
        Mr(U, Q, 0, B.sortObjects),
          E.finish(),
          B.sortObjects === !0 && E.sort(fe, te),
          (Ye = we.enabled === !1 || we.isPresenting === !1 || we.hasDepthSensing() === !1),
          Ye && Ft.addToRenderList(E, U),
          this.info.render.frame++,
          De === !0 && Ze.beginShadows();
        const ee = S.state.shadowsArray;
        wt.render(ee, U, Q),
          De === !0 && Ze.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const q = E.opaque,
          le = E.transmissive;
        if ((S.setupLights(), Q.isArrayCamera)) {
          const Ae = Q.cameras;
          if (le.length > 0)
            for (let Fe = 0, Ve = Ae.length; Fe < Ve; Fe++) {
              const Je = Ae[Fe];
              Ii(q, le, U, Je);
            }
          Ye && Ft.render(U);
          for (let Fe = 0, Ve = Ae.length; Fe < Ve; Fe++) {
            const Je = Ae[Fe];
            Er(E, U, Je, Je.viewport);
          }
        } else le.length > 0 && Ii(q, le, U, Q), Ye && Ft.render(U), Er(E, U, Q);
        k !== null &&
          G === 0 &&
          (K.updateMultisampleRenderTarget(k), K.updateRenderTargetMipmap(k)),
          U.isScene === !0 && U.onAfterRender(B, U, Q),
          tt.resetDefaultState(),
          (L = -1),
          (D = null),
          I.pop(),
          I.length > 0
            ? ((S = I[I.length - 1]),
              De === !0 && Ze.setGlobalState(B.clippingPlanes, S.state.camera))
            : (S = null),
          b.pop(),
          b.length > 0 ? (E = b[b.length - 1]) : (E = null);
      });
    function Mr(U, Q, ee, q) {
      if (U.visible === !1) return;
      if (U.layers.test(Q.layers)) {
        if (U.isGroup) ee = U.renderOrder;
        else if (U.isLOD) U.autoUpdate === !0 && U.update(Q);
        else if (U.isLight) S.pushLight(U), U.castShadow && S.pushShadow(U);
        else if (U.isSprite) {
          if (!U.frustumCulled || ge.intersectsSprite(U)) {
            q && ht.setFromMatrixPosition(U.matrixWorld).applyMatrix4(et);
            const Fe = ze.update(U),
              Ve = U.material;
            Ve.visible && E.push(U, Fe, Ve, ee, ht.z, null);
          }
        } else if (
          (U.isMesh || U.isLine || U.isPoints) &&
          (!U.frustumCulled || ge.intersectsObject(U))
        ) {
          const Fe = ze.update(U),
            Ve = U.material;
          if (
            (q &&
              (U.boundingSphere !== void 0
                ? (U.boundingSphere === null && U.computeBoundingSphere(),
                  ht.copy(U.boundingSphere.center))
                : (Fe.boundingSphere === null && Fe.computeBoundingSphere(),
                  ht.copy(Fe.boundingSphere.center)),
              ht.applyMatrix4(U.matrixWorld).applyMatrix4(et)),
            Array.isArray(Ve))
          ) {
            const Je = Fe.groups;
            for (let ft = 0, ut = Je.length; ft < ut; ft++) {
              const Xe = Je[ft],
                mt = Ve[Xe.materialIndex];
              mt && mt.visible && E.push(U, Fe, mt, ee, ht.z, Xe);
            }
          } else Ve.visible && E.push(U, Fe, Ve, ee, ht.z, null);
        }
      }
      const Ae = U.children;
      for (let Fe = 0, Ve = Ae.length; Fe < Ve; Fe++) Mr(Ae[Fe], Q, ee, q);
    }
    function Er(U, Q, ee, q) {
      const le = U.opaque,
        Ae = U.transmissive,
        Fe = U.transparent;
      S.setupLightsView(ee),
        De === !0 && Ze.setGlobalState(B.clippingPlanes, ee),
        q && rt.viewport(V.copy(q)),
        le.length > 0 && nn(le, Q, ee),
        Ae.length > 0 && nn(Ae, Q, ee),
        Fe.length > 0 && nn(Fe, Q, ee),
        rt.buffers.depth.setTest(!0),
        rt.buffers.depth.setMask(!0),
        rt.buffers.color.setMask(!0),
        rt.setPolygonOffset(!1);
    }
    function Ii(U, Q, ee, q) {
      if ((ee.isScene === !0 ? ee.overrideMaterial : null) !== null) return;
      S.state.transmissionRenderTarget[q.id] === void 0 &&
        (S.state.transmissionRenderTarget[q.id] = new Ls(1, 1, {
          generateMipmaps: !0,
          type: qe.has('EXT_color_buffer_half_float') || qe.has('EXT_color_buffer_float') ? Yi : ns,
          minFilter: Ds,
          samples: 4,
          stencilBuffer: o,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: bn.workingColorSpace,
        }));
      const Ae = S.state.transmissionRenderTarget[q.id],
        Fe = q.viewport || V;
      Ae.setSize(Fe.z * B.transmissionResolutionScale, Fe.w * B.transmissionResolutionScale);
      const Ve = B.getRenderTarget();
      B.setRenderTarget(Ae),
        B.getClearColor(ce),
        (xe = B.getClearAlpha()),
        xe < 1 && B.setClearColor(16777215, 0.5),
        B.clear(),
        Ye && Ft.render(ee);
      const Je = B.toneMapping;
      B.toneMapping = Lo;
      const ft = q.viewport;
      if (
        (q.viewport !== void 0 && (q.viewport = void 0),
        S.setupLightsView(q),
        De === !0 && Ze.setGlobalState(B.clippingPlanes, q),
        nn(U, ee, q),
        K.updateMultisampleRenderTarget(Ae),
        K.updateRenderTargetMipmap(Ae),
        qe.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let ut = !1;
        for (let Xe = 0, mt = Q.length; Xe < mt; Xe++) {
          const gt = Q[Xe],
            qt = gt.object,
            Dt = gt.geometry,
            Ut = gt.material,
            Mt = gt.group;
          if (Ut.side === gs && qt.layers.test(q.layers)) {
            const cn = Ut.side;
            (Ut.side = Or),
              (Ut.needsUpdate = !0),
              Go(qt, ee, q, Dt, Ut, Mt),
              (Ut.side = cn),
              (Ut.needsUpdate = !0),
              (ut = !0);
          }
        }
        ut === !0 && (K.updateMultisampleRenderTarget(Ae), K.updateRenderTargetMipmap(Ae));
      }
      B.setRenderTarget(Ve),
        B.setClearColor(ce, xe),
        ft !== void 0 && (q.viewport = ft),
        (B.toneMapping = Je);
    }
    function nn(U, Q, ee) {
      const q = Q.isScene === !0 ? Q.overrideMaterial : null;
      for (let le = 0, Ae = U.length; le < Ae; le++) {
        const Fe = U[le],
          Ve = Fe.object,
          Je = Fe.geometry,
          ft = q === null ? Fe.material : q,
          ut = Fe.group;
        Ve.layers.test(ee.layers) && Go(Ve, Q, ee, Je, ft, ut);
      }
    }
    function Go(U, Q, ee, q, le, Ae) {
      U.onBeforeRender(B, Q, ee, q, le, Ae),
        U.modelViewMatrix.multiplyMatrices(ee.matrixWorldInverse, U.matrixWorld),
        U.normalMatrix.getNormalMatrix(U.modelViewMatrix),
        le.onBeforeRender(B, Q, ee, q, U, Ae),
        le.transparent === !0 && le.side === gs && le.forceSinglePass === !1
          ? ((le.side = Or),
            (le.needsUpdate = !0),
            B.renderBufferDirect(ee, Q, q, le, U, Ae),
            (le.side = Uo),
            (le.needsUpdate = !0),
            B.renderBufferDirect(ee, Q, q, le, U, Ae),
            (le.side = gs))
          : B.renderBufferDirect(ee, Q, q, le, U, Ae),
        U.onAfterRender(B, Q, ee, q, le, Ae);
    }
    function _o(U, Q, ee) {
      Q.isScene !== !0 && (Q = Jt);
      const q = lt.get(U),
        le = S.state.lights,
        Ae = S.state.shadowsArray,
        Fe = le.state.version,
        Ve = Ct.getParameters(U, le.state, Ae, Q, ee),
        Je = Ct.getProgramCacheKey(Ve);
      let ft = q.programs;
      (q.environment = U.isMeshStandardMaterial ? Q.environment : null),
        (q.fog = Q.fog),
        (q.envMap = (U.isMeshStandardMaterial ? ve : H).get(U.envMap || q.environment)),
        (q.envMapRotation =
          q.environment !== null && U.envMap === null ? Q.environmentRotation : U.envMapRotation),
        ft === void 0 && (U.addEventListener('dispose', Gt), (ft = new Map()), (q.programs = ft));
      let ut = ft.get(Je);
      if (ut !== void 0) {
        if (q.currentProgram === ut && q.lightsStateVersion === Fe) return W(U, Ve), ut;
      } else
        (Ve.uniforms = Ct.getUniforms(U)),
          U.onBeforeCompile(Ve, B),
          (ut = Ct.acquireProgram(Ve, Je)),
          ft.set(Je, ut),
          (q.uniforms = Ve.uniforms);
      const Xe = q.uniforms;
      return (
        ((!U.isShaderMaterial && !U.isRawShaderMaterial) || U.clipping === !0) &&
          (Xe.clippingPlanes = Ze.uniform),
        W(U, Ve),
        (q.needsLights = Be(U)),
        (q.lightsStateVersion = Fe),
        q.needsLights &&
          ((Xe.ambientLightColor.value = le.state.ambient),
          (Xe.lightProbe.value = le.state.probe),
          (Xe.directionalLights.value = le.state.directional),
          (Xe.directionalLightShadows.value = le.state.directionalShadow),
          (Xe.spotLights.value = le.state.spot),
          (Xe.spotLightShadows.value = le.state.spotShadow),
          (Xe.rectAreaLights.value = le.state.rectArea),
          (Xe.ltc_1.value = le.state.rectAreaLTC1),
          (Xe.ltc_2.value = le.state.rectAreaLTC2),
          (Xe.pointLights.value = le.state.point),
          (Xe.pointLightShadows.value = le.state.pointShadow),
          (Xe.hemisphereLights.value = le.state.hemi),
          (Xe.directionalShadowMap.value = le.state.directionalShadowMap),
          (Xe.directionalShadowMatrix.value = le.state.directionalShadowMatrix),
          (Xe.spotShadowMap.value = le.state.spotShadowMap),
          (Xe.spotLightMatrix.value = le.state.spotLightMatrix),
          (Xe.spotLightMap.value = le.state.spotLightMap),
          (Xe.pointShadowMap.value = le.state.pointShadowMap),
          (Xe.pointShadowMatrix.value = le.state.pointShadowMatrix)),
        (q.currentProgram = ut),
        (q.uniformsList = null),
        ut
      );
    }
    function F(U) {
      if (U.uniformsList === null) {
        const Q = U.currentProgram.getUniforms();
        U.uniformsList = Ym.seqWithValue(Q.seq, U.uniforms);
      }
      return U.uniformsList;
    }
    function W(U, Q) {
      const ee = lt.get(U);
      (ee.outputColorSpace = Q.outputColorSpace),
        (ee.batching = Q.batching),
        (ee.batchingColor = Q.batchingColor),
        (ee.instancing = Q.instancing),
        (ee.instancingColor = Q.instancingColor),
        (ee.instancingMorph = Q.instancingMorph),
        (ee.skinning = Q.skinning),
        (ee.morphTargets = Q.morphTargets),
        (ee.morphNormals = Q.morphNormals),
        (ee.morphColors = Q.morphColors),
        (ee.morphTargetsCount = Q.morphTargetsCount),
        (ee.numClippingPlanes = Q.numClippingPlanes),
        (ee.numIntersection = Q.numClipIntersection),
        (ee.vertexAlphas = Q.vertexAlphas),
        (ee.vertexTangents = Q.vertexTangents),
        (ee.toneMapping = Q.toneMapping);
    }
    function se(U, Q, ee, q, le) {
      Q.isScene !== !0 && (Q = Jt), K.resetTextureUnits();
      const Ae = Q.fog,
        Fe = q.isMeshStandardMaterial ? Q.environment : null,
        Ve =
          k === null ? B.outputColorSpace : k.isXRRenderTarget === !0 ? k.texture.colorSpace : zo,
        Je = (q.isMeshStandardMaterial ? ve : H).get(q.envMap || Fe),
        ft = q.vertexColors === !0 && !!ee.attributes.color && ee.attributes.color.itemSize === 4,
        ut = !!ee.attributes.tangent && (!!q.normalMap || q.anisotropy > 0),
        Xe = !!ee.morphAttributes.position,
        mt = !!ee.morphAttributes.normal,
        gt = !!ee.morphAttributes.color;
      let qt = Lo;
      q.toneMapped && (k === null || k.isXRRenderTarget === !0) && (qt = B.toneMapping);
      const Dt =
          ee.morphAttributes.position || ee.morphAttributes.normal || ee.morphAttributes.color,
        Ut = Dt !== void 0 ? Dt.length : 0,
        Mt = lt.get(q),
        cn = S.state.lights;
      if (De === !0 && (Ie === !0 || U !== D)) {
        const Gn = U === D && q.id === L;
        Ze.setState(q, U, Gn);
      }
      let Wt = !1;
      q.version === Mt.__version
        ? ((Mt.needsLights && Mt.lightsStateVersion !== cn.state.version) ||
            Mt.outputColorSpace !== Ve ||
            (le.isBatchedMesh && Mt.batching === !1) ||
            (!le.isBatchedMesh && Mt.batching === !0) ||
            (le.isBatchedMesh && Mt.batchingColor === !0 && le.colorTexture === null) ||
            (le.isBatchedMesh && Mt.batchingColor === !1 && le.colorTexture !== null) ||
            (le.isInstancedMesh && Mt.instancing === !1) ||
            (!le.isInstancedMesh && Mt.instancing === !0) ||
            (le.isSkinnedMesh && Mt.skinning === !1) ||
            (!le.isSkinnedMesh && Mt.skinning === !0) ||
            (le.isInstancedMesh && Mt.instancingColor === !0 && le.instanceColor === null) ||
            (le.isInstancedMesh && Mt.instancingColor === !1 && le.instanceColor !== null) ||
            (le.isInstancedMesh && Mt.instancingMorph === !0 && le.morphTexture === null) ||
            (le.isInstancedMesh && Mt.instancingMorph === !1 && le.morphTexture !== null) ||
            Mt.envMap !== Je ||
            (q.fog === !0 && Mt.fog !== Ae) ||
            (Mt.numClippingPlanes !== void 0 &&
              (Mt.numClippingPlanes !== Ze.numPlanes ||
                Mt.numIntersection !== Ze.numIntersection)) ||
            Mt.vertexAlphas !== ft ||
            Mt.vertexTangents !== ut ||
            Mt.morphTargets !== Xe ||
            Mt.morphNormals !== mt ||
            Mt.morphColors !== gt ||
            Mt.toneMapping !== qt ||
            Mt.morphTargetsCount !== Ut) &&
          (Wt = !0)
        : ((Wt = !0), (Mt.__version = q.version));
      let en = Mt.currentProgram;
      Wt === !0 && (en = _o(q, Q, le));
      let Hn = !1,
        on = !1,
        pn = !1;
      const Yt = en.getUniforms(),
        Kn = Mt.uniforms;
      if (
        (rt.useProgram(en.program) && ((Hn = !0), (on = !0), (pn = !0)),
        q.id !== L && ((L = q.id), (on = !0)),
        Hn || D !== U)
      ) {
        rt.buffers.depth.getReversed()
          ? (Ue.copy(U.projectionMatrix), Dw(Ue), Lw(Ue), Yt.setValue(j, 'projectionMatrix', Ue))
          : Yt.setValue(j, 'projectionMatrix', U.projectionMatrix),
          Yt.setValue(j, 'viewMatrix', U.matrixWorldInverse);
        const ai = Yt.map.cameraPosition;
        ai !== void 0 && ai.setValue(j, Bt.setFromMatrixPosition(U.matrixWorld)),
          yt.logarithmicDepthBuffer &&
            Yt.setValue(j, 'logDepthBufFC', 2 / (Math.log(U.far + 1) / Math.LN2)),
          (q.isMeshPhongMaterial ||
            q.isMeshToonMaterial ||
            q.isMeshLambertMaterial ||
            q.isMeshBasicMaterial ||
            q.isMeshStandardMaterial ||
            q.isShaderMaterial) &&
            Yt.setValue(j, 'isOrthographic', U.isOrthographicCamera === !0),
          D !== U && ((D = U), (on = !0), (pn = !0));
      }
      if (le.isSkinnedMesh) {
        Yt.setOptional(j, le, 'bindMatrix'), Yt.setOptional(j, le, 'bindMatrixInverse');
        const Gn = le.skeleton;
        Gn &&
          (Gn.boneTexture === null && Gn.computeBoneTexture(),
          Yt.setValue(j, 'boneTexture', Gn.boneTexture, K));
      }
      le.isBatchedMesh &&
        (Yt.setOptional(j, le, 'batchingTexture'),
        Yt.setValue(j, 'batchingTexture', le._matricesTexture, K),
        Yt.setOptional(j, le, 'batchingIdTexture'),
        Yt.setValue(j, 'batchingIdTexture', le._indirectTexture, K),
        Yt.setOptional(j, le, 'batchingColorTexture'),
        le._colorsTexture !== null && Yt.setValue(j, 'batchingColorTexture', le._colorsTexture, K));
      const Cn = ee.morphAttributes;
      if (
        ((Cn.position !== void 0 || Cn.normal !== void 0 || Cn.color !== void 0) &&
          Rt.update(le, ee, en),
        (on || Mt.receiveShadow !== le.receiveShadow) &&
          ((Mt.receiveShadow = le.receiveShadow),
          Yt.setValue(j, 'receiveShadow', le.receiveShadow)),
        q.isMeshGouraudMaterial &&
          q.envMap !== null &&
          ((Kn.envMap.value = Je),
          (Kn.flipEnvMap.value = Je.isCubeTexture && Je.isRenderTargetTexture === !1 ? -1 : 1)),
        q.isMeshStandardMaterial &&
          q.envMap === null &&
          Q.environment !== null &&
          (Kn.envMapIntensity.value = Q.environmentIntensity),
        on &&
          (Yt.setValue(j, 'toneMappingExposure', B.toneMappingExposure),
          Mt.needsLights && Ee(Kn, pn),
          Ae && q.fog === !0 && at.refreshFogUniforms(Kn, Ae),
          at.refreshMaterialUniforms(Kn, q, X, Ce, S.state.transmissionRenderTarget[U.id]),
          Ym.upload(j, F(Mt), Kn, K)),
        q.isShaderMaterial &&
          q.uniformsNeedUpdate === !0 &&
          (Ym.upload(j, F(Mt), Kn, K), (q.uniformsNeedUpdate = !1)),
        q.isSpriteMaterial && Yt.setValue(j, 'center', le.center),
        Yt.setValue(j, 'modelViewMatrix', le.modelViewMatrix),
        Yt.setValue(j, 'normalMatrix', le.normalMatrix),
        Yt.setValue(j, 'modelMatrix', le.matrixWorld),
        q.isShaderMaterial || q.isRawShaderMaterial)
      ) {
        const Gn = q.uniformsGroups;
        for (let ai = 0, xn = Gn.length; ai < xn; ai++) {
          const ur = Gn[ai];
          ne.update(ur, en), ne.bind(ur, en);
        }
      }
      return en;
    }
    function Ee(U, Q) {
      (U.ambientLightColor.needsUpdate = Q),
        (U.lightProbe.needsUpdate = Q),
        (U.directionalLights.needsUpdate = Q),
        (U.directionalLightShadows.needsUpdate = Q),
        (U.pointLights.needsUpdate = Q),
        (U.pointLightShadows.needsUpdate = Q),
        (U.spotLights.needsUpdate = Q),
        (U.spotLightShadows.needsUpdate = Q),
        (U.rectAreaLights.needsUpdate = Q),
        (U.hemisphereLights.needsUpdate = Q);
    }
    function Be(U) {
      return (
        U.isMeshLambertMaterial ||
        U.isMeshToonMaterial ||
        U.isMeshPhongMaterial ||
        U.isMeshStandardMaterial ||
        U.isShadowMaterial ||
        (U.isShaderMaterial && U.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return N;
    }),
      (this.getActiveMipmapLevel = function () {
        return G;
      }),
      (this.getRenderTarget = function () {
        return k;
      }),
      (this.setRenderTargetTextures = function (U, Q, ee) {
        (lt.get(U.texture).__webglTexture = Q), (lt.get(U.depthTexture).__webglTexture = ee);
        const q = lt.get(U);
        (q.__hasExternalTextures = !0),
          (q.__autoAllocateDepthBuffer = ee === void 0),
          q.__autoAllocateDepthBuffer ||
            (qe.has('WEBGL_multisampled_render_to_texture') === !0 &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided',
              ),
              (q.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (U, Q) {
        const ee = lt.get(U);
        (ee.__webglFramebuffer = Q), (ee.__useDefaultFramebuffer = Q === void 0);
      });
    const Pe = j.createFramebuffer();
    (this.setRenderTarget = function (U, Q = 0, ee = 0) {
      (k = U), (N = Q), (G = ee);
      let q = !0,
        le = null,
        Ae = !1,
        Fe = !1;
      if (U) {
        const Je = lt.get(U);
        if (Je.__useDefaultFramebuffer !== void 0)
          rt.bindFramebuffer(j.FRAMEBUFFER, null), (q = !1);
        else if (Je.__webglFramebuffer === void 0) K.setupRenderTarget(U);
        else if (Je.__hasExternalTextures)
          K.rebindTextures(
            U,
            lt.get(U.texture).__webglTexture,
            lt.get(U.depthTexture).__webglTexture,
          );
        else if (U.depthBuffer) {
          const Xe = U.depthTexture;
          if (Je.__boundDepthTexture !== Xe) {
            if (
              Xe !== null &&
              lt.has(Xe) &&
              (U.width !== Xe.image.width || U.height !== Xe.image.height)
            )
              throw new Error(
                'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.',
              );
            K.setupDepthRenderbuffer(U);
          }
        }
        const ft = U.texture;
        (ft.isData3DTexture || ft.isDataArrayTexture || ft.isCompressedArrayTexture) && (Fe = !0);
        const ut = lt.get(U).__webglFramebuffer;
        U.isWebGLCubeRenderTarget
          ? (Array.isArray(ut[Q]) ? (le = ut[Q][ee]) : (le = ut[Q]), (Ae = !0))
          : U.samples > 0 && K.useMultisampledRTT(U) === !1
          ? (le = lt.get(U).__webglMultisampledFramebuffer)
          : Array.isArray(ut)
          ? (le = ut[ee])
          : (le = ut),
          V.copy(U.viewport),
          oe.copy(U.scissor),
          (ie = U.scissorTest);
      } else V.copy(Y).multiplyScalar(X).floor(), oe.copy(ue).multiplyScalar(X).floor(), (ie = He);
      if (
        (ee !== 0 && (le = Pe),
        rt.bindFramebuffer(j.FRAMEBUFFER, le) && q && rt.drawBuffers(U, le),
        rt.viewport(V),
        rt.scissor(oe),
        rt.setScissorTest(ie),
        Ae)
      ) {
        const Je = lt.get(U.texture);
        j.framebufferTexture2D(
          j.FRAMEBUFFER,
          j.COLOR_ATTACHMENT0,
          j.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
          Je.__webglTexture,
          ee,
        );
      } else if (Fe) {
        const Je = lt.get(U.texture),
          ft = Q;
        j.framebufferTextureLayer(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, Je.__webglTexture, ee, ft);
      } else if (U !== null && ee !== 0) {
        const Je = lt.get(U.texture);
        j.framebufferTexture2D(
          j.FRAMEBUFFER,
          j.COLOR_ATTACHMENT0,
          j.TEXTURE_2D,
          Je.__webglTexture,
          ee,
        );
      }
      L = -1;
    }),
      (this.readRenderTargetPixels = function (U, Q, ee, q, le, Ae, Fe) {
        if (!(U && U.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          );
          return;
        }
        let Ve = lt.get(U).__webglFramebuffer;
        if ((U.isWebGLCubeRenderTarget && Fe !== void 0 && (Ve = Ve[Fe]), Ve)) {
          rt.bindFramebuffer(j.FRAMEBUFFER, Ve);
          try {
            const Je = U.texture,
              ft = Je.format,
              ut = Je.type;
            if (!yt.textureFormatReadable(ft)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
              );
              return;
            }
            if (!yt.textureTypeReadable(ut)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
              );
              return;
            }
            Q >= 0 &&
              Q <= U.width - q &&
              ee >= 0 &&
              ee <= U.height - le &&
              j.readPixels(Q, ee, q, le, Re.convert(ft), Re.convert(ut), Ae);
          } finally {
            const Je = k !== null ? lt.get(k).__webglFramebuffer : null;
            rt.bindFramebuffer(j.FRAMEBUFFER, Je);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (U, Q, ee, q, le, Ae, Fe) {
        if (!(U && U.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          );
        let Ve = lt.get(U).__webglFramebuffer;
        if ((U.isWebGLCubeRenderTarget && Fe !== void 0 && (Ve = Ve[Fe]), Ve)) {
          const Je = U.texture,
            ft = Je.format,
            ut = Je.type;
          if (!yt.textureFormatReadable(ft))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.',
            );
          if (!yt.textureTypeReadable(ut))
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.',
            );
          if (Q >= 0 && Q <= U.width - q && ee >= 0 && ee <= U.height - le) {
            rt.bindFramebuffer(j.FRAMEBUFFER, Ve);
            const Xe = j.createBuffer();
            j.bindBuffer(j.PIXEL_PACK_BUFFER, Xe),
              j.bufferData(j.PIXEL_PACK_BUFFER, Ae.byteLength, j.STREAM_READ),
              j.readPixels(Q, ee, q, le, Re.convert(ft), Re.convert(ut), 0);
            const mt = k !== null ? lt.get(k).__webglFramebuffer : null;
            rt.bindFramebuffer(j.FRAMEBUFFER, mt);
            const gt = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              j.flush(),
              await Pw(j, gt, 4),
              j.bindBuffer(j.PIXEL_PACK_BUFFER, Xe),
              j.getBufferSubData(j.PIXEL_PACK_BUFFER, 0, Ae),
              j.deleteBuffer(Xe),
              j.deleteSync(gt),
              Ae
            );
          } else
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.',
            );
        }
      }),
      (this.copyFramebufferToTexture = function (U, Q = null, ee = 0) {
        U.isTexture !== !0 &&
          (Cf('WebGLRenderer: copyFramebufferToTexture function signature has changed.'),
          (Q = arguments[0] || null),
          (U = arguments[1]));
        const q = Math.pow(2, -ee),
          le = Math.floor(U.image.width * q),
          Ae = Math.floor(U.image.height * q),
          Fe = Q !== null ? Q.x : 0,
          Ve = Q !== null ? Q.y : 0;
        K.setTexture2D(U, 0),
          j.copyTexSubImage2D(j.TEXTURE_2D, ee, 0, 0, Fe, Ve, le, Ae),
          rt.unbindTexture();
      });
    const it = j.createFramebuffer(),
      Qe = j.createFramebuffer();
    (this.copyTextureToTexture = function (U, Q, ee = null, q = null, le = 0, Ae = null) {
      U.isTexture !== !0 &&
        (Cf('WebGLRenderer: copyTextureToTexture function signature has changed.'),
        (q = arguments[0] || null),
        (U = arguments[1]),
        (Q = arguments[2]),
        (Ae = arguments[3] || 0),
        (ee = null)),
        Ae === null &&
          (le !== 0
            ? (Cf(
                'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.',
              ),
              (Ae = le),
              (le = 0))
            : (Ae = 0));
      let Fe, Ve, Je, ft, ut, Xe, mt, gt, qt;
      const Dt = U.isCompressedTexture ? U.mipmaps[Ae] : U.image;
      if (ee !== null)
        (Fe = ee.max.x - ee.min.x),
          (Ve = ee.max.y - ee.min.y),
          (Je = ee.isBox3 ? ee.max.z - ee.min.z : 1),
          (ft = ee.min.x),
          (ut = ee.min.y),
          (Xe = ee.isBox3 ? ee.min.z : 0);
      else {
        const Cn = Math.pow(2, -le);
        (Fe = Math.floor(Dt.width * Cn)),
          (Ve = Math.floor(Dt.height * Cn)),
          U.isDataArrayTexture
            ? (Je = Dt.depth)
            : U.isData3DTexture
            ? (Je = Math.floor(Dt.depth * Cn))
            : (Je = 1),
          (ft = 0),
          (ut = 0),
          (Xe = 0);
      }
      q !== null ? ((mt = q.x), (gt = q.y), (qt = q.z)) : ((mt = 0), (gt = 0), (qt = 0));
      const Ut = Re.convert(Q.format),
        Mt = Re.convert(Q.type);
      let cn;
      Q.isData3DTexture
        ? (K.setTexture3D(Q, 0), (cn = j.TEXTURE_3D))
        : Q.isDataArrayTexture || Q.isCompressedArrayTexture
        ? (K.setTexture2DArray(Q, 0), (cn = j.TEXTURE_2D_ARRAY))
        : (K.setTexture2D(Q, 0), (cn = j.TEXTURE_2D)),
        j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, Q.flipY),
        j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha),
        j.pixelStorei(j.UNPACK_ALIGNMENT, Q.unpackAlignment);
      const Wt = j.getParameter(j.UNPACK_ROW_LENGTH),
        en = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
        Hn = j.getParameter(j.UNPACK_SKIP_PIXELS),
        on = j.getParameter(j.UNPACK_SKIP_ROWS),
        pn = j.getParameter(j.UNPACK_SKIP_IMAGES);
      j.pixelStorei(j.UNPACK_ROW_LENGTH, Dt.width),
        j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Dt.height),
        j.pixelStorei(j.UNPACK_SKIP_PIXELS, ft),
        j.pixelStorei(j.UNPACK_SKIP_ROWS, ut),
        j.pixelStorei(j.UNPACK_SKIP_IMAGES, Xe);
      const Yt = U.isDataArrayTexture || U.isData3DTexture,
        Kn = Q.isDataArrayTexture || Q.isData3DTexture;
      if (U.isDepthTexture) {
        const Cn = lt.get(U),
          Gn = lt.get(Q),
          ai = lt.get(Cn.__renderTarget),
          xn = lt.get(Gn.__renderTarget);
        rt.bindFramebuffer(j.READ_FRAMEBUFFER, ai.__webglFramebuffer),
          rt.bindFramebuffer(j.DRAW_FRAMEBUFFER, xn.__webglFramebuffer);
        for (let ur = 0; ur < Je; ur++)
          Yt &&
            (j.framebufferTextureLayer(
              j.READ_FRAMEBUFFER,
              j.COLOR_ATTACHMENT0,
              lt.get(U).__webglTexture,
              le,
              Xe + ur,
            ),
            j.framebufferTextureLayer(
              j.DRAW_FRAMEBUFFER,
              j.COLOR_ATTACHMENT0,
              lt.get(Q).__webglTexture,
              Ae,
              qt + ur,
            )),
            j.blitFramebuffer(ft, ut, Fe, Ve, mt, gt, Fe, Ve, j.DEPTH_BUFFER_BIT, j.NEAREST);
        rt.bindFramebuffer(j.READ_FRAMEBUFFER, null), rt.bindFramebuffer(j.DRAW_FRAMEBUFFER, null);
      } else if (le !== 0 || U.isRenderTargetTexture || lt.has(U)) {
        const Cn = lt.get(U),
          Gn = lt.get(Q);
        rt.bindFramebuffer(j.READ_FRAMEBUFFER, it), rt.bindFramebuffer(j.DRAW_FRAMEBUFFER, Qe);
        for (let ai = 0; ai < Je; ai++)
          Yt
            ? j.framebufferTextureLayer(
                j.READ_FRAMEBUFFER,
                j.COLOR_ATTACHMENT0,
                Cn.__webglTexture,
                le,
                Xe + ai,
              )
            : j.framebufferTexture2D(
                j.READ_FRAMEBUFFER,
                j.COLOR_ATTACHMENT0,
                j.TEXTURE_2D,
                Cn.__webglTexture,
                le,
              ),
            Kn
              ? j.framebufferTextureLayer(
                  j.DRAW_FRAMEBUFFER,
                  j.COLOR_ATTACHMENT0,
                  Gn.__webglTexture,
                  Ae,
                  qt + ai,
                )
              : j.framebufferTexture2D(
                  j.DRAW_FRAMEBUFFER,
                  j.COLOR_ATTACHMENT0,
                  j.TEXTURE_2D,
                  Gn.__webglTexture,
                  Ae,
                ),
            le !== 0
              ? j.blitFramebuffer(ft, ut, Fe, Ve, mt, gt, Fe, Ve, j.COLOR_BUFFER_BIT, j.NEAREST)
              : Kn
              ? j.copyTexSubImage3D(cn, Ae, mt, gt, qt + ai, ft, ut, Fe, Ve)
              : j.copyTexSubImage2D(cn, Ae, mt, gt, ft, ut, Fe, Ve);
        rt.bindFramebuffer(j.READ_FRAMEBUFFER, null), rt.bindFramebuffer(j.DRAW_FRAMEBUFFER, null);
      } else
        Kn
          ? U.isDataTexture || U.isData3DTexture
            ? j.texSubImage3D(cn, Ae, mt, gt, qt, Fe, Ve, Je, Ut, Mt, Dt.data)
            : Q.isCompressedArrayTexture
            ? j.compressedTexSubImage3D(cn, Ae, mt, gt, qt, Fe, Ve, Je, Ut, Dt.data)
            : j.texSubImage3D(cn, Ae, mt, gt, qt, Fe, Ve, Je, Ut, Mt, Dt)
          : U.isDataTexture
          ? j.texSubImage2D(j.TEXTURE_2D, Ae, mt, gt, Fe, Ve, Ut, Mt, Dt.data)
          : U.isCompressedTexture
          ? j.compressedTexSubImage2D(j.TEXTURE_2D, Ae, mt, gt, Dt.width, Dt.height, Ut, Dt.data)
          : j.texSubImage2D(j.TEXTURE_2D, Ae, mt, gt, Fe, Ve, Ut, Mt, Dt);
      j.pixelStorei(j.UNPACK_ROW_LENGTH, Wt),
        j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, en),
        j.pixelStorei(j.UNPACK_SKIP_PIXELS, Hn),
        j.pixelStorei(j.UNPACK_SKIP_ROWS, on),
        j.pixelStorei(j.UNPACK_SKIP_IMAGES, pn),
        Ae === 0 && Q.generateMipmaps && j.generateMipmap(cn),
        rt.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (U, Q, ee = null, q = null, le = 0) {
        return (
          U.isTexture !== !0 &&
            (Cf('WebGLRenderer: copyTextureToTexture3D function signature has changed.'),
            (ee = arguments[0] || null),
            (q = arguments[1] || null),
            (U = arguments[2]),
            (Q = arguments[3]),
            (le = arguments[4] || 0)),
          Cf(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(U, Q, ee, q, le)
        );
      }),
      (this.initRenderTarget = function (U) {
        lt.get(U).__webglFramebuffer === void 0 && K.setupRenderTarget(U);
      }),
      (this.initTexture = function (U) {
        U.isCubeTexture
          ? K.setTextureCube(U, 0)
          : U.isData3DTexture
          ? K.setTexture3D(U, 0)
          : U.isDataArrayTexture || U.isCompressedArrayTexture
          ? K.setTexture2DArray(U, 0)
          : K.setTexture2D(U, 0),
          rt.unbindTexture();
      }),
      (this.resetState = function () {
        (N = 0), (G = 0), (k = null), rt.reset(), tt.reset();
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
  }
  get coordinateSystem() {
    return ho;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorspace = bn._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = bn._getUnpackColorSpace());
  }
}
const OP = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: Ty,
      AddEquation: Ml,
      AddOperation: ZS,
      AdditiveAnimationBlendMode: Fy,
      AdditiveBlending: sy,
      AgXToneMapping: tM,
      AlphaFormat: by,
      AlwaysCompare: vM,
      AlwaysDepth: qm,
      AlwaysStencilFunc: cy,
      AmbientLight: iE,
      AnimationAction: hE,
      AnimationClip: Vf,
      AnimationLoader: iT,
      AnimationMixer: RT,
      AnimationObjectGroup: CT,
      AnimationUtils: $C,
      ArcCurve: BM,
      ArrayCamera: cE,
      ArrowHelper: ZT,
      AttachedBindMode: ly,
      Audio: fE,
      AudioAnalyser: gT,
      AudioContext: c_,
      AudioListener: hT,
      AudioLoader: cT,
      AxesHelper: QT,
      BackSide: Or,
      BasicDepthPacking: lM,
      BasicShadowMap: IS,
      BatchedMesh: bM,
      Bone: Zg,
      BooleanKeyframeTrack: ac,
      Box2: NT,
      Box3: Ar,
      Box3Helper: KT,
      BoxGeometry: oc,
      BoxHelper: YT,
      BufferAttribute: Pn,
      BufferGeometry: hn,
      BufferGeometryLoader: lE,
      ByteType: kg,
      Cache: Pa,
      Camera: kh,
      CameraHelper: JT,
      CanvasTexture: MC,
      CapsuleGeometry: ev,
      CatmullRomCurve3: PM,
      CineonToneMapping: $S,
      CircleGeometry: tv,
      ClampToEdgeWrapping: Ai,
      Clock: f_,
      Color: At,
      ColorKeyframeTrack: r_,
      ColorManagement: bn,
      CompressedArrayTexture: AC,
      CompressedCubeTexture: SC,
      CompressedTexture: qg,
      CompressedTextureLoader: rT,
      ConeGeometry: nv,
      ConstantAlphaFactor: YS,
      ConstantColorFactor: XS,
      Controls: $T,
      CubeCamera: wM,
      CubeReflectionMapping: Oo,
      CubeRefractionMapping: Tl,
      CubeTexture: zh,
      CubeTextureLoader: tE,
      CubeUVReflectionMapping: Xf,
      CubicBezierCurve: jy,
      CubicBezierCurve3: DM,
      CubicInterpolant: QM,
      CullFaceBack: ry,
      CullFaceFront: bS,
      CullFaceFrontBack: O1,
      CullFaceNone: RS,
      Curve: go,
      CurvePath: FM,
      CustomBlending: BS,
      CustomToneMapping: eM,
      CylinderGeometry: Jf,
      Cylindrical: FT,
      Data3DTexture: Yg,
      DataArrayTexture: Oh,
      DataTexture: po,
      DataTextureLoader: s_,
      DataUtils: Gu,
      DecrementStencilOp: K1,
      DecrementWrapStencilOp: Z1,
      DefaultLoadingManager: eE,
      DepthFormat: Yu,
      DepthStencilFormat: $u,
      DepthTexture: Yy,
      DetachedBindMode: iM,
      DirectionalLight: u_,
      DirectionalLightHelper: XT,
      DiscreteInterpolant: qM,
      DodecahedronGeometry: iv,
      DoubleSide: gs,
      DstAlphaFactor: zS,
      DstColorFactor: GS,
      DynamicCopyUsage: fw,
      DynamicDrawUsage: sw,
      DynamicReadUsage: lw,
      EdgesGeometry: NM,
      EllipseCurve: $g,
      EqualCompare: hM,
      EqualDepth: eg,
      EqualStencilFunc: ew,
      EquirectangularReflectionMapping: Nf,
      EquirectangularRefractionMapping: xh,
      Euler: ys,
      EventDispatcher: Ho,
      ExtrudeGeometry: sv,
      FileLoader: ar,
      Float16BufferAttribute: tC,
      Float32BufferAttribute: kt,
      FloatType: fi,
      Fog: jg,
      FogExp2: Kg,
      FramebufferTexture: xC,
      FrontSide: Uo,
      Frustum: Wh,
      GLBufferAttribute: LT,
      GLSL1: hw,
      GLSL3: fy,
      GreaterCompare: pM,
      GreaterDepth: ng,
      GreaterEqualCompare: gM,
      GreaterEqualDepth: tg,
      GreaterEqualStencilFunc: rw,
      GreaterStencilFunc: nw,
      GridHelper: VT,
      Group: Ba,
      HalfFloatType: Yi,
      HemisphereLight: nE,
      HemisphereLightHelper: GT,
      IcosahedronGeometry: Jh,
      ImageBitmapLoader: uE,
      ImageLoader: Ih,
      ImageUtils: AM,
      IncrementStencilOp: Y1,
      IncrementWrapStencilOp: j1,
      InstancedBufferAttribute: ec,
      InstancedBufferGeometry: aE,
      InstancedInterleavedBuffer: DT,
      InstancedMesh: Wy,
      Int16BufferAttribute: $w,
      Int32BufferAttribute: eC,
      Int8BufferAttribute: Zw,
      IntType: Fh,
      InterleavedBuffer: Gh,
      InterleavedBufferAttribute: bl,
      Interpolant: Yf,
      InterpolateDiscrete: kf,
      InterpolateLinear: zf,
      InterpolateSmooth: Xm,
      InvertStencilOp: Q1,
      KeepStencilOp: Fu,
      KeyframeTrack: vo,
      LOD: RM,
      LatheGeometry: Xh,
      Layers: ju,
      LessCompare: dM,
      LessDepth: $m,
      LessEqualCompare: Uy,
      LessEqualDepth: Qu,
      LessEqualStencilFunc: tw,
      LessStencilFunc: $1,
      Light: Dl,
      LightProbe: oE,
      Line: Fa,
      Line3: UT,
      LineBasicMaterial: Sr,
      LineCurve: Zy,
      LineCurve3: LM,
      LineDashedMaterial: KM,
      LineLoop: Xy,
      LineSegments: mo,
      LinearFilter: Fn,
      LinearInterpolant: i_,
      LinearMipMapLinearFilter: uy,
      LinearMipMapNearestFilter: H1,
      LinearMipmapLinearFilter: Ds,
      LinearMipmapNearestFilter: Pf,
      LinearSRGBColorSpace: zo,
      LinearToneMapping: QS,
      LinearTransfer: Sh,
      Loader: lr,
      LoaderUtils: wl,
      LoadingManager: dv,
      LoopOnce: rM,
      LoopPingPong: oM,
      LoopRepeat: sM,
      LuminanceAlphaFormat: Py,
      LuminanceFormat: By,
      MOUSE: Du,
      Material: Oi,
      MaterialLoader: hv,
      MathUtils: yM,
      Matrix2: g_,
      Matrix3: dn,
      Matrix4: Qt,
      MaxEquation: FS,
      Mesh: oi,
      MeshBasicMaterial: ts,
      MeshDepthMaterial: e_,
      MeshDistanceMaterial: t_,
      MeshLambertMaterial: JM,
      MeshMatcapMaterial: YM,
      MeshNormalMaterial: XM,
      MeshPhongMaterial: VM,
      MeshPhysicalMaterial: Ns,
      MeshStandardMaterial: jh,
      MeshToonMaterial: WM,
      MinEquation: LS,
      MirroredRepeatWrapping: Uf,
      MixOperation: jS,
      MultiplyBlending: ay,
      MultiplyOperation: Lh,
      NearestFilter: Ki,
      NearestMipMapLinearFilter: z1,
      NearestMipMapNearestFilter: k1,
      NearestMipmapLinearFilter: Ou,
      NearestMipmapNearestFilter: Og,
      NeutralToneMapping: nM,
      NeverCompare: fM,
      NeverDepth: Qm,
      NeverStencilFunc: q1,
      NoBlending: Do,
      NoColorSpace: ba,
      NoToneMapping: Lo,
      NormalAnimationBlendMode: Xg,
      NormalBlending: Ju,
      NotEqualCompare: mM,
      NotEqualDepth: ig,
      NotEqualStencilFunc: iw,
      NumberKeyframeTrack: nc,
      Object3D: wn,
      ObjectLoader: lT,
      ObjectSpaceNormalMap: cM,
      OctahedronGeometry: Yh,
      OneFactor: US,
      OneMinusConstantAlphaFactor: KS,
      OneMinusConstantColorFactor: JS,
      OneMinusDstAlphaFactor: HS,
      OneMinusDstColorFactor: VS,
      OneMinusSrcAlphaFactor: Zm,
      OneMinusSrcColorFactor: kS,
      OrthographicCamera: No,
      PCFShadowMap: Ug,
      PCFSoftShadowMap: ch,
      PMREMGenerator: _y,
      Path: Ch,
      PerspectiveCamera: gi,
      Plane: Ra,
      PlaneGeometry: Pl,
      PlaneHelper: jT,
      PointLight: l_,
      PointLightHelper: zT,
      Points: Jy,
      PointsMaterial: Qg,
      PolarGridHelper: WT,
      PolyhedronGeometry: Bl,
      PositionalAudio: mT,
      PropertyBinding: Rn,
      PropertyMixer: dE,
      QuadraticBezierCurve: Qy,
      QuadraticBezierCurve3: qy,
      Quaternion: ji,
      QuaternionKeyframeTrack: ic,
      QuaternionLinearInterpolant: $M,
      RED_GREEN_RGTC2_Format: Rg,
      RED_RGTC1_Format: Ly,
      REVISION: Dh,
      RGBADepthPacking: uM,
      RGBAFormat: Si,
      RGBAIntegerFormat: Wg,
      RGBA_ASTC_10x10_Format: Sg,
      RGBA_ASTC_10x5_Format: _g,
      RGBA_ASTC_10x6_Format: xg,
      RGBA_ASTC_10x8_Format: Ag,
      RGBA_ASTC_12x10_Format: Mg,
      RGBA_ASTC_12x12_Format: Eg,
      RGBA_ASTC_4x4_Format: fg,
      RGBA_ASTC_5x4_Format: dg,
      RGBA_ASTC_5x5_Format: hg,
      RGBA_ASTC_6x5_Format: pg,
      RGBA_ASTC_6x6_Format: mg,
      RGBA_ASTC_8x5_Format: gg,
      RGBA_ASTC_8x6_Format: vg,
      RGBA_ASTC_8x8_Format: yg,
      RGBA_BPTC_Format: mh,
      RGBA_ETC2_EAC_Format: cg,
      RGBA_PVRTC_2BPPV1_Format: ag,
      RGBA_PVRTC_4BPPV1_Format: og,
      RGBA_S3TC_DXT1_Format: dh,
      RGBA_S3TC_DXT3_Format: hh,
      RGBA_S3TC_DXT5_Format: ph,
      RGBDepthPacking: V1,
      RGBFormat: Iy,
      RGBIntegerFormat: G1,
      RGB_BPTC_SIGNED_Format: wg,
      RGB_BPTC_UNSIGNED_Format: Cg,
      RGB_ETC1_Format: lg,
      RGB_ETC2_Format: ug,
      RGB_PVRTC_2BPPV1_Format: sg,
      RGB_PVRTC_4BPPV1_Format: rg,
      RGB_S3TC_DXT1_Format: fh,
      RGDepthPacking: W1,
      RGFormat: Dy,
      RGIntegerFormat: Vg,
      RawShaderMaterial: GM,
      Ray: sc,
      Raycaster: m_,
      RectAreaLight: rE,
      RedFormat: Nh,
      RedIntegerFormat: Uh,
      ReinhardToneMapping: qS,
      RenderTarget: Jg,
      RenderTarget3D: bT,
      RenderTargetArray: IT,
      RepeatWrapping: Rl,
      ReplaceStencilOp: J1,
      ReverseSubtractEquation: DS,
      RingGeometry: ov,
      SIGNED_RED_GREEN_RGTC2_Format: bg,
      SIGNED_RED_RGTC1_Format: Tg,
      SRGBColorSpace: xr,
      SRGBTransfer: zn,
      Scene: Hh,
      ShaderChunk: yn,
      ShaderLib: fo,
      ShaderMaterial: is,
      ShadowMaterial: HM,
      Shape: Zu,
      ShapeGeometry: av,
      ShapePath: qT,
      ShapeUtils: Fo,
      ShortType: zg,
      Skeleton: Vh,
      SkeletonHelper: kT,
      SkinnedMesh: Vy,
      Source: Hu,
      Sphere: or,
      SphereGeometry: Kh,
      Spherical: vy,
      SphericalHarmonics3: sE,
      SplineCurve: $y,
      SpotLight: a_,
      SpotLightHelper: OT,
      Sprite: TM,
      SpriteMaterial: Gy,
      SrcAlphaFactor: jm,
      SrcAlphaSaturateFactor: WS,
      SrcColorFactor: OS,
      StaticCopyUsage: cw,
      StaticDrawUsage: Mh,
      StaticReadUsage: aw,
      StereoCamera: fT,
      StreamCopyUsage: dw,
      StreamDrawUsage: ow,
      StreamReadUsage: uw,
      StringKeyframeTrack: lc,
      SubtractEquation: PS,
      SubtractiveBlending: oy,
      TOUCH: Lu,
      TangentSpaceNormalMap: Il,
      TetrahedronGeometry: lv,
      Texture: Ln,
      TextureLoader: Zh,
      TextureUtils: rR,
      TimestampQuery: pw,
      TorusGeometry: uv,
      TorusKnotGeometry: cv,
      Triangle: es,
      TriangleFanDrawMode: Ig,
      TriangleStripDrawMode: Ny,
      TrianglesDrawMode: aM,
      TubeGeometry: fv,
      UVMapping: Cl,
      Uint16BufferAttribute: ky,
      Uint32BufferAttribute: zy,
      Uint8BufferAttribute: Qw,
      Uint8ClampedBufferAttribute: qw,
      Uniform: p_,
      UniformsGroup: PT,
      UniformsLib: xt,
      UniformsUtils: EM,
      UnsignedByteType: ns,
      UnsignedInt248Type: qu,
      UnsignedInt5999Type: Ry,
      UnsignedIntType: ko,
      UnsignedShort4444Type: Hg,
      UnsignedShort5551Type: Gg,
      UnsignedShortType: Of,
      VSMShadowMap: co,
      Vector2: Ge,
      Vector3: J,
      Vector4: Bn,
      VectorKeyframeTrack: rc,
      VideoFrameTexture: _C,
      VideoTexture: IM,
      WebGL3DRenderTarget: kw,
      WebGLArrayRenderTarget: Ow,
      WebGLCoordinateSystem: ho,
      WebGLCubeRenderTarget: Hy,
      WebGLRenderTarget: Ls,
      WebGLRenderer: y_,
      WebGLUtils: xE,
      WebGPUCoordinateSystem: Eh,
      WebXRController: Jm,
      WireframeGeometry: zM,
      WrapAroundEnding: Ah,
      ZeroCurvatureEnding: ku,
      ZeroFactor: NS,
      ZeroSlopeEnding: zu,
      ZeroStencilOp: X1,
      createCanvasElement: xM,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var U0 = { exports: {} },
  _l = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ZA;
function kP() {
  return (
    ZA ||
      ((ZA = 1),
      (_l.ConcurrentRoot = 1),
      (_l.ContinuousEventPriority = 4),
      (_l.DefaultEventPriority = 16),
      (_l.DiscreteEventPriority = 1),
      (_l.IdleEventPriority = 536870912),
      (_l.LegacyRoot = 0)),
    _l
  );
}
var QA;
function zP() {
  return QA || ((QA = 1), (U0.exports = kP())), U0.exports;
}
var uh = zP();
function HP(r) {
  let e;
  const t = new Set(),
    n = (h, m) => {
      const g = typeof h == 'function' ? h(e) : h;
      if (g !== e) {
        const v = e;
        (e = m ? g : Object.assign({}, e, g)), t.forEach((x) => x(e, v));
      }
    },
    i = () => e,
    o = (h, m = i, g = Object.is) => {
      console.warn('[DEPRECATED] Please use `subscribeWithSelector` middleware');
      let v = m(e);
      function x() {
        const A = m(e);
        if (!g(v, A)) {
          const C = v;
          h((v = A), C);
        }
      }
      return t.add(x), () => t.delete(x);
    },
    d = {
      setState: n,
      getState: i,
      subscribe: (h, m, g) => (m || g ? o(h, m, g) : (t.add(h), () => t.delete(h))),
      destroy: () => t.clear(),
    };
  return (e = r(n, i, d)), d;
}
const GP =
    typeof window > 'u' ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  qA = GP ? je.useEffect : je.useLayoutEffect;
function AE(r) {
  const e = typeof r == 'function' ? HP(r) : r,
    t = (n = e.getState, i = Object.is) => {
      const [, o] = je.useReducer((E) => E + 1, 0),
        a = e.getState(),
        u = je.useRef(a),
        d = je.useRef(n),
        h = je.useRef(i),
        m = je.useRef(!1),
        g = je.useRef();
      g.current === void 0 && (g.current = n(a));
      let v,
        x = !1;
      (u.current !== a || d.current !== n || h.current !== i || m.current) &&
        ((v = n(a)), (x = !i(g.current, v))),
        qA(() => {
          x && (g.current = v), (u.current = a), (d.current = n), (h.current = i), (m.current = !1);
        });
      const A = je.useRef(a);
      qA(() => {
        const E = () => {
            try {
              const b = e.getState(),
                I = d.current(b);
              h.current(g.current, I) || ((u.current = b), (g.current = I), o());
            } catch {
              (m.current = !0), o();
            }
          },
          S = e.subscribe(E);
        return e.getState() !== A.current && E(), S;
      }, []);
      const C = x ? v : g.current;
      return je.useDebugValue(C), C;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn('[useStore, api] = create() is deprecated and will be removed in v4');
      const n = [t, e];
      return {
        next() {
          const i = n.length <= 0;
          return { value: n.shift(), done: i };
        },
      };
    }),
    t
  );
}
const VP = (r) => typeof r == 'object' && typeof r.then == 'function',
  Wu = [];
function SE(r, e, t = (n, i) => n === i) {
  if (r === e) return !0;
  if (!r || !e) return !1;
  const n = r.length;
  if (e.length !== n) return !1;
  for (let i = 0; i < n; i++) if (!t(r[i], e[i])) return !1;
  return !0;
}
function ME(r, e = null, t = !1, n = {}) {
  e === null && (e = [r]);
  for (const o of Wu)
    if (SE(e, o.keys, o.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(o, 'error')) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, 'response'))
        return (
          n.lifespan &&
            n.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout), (o.timeout = setTimeout(o.remove, n.lifespan))),
          o.response
        );
      if (!t) throw o.promise;
    }
  const i = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const o = Wu.indexOf(i);
      o !== -1 && Wu.splice(o, 1);
    },
    promise: (VP(r) ? r : r(...e))
      .then((o) => {
        (i.response = o),
          n.lifespan && n.lifespan > 0 && (i.timeout = setTimeout(i.remove, n.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((Wu.push(i), !t)) throw i.promise;
}
const WP = (r, e, t) => ME(r, e, !1, t),
  XP = (r, e, t) => void ME(r, e, !0, t),
  JP = (r) => {
    if (r === void 0 || r.length === 0) Wu.splice(0, Wu.length);
    else {
      const e = Wu.find((t) => SE(r, t.keys, t.equal));
      e && e.remove();
    }
  };
var O0 = { exports: {} },
  k0 = { exports: {} },
  z0 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $A;
function YP() {
  return (
    $A ||
      (($A = 1),
      (function (r) {
        function e(X, fe) {
          var te = X.length;
          X.push(fe);
          e: for (; 0 < te; ) {
            var Y = (te - 1) >>> 1,
              ue = X[Y];
            if (0 < i(ue, fe)) (X[Y] = fe), (X[te] = ue), (te = Y);
            else break e;
          }
        }
        function t(X) {
          return X.length === 0 ? null : X[0];
        }
        function n(X) {
          if (X.length === 0) return null;
          var fe = X[0],
            te = X.pop();
          if (te !== fe) {
            X[0] = te;
            e: for (var Y = 0, ue = X.length, He = ue >>> 1; Y < He; ) {
              var ge = 2 * (Y + 1) - 1,
                De = X[ge],
                Ie = ge + 1,
                Ue = X[Ie];
              if (0 > i(De, te))
                Ie < ue && 0 > i(Ue, De)
                  ? ((X[Y] = Ue), (X[Ie] = te), (Y = Ie))
                  : ((X[Y] = De), (X[ge] = te), (Y = ge));
              else if (Ie < ue && 0 > i(Ue, te)) (X[Y] = Ue), (X[Ie] = te), (Y = Ie);
              else break e;
            }
          }
          return fe;
        }
        function i(X, fe) {
          var te = X.sortIndex - fe.sortIndex;
          return te !== 0 ? te : X.id - fe.id;
        }
        if (typeof performance == 'object' && typeof performance.now == 'function') {
          var o = performance;
          r.unstable_now = function () {
            return o.now();
          };
        } else {
          var a = Date,
            u = a.now();
          r.unstable_now = function () {
            return a.now() - u;
          };
        }
        var d = [],
          h = [],
          m = 1,
          g = null,
          v = 3,
          x = !1,
          A = !1,
          C = !1,
          E = typeof setTimeout == 'function' ? setTimeout : null,
          S = typeof clearTimeout == 'function' ? clearTimeout : null,
          b = typeof setImmediate < 'u' ? setImmediate : null;
        typeof navigator < 'u' &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function I(X) {
          for (var fe = t(h); fe !== null; ) {
            if (fe.callback === null) n(h);
            else if (fe.startTime <= X) n(h), (fe.sortIndex = fe.expirationTime), e(d, fe);
            else break;
            fe = t(h);
          }
        }
        function B(X) {
          if (((C = !1), I(X), !A))
            if (t(d) !== null) (A = !0), de(z);
            else {
              var fe = t(h);
              fe !== null && Ce(B, fe.startTime - X);
            }
        }
        function z(X, fe) {
          (A = !1), C && ((C = !1), S(k), (k = -1)), (x = !0);
          var te = v;
          try {
            for (I(fe), g = t(d); g !== null && (!(g.expirationTime > fe) || (X && !V())); ) {
              var Y = g.callback;
              if (typeof Y == 'function') {
                (g.callback = null), (v = g.priorityLevel);
                var ue = Y(g.expirationTime <= fe);
                (fe = r.unstable_now()),
                  typeof ue == 'function' ? (g.callback = ue) : g === t(d) && n(d),
                  I(fe);
              } else n(d);
              g = t(d);
            }
            if (g !== null) var He = !0;
            else {
              var ge = t(h);
              ge !== null && Ce(B, ge.startTime - fe), (He = !1);
            }
            return He;
          } finally {
            (g = null), (v = te), (x = !1);
          }
        }
        var N = !1,
          G = null,
          k = -1,
          L = 5,
          D = -1;
        function V() {
          return !(r.unstable_now() - D < L);
        }
        function oe() {
          if (G !== null) {
            var X = r.unstable_now();
            D = X;
            var fe = !0;
            try {
              fe = G(!0, X);
            } finally {
              fe ? ie() : ((N = !1), (G = null));
            }
          } else N = !1;
        }
        var ie;
        if (typeof b == 'function')
          ie = function () {
            b(oe);
          };
        else if (typeof MessageChannel < 'u') {
          var ce = new MessageChannel(),
            xe = ce.port2;
          (ce.port1.onmessage = oe),
            (ie = function () {
              xe.postMessage(null);
            });
        } else
          ie = function () {
            E(oe, 0);
          };
        function de(X) {
          (G = X), N || ((N = !0), ie());
        }
        function Ce(X, fe) {
          k = E(function () {
            X(r.unstable_now());
          }, fe);
        }
        (r.unstable_IdlePriority = 5),
          (r.unstable_ImmediatePriority = 1),
          (r.unstable_LowPriority = 4),
          (r.unstable_NormalPriority = 3),
          (r.unstable_Profiling = null),
          (r.unstable_UserBlockingPriority = 2),
          (r.unstable_cancelCallback = function (X) {
            X.callback = null;
          }),
          (r.unstable_continueExecution = function () {
            A || x || ((A = !0), de(z));
          }),
          (r.unstable_forceFrameRate = function (X) {
            0 > X || 125 < X
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported',
                )
              : (L = 0 < X ? Math.floor(1e3 / X) : 5);
          }),
          (r.unstable_getCurrentPriorityLevel = function () {
            return v;
          }),
          (r.unstable_getFirstCallbackNode = function () {
            return t(d);
          }),
          (r.unstable_next = function (X) {
            switch (v) {
              case 1:
              case 2:
              case 3:
                var fe = 3;
                break;
              default:
                fe = v;
            }
            var te = v;
            v = fe;
            try {
              return X();
            } finally {
              v = te;
            }
          }),
          (r.unstable_pauseExecution = function () {}),
          (r.unstable_requestPaint = function () {}),
          (r.unstable_runWithPriority = function (X, fe) {
            switch (X) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                X = 3;
            }
            var te = v;
            v = X;
            try {
              return fe();
            } finally {
              v = te;
            }
          }),
          (r.unstable_scheduleCallback = function (X, fe, te) {
            var Y = r.unstable_now();
            switch (
              (typeof te == 'object' && te !== null
                ? ((te = te.delay), (te = typeof te == 'number' && 0 < te ? Y + te : Y))
                : (te = Y),
              X)
            ) {
              case 1:
                var ue = -1;
                break;
              case 2:
                ue = 250;
                break;
              case 5:
                ue = 1073741823;
                break;
              case 4:
                ue = 1e4;
                break;
              default:
                ue = 5e3;
            }
            return (
              (ue = te + ue),
              (X = {
                id: m++,
                callback: fe,
                priorityLevel: X,
                startTime: te,
                expirationTime: ue,
                sortIndex: -1,
              }),
              te > Y
                ? ((X.sortIndex = te),
                  e(h, X),
                  t(d) === null && X === t(h) && (C ? (S(k), (k = -1)) : (C = !0), Ce(B, te - Y)))
                : ((X.sortIndex = ue), e(d, X), A || x || ((A = !0), de(z))),
              X
            );
          }),
          (r.unstable_shouldYield = V),
          (r.unstable_wrapCallback = function (X) {
            var fe = v;
            return function () {
              var te = v;
              v = fe;
              try {
                return X.apply(this, arguments);
              } finally {
                v = te;
              }
            };
          });
      })(z0)),
    z0
  );
}
var eS;
function EE() {
  return eS || ((eS = 1), (k0.exports = YP())), k0.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var H0, tS;
function KP() {
  return (
    tS ||
      ((tS = 1),
      (H0 = function (e) {
        var t = {},
          n = Ng(),
          i = EE(),
          o = Object.assign;
        function a(c) {
          for (
            var f = 'https://reactjs.org/docs/error-decoder.html?invariant=' + c, y = 1;
            y < arguments.length;
            y++
          )
            f += '&args[]=' + encodeURIComponent(arguments[y]);
          return (
            'Minified React error #' +
            c +
            '; visit ' +
            f +
            ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
          );
        }
        var u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          d = Symbol.for('react.element'),
          h = Symbol.for('react.portal'),
          m = Symbol.for('react.fragment'),
          g = Symbol.for('react.strict_mode'),
          v = Symbol.for('react.profiler'),
          x = Symbol.for('react.provider'),
          A = Symbol.for('react.context'),
          C = Symbol.for('react.forward_ref'),
          E = Symbol.for('react.suspense'),
          S = Symbol.for('react.suspense_list'),
          b = Symbol.for('react.memo'),
          I = Symbol.for('react.lazy'),
          B = Symbol.for('react.offscreen'),
          z = Symbol.iterator;
        function N(c) {
          return c === null || typeof c != 'object'
            ? null
            : ((c = (z && c[z]) || c['@@iterator']), typeof c == 'function' ? c : null);
        }
        function G(c) {
          if (c == null) return null;
          if (typeof c == 'function') return c.displayName || c.name || null;
          if (typeof c == 'string') return c;
          switch (c) {
            case m:
              return 'Fragment';
            case h:
              return 'Portal';
            case v:
              return 'Profiler';
            case g:
              return 'StrictMode';
            case E:
              return 'Suspense';
            case S:
              return 'SuspenseList';
          }
          if (typeof c == 'object')
            switch (c.$$typeof) {
              case A:
                return (c.displayName || 'Context') + '.Consumer';
              case x:
                return (c._context.displayName || 'Context') + '.Provider';
              case C:
                var f = c.render;
                return (
                  (c = c.displayName),
                  c ||
                    ((c = f.displayName || f.name || ''),
                    (c = c !== '' ? 'ForwardRef(' + c + ')' : 'ForwardRef')),
                  c
                );
              case b:
                return (f = c.displayName || null), f !== null ? f : G(c.type) || 'Memo';
              case I:
                (f = c._payload), (c = c._init);
                try {
                  return G(c(f));
                } catch {}
            }
          return null;
        }
        function k(c) {
          var f = c.type;
          switch (c.tag) {
            case 24:
              return 'Cache';
            case 9:
              return (f.displayName || 'Context') + '.Consumer';
            case 10:
              return (f._context.displayName || 'Context') + '.Provider';
            case 18:
              return 'DehydratedFragment';
            case 11:
              return (
                (c = f.render),
                (c = c.displayName || c.name || ''),
                f.displayName || (c !== '' ? 'ForwardRef(' + c + ')' : 'ForwardRef')
              );
            case 7:
              return 'Fragment';
            case 5:
              return f;
            case 4:
              return 'Portal';
            case 3:
              return 'Root';
            case 6:
              return 'Text';
            case 16:
              return G(f);
            case 8:
              return f === g ? 'StrictMode' : 'Mode';
            case 22:
              return 'Offscreen';
            case 12:
              return 'Profiler';
            case 21:
              return 'Scope';
            case 13:
              return 'Suspense';
            case 19:
              return 'SuspenseList';
            case 25:
              return 'TracingMarker';
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if (typeof f == 'function') return f.displayName || f.name || null;
              if (typeof f == 'string') return f;
          }
          return null;
        }
        function L(c) {
          var f = c,
            y = c;
          if (c.alternate) for (; f.return; ) f = f.return;
          else {
            c = f;
            do (f = c), f.flags & 4098 && (y = f.return), (c = f.return);
            while (c);
          }
          return f.tag === 3 ? y : null;
        }
        function D(c) {
          if (L(c) !== c) throw Error(a(188));
        }
        function V(c) {
          var f = c.alternate;
          if (!f) {
            if (((f = L(c)), f === null)) throw Error(a(188));
            return f !== c ? null : c;
          }
          for (var y = c, M = f; ; ) {
            var T = y.return;
            if (T === null) break;
            var P = T.alternate;
            if (P === null) {
              if (((M = T.return), M !== null)) {
                y = M;
                continue;
              }
              break;
            }
            if (T.child === P.child) {
              for (P = T.child; P; ) {
                if (P === y) return D(T), c;
                if (P === M) return D(T), f;
                P = P.sibling;
              }
              throw Error(a(188));
            }
            if (y.return !== M.return) (y = T), (M = P);
            else {
              for (var Z = !1, pe = T.child; pe; ) {
                if (pe === y) {
                  (Z = !0), (y = T), (M = P);
                  break;
                }
                if (pe === M) {
                  (Z = !0), (M = T), (y = P);
                  break;
                }
                pe = pe.sibling;
              }
              if (!Z) {
                for (pe = P.child; pe; ) {
                  if (pe === y) {
                    (Z = !0), (y = P), (M = T);
                    break;
                  }
                  if (pe === M) {
                    (Z = !0), (M = P), (y = T);
                    break;
                  }
                  pe = pe.sibling;
                }
                if (!Z) throw Error(a(189));
              }
            }
            if (y.alternate !== M) throw Error(a(190));
          }
          if (y.tag !== 3) throw Error(a(188));
          return y.stateNode.current === y ? c : f;
        }
        function oe(c) {
          return (c = V(c)), c !== null ? ie(c) : null;
        }
        function ie(c) {
          if (c.tag === 5 || c.tag === 6) return c;
          for (c = c.child; c !== null; ) {
            var f = ie(c);
            if (f !== null) return f;
            c = c.sibling;
          }
          return null;
        }
        function ce(c) {
          if (c.tag === 5 || c.tag === 6) return c;
          for (c = c.child; c !== null; ) {
            if (c.tag !== 4) {
              var f = ce(c);
              if (f !== null) return f;
            }
            c = c.sibling;
          }
          return null;
        }
        var xe = Array.isArray,
          de = e.getPublicInstance,
          Ce = e.getRootHostContext,
          X = e.getChildHostContext,
          fe = e.prepareForCommit,
          te = e.resetAfterCommit,
          Y = e.createInstance,
          ue = e.appendInitialChild,
          He = e.finalizeInitialChildren,
          ge = e.prepareUpdate,
          De = e.shouldSetTextContent,
          Ie = e.createTextInstance,
          Ue = e.scheduleTimeout,
          et = e.cancelTimeout,
          Bt = e.noTimeout,
          ht = e.isPrimaryRenderer,
          Jt = e.supportsMutation,
          Ye = e.supportsPersistence,
          ke = e.supportsHydration,
          j = e.getInstanceFromNode,
          It = e.preparePortalMount,
          qe = e.getCurrentEventPriority,
          yt = e.detachDeletedInstance,
          rt = e.supportsMicrotasks,
          Ht = e.scheduleMicrotask,
          lt = e.supportsTestSelectors,
          K = e.findFiberRoot,
          H = e.getBoundingRect,
          ve = e.getTextContent,
          Le = e.isHiddenSubtree,
          We = e.matchAccessibilityRole,
          ze = e.setFocusIfFocusable,
          Ct = e.setupIntersectionObserver,
          at = e.appendChild,
          pt = e.appendChildToContainer,
          $t = e.commitTextUpdate,
          Ze = e.commitMount,
          wt = e.commitUpdate,
          Ft = e.insertBefore,
          Rt = e.insertInContainerBefore,
          St = e.removeChild,
          re = e.removeChildFromContainer,
          Re = e.resetTextContent,
          tt = e.hideInstance,
          ne = e.hideTextInstance,
          ye = e.unhideInstance,
          we = e.unhideTextInstance,
          Oe = e.clearContainer,
          vt = e.cloneInstance,
          dt = e.createContainerChildSet,
          Gt = e.appendChildToContainerChildSet,
          _n = e.finalizeContainerChildren,
          Nn = e.replaceContainerChildren,
          an = e.cloneHiddenInstance,
          qn = e.cloneHiddenTextInstance,
          ni = e.canHydrateInstance,
          yo = e.canHydrateTextInstance,
          _s = e.canHydrateSuspenseInstance,
          Zi = e.isSuspenseInstancePending,
          Mr = e.isSuspenseInstanceFallback,
          Er = e.registerSuspenseInstanceRetry,
          Ii = e.getNextHydratableSibling,
          nn = e.getFirstHydratableChild,
          Go = e.getFirstHydratableChildWithinContainer,
          _o = e.getFirstHydratableChildWithinSuspenseInstance,
          F = e.hydrateInstance,
          W = e.hydrateTextInstance,
          se = e.hydrateSuspenseInstance,
          Ee = e.getNextHydratableInstanceAfterSuspenseInstance,
          Be = e.commitHydratedContainer,
          Pe = e.commitHydratedSuspenseInstance,
          it = e.clearSuspenseBoundary,
          Qe = e.clearSuspenseBoundaryFromContainer,
          U = e.shouldDeleteUnhydratedTailInstances,
          Q = e.didNotMatchHydratedContainerTextInstance,
          ee = e.didNotMatchHydratedTextInstance,
          q;
        function le(c) {
          if (q === void 0)
            try {
              throw Error();
            } catch (y) {
              var f = y.stack.trim().match(/\n( *(at )?)/);
              q = (f && f[1]) || '';
            }
          return (
            `
` +
            q +
            c
          );
        }
        var Ae = !1;
        function Fe(c, f) {
          if (!c || Ae) return '';
          Ae = !0;
          var y = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (f)
              if (
                ((f = function () {
                  throw Error();
                }),
                Object.defineProperty(f.prototype, 'props', {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == 'object' && Reflect.construct)
              ) {
                try {
                  Reflect.construct(f, []);
                } catch (st) {
                  var M = st;
                }
                Reflect.construct(c, [], f);
              } else {
                try {
                  f.call();
                } catch (st) {
                  M = st;
                }
                c.call(f.prototype);
              }
            else {
              try {
                throw Error();
              } catch (st) {
                M = st;
              }
              c();
            }
          } catch (st) {
            if (st && M && typeof st.stack == 'string') {
              for (
                var T = st.stack.split(`
`),
                  P = M.stack.split(`
`),
                  Z = T.length - 1,
                  pe = P.length - 1;
                1 <= Z && 0 <= pe && T[Z] !== P[pe];

              )
                pe--;
              for (; 1 <= Z && 0 <= pe; Z--, pe--)
                if (T[Z] !== P[pe]) {
                  if (Z !== 1 || pe !== 1)
                    do
                      if ((Z--, pe--, 0 > pe || T[Z] !== P[pe])) {
                        var Ne =
                          `
` + T[Z].replace(' at new ', ' at ');
                        return (
                          c.displayName &&
                            Ne.includes('<anonymous>') &&
                            (Ne = Ne.replace('<anonymous>', c.displayName)),
                          Ne
                        );
                      }
                    while (1 <= Z && 0 <= pe);
                  break;
                }
            }
          } finally {
            (Ae = !1), (Error.prepareStackTrace = y);
          }
          return (c = c ? c.displayName || c.name : '') ? le(c) : '';
        }
        var Ve = Object.prototype.hasOwnProperty,
          Je = [],
          ft = -1;
        function ut(c) {
          return { current: c };
        }
        function Xe(c) {
          0 > ft || ((c.current = Je[ft]), (Je[ft] = null), ft--);
        }
        function mt(c, f) {
          ft++, (Je[ft] = c.current), (c.current = f);
        }
        var gt = {},
          qt = ut(gt),
          Dt = ut(!1),
          Ut = gt;
        function Mt(c, f) {
          var y = c.type.contextTypes;
          if (!y) return gt;
          var M = c.stateNode;
          if (M && M.__reactInternalMemoizedUnmaskedChildContext === f)
            return M.__reactInternalMemoizedMaskedChildContext;
          var T = {},
            P;
          for (P in y) T[P] = f[P];
          return (
            M &&
              ((c = c.stateNode),
              (c.__reactInternalMemoizedUnmaskedChildContext = f),
              (c.__reactInternalMemoizedMaskedChildContext = T)),
            T
          );
        }
        function cn(c) {
          return (c = c.childContextTypes), c != null;
        }
        function Wt() {
          Xe(Dt), Xe(qt);
        }
        function en(c, f, y) {
          if (qt.current !== gt) throw Error(a(168));
          mt(qt, f), mt(Dt, y);
        }
        function Hn(c, f, y) {
          var M = c.stateNode;
          if (((f = f.childContextTypes), typeof M.getChildContext != 'function')) return y;
          M = M.getChildContext();
          for (var T in M) if (!(T in f)) throw Error(a(108, k(c) || 'Unknown', T));
          return o({}, y, M);
        }
        function on(c) {
          return (
            (c = ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) || gt),
            (Ut = qt.current),
            mt(qt, c),
            mt(Dt, Dt.current),
            !0
          );
        }
        function pn(c, f, y) {
          var M = c.stateNode;
          if (!M) throw Error(a(169));
          y
            ? ((c = Hn(c, f, Ut)),
              (M.__reactInternalMemoizedMergedChildContext = c),
              Xe(Dt),
              Xe(qt),
              mt(qt, c))
            : Xe(Dt),
            mt(Dt, y);
        }
        var Yt = Math.clz32 ? Math.clz32 : Gn,
          Kn = Math.log,
          Cn = Math.LN2;
        function Gn(c) {
          return (c >>>= 0), c === 0 ? 32 : (31 - ((Kn(c) / Cn) | 0)) | 0;
        }
        var ai = 64,
          xn = 4194304;
        function ur(c) {
          switch (c & -c) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return c & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return c & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return c;
          }
        }
        function Ll(c, f) {
          var y = c.pendingLanes;
          if (y === 0) return 0;
          var M = 0,
            T = c.suspendedLanes,
            P = c.pingedLanes,
            Z = y & 268435455;
          if (Z !== 0) {
            var pe = Z & ~T;
            pe !== 0 ? (M = ur(pe)) : ((P &= Z), P !== 0 && (M = ur(P)));
          } else (Z = y & ~T), Z !== 0 ? (M = ur(Z)) : P !== 0 && (M = ur(P));
          if (M === 0) return 0;
          if (
            f !== 0 &&
            f !== M &&
            !(f & T) &&
            ((T = M & -M), (P = f & -f), T >= P || (T === 16 && (P & 4194240) !== 0))
          )
            return f;
          if ((M & 4 && (M |= y & 16), (f = c.entangledLanes), f !== 0))
            for (c = c.entanglements, f &= M; 0 < f; )
              (y = 31 - Yt(f)), (T = 1 << y), (M |= c[y]), (f &= ~T);
          return M;
        }
        function jf(c, f) {
          switch (c) {
            case 1:
            case 2:
            case 4:
              return f + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return f + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function ep(c, f) {
          for (
            var y = c.suspendedLanes, M = c.pingedLanes, T = c.expirationTimes, P = c.pendingLanes;
            0 < P;

          ) {
            var Z = 31 - Yt(P),
              pe = 1 << Z,
              Ne = T[Z];
            Ne === -1
              ? (!(pe & y) || pe & M) && (T[Z] = jf(pe, f))
              : Ne <= f && (c.expiredLanes |= pe),
              (P &= ~pe);
          }
        }
        function uc(c) {
          return (c = c.pendingLanes & -1073741825), c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
        }
        function cc(c) {
          for (var f = [], y = 0; 31 > y; y++) f.push(c);
          return f;
        }
        function Vo(c, f, y) {
          (c.pendingLanes |= f),
            f !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
            (c = c.eventTimes),
            (f = 31 - Yt(f)),
            (c[f] = y);
        }
        function fc(c, f) {
          var y = c.pendingLanes & ~f;
          (c.pendingLanes = f),
            (c.suspendedLanes = 0),
            (c.pingedLanes = 0),
            (c.expiredLanes &= f),
            (c.mutableReadLanes &= f),
            (c.entangledLanes &= f),
            (f = c.entanglements);
          var M = c.eventTimes;
          for (c = c.expirationTimes; 0 < y; ) {
            var T = 31 - Yt(y),
              P = 1 << T;
            (f[T] = 0), (M[T] = -1), (c[T] = -1), (y &= ~P);
          }
        }
        function xs(c, f) {
          var y = (c.entangledLanes |= f);
          for (c = c.entanglements; y; ) {
            var M = 31 - Yt(y),
              T = 1 << M;
            (T & f) | (c[M] & f) && (c[M] |= f), (y &= ~T);
          }
        }
        var vn = 0;
        function Us(c) {
          return (c &= -c), 1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1;
        }
        var Wo = i.unstable_scheduleCallback,
          Na = i.unstable_cancelCallback,
          xo = i.unstable_shouldYield,
          gv = i.unstable_requestPaint,
          vi = i.unstable_now,
          Xo = i.unstable_ImmediatePriority,
          vv = i.unstable_UserBlockingPriority,
          dc = i.unstable_NormalPriority,
          hc = i.unstable_IdlePriority,
          Fl = null,
          As = null;
        function Nl(c) {
          if (As && typeof As.onCommitFiberRoot == 'function')
            try {
              As.onCommitFiberRoot(Fl, c, void 0, (c.current.flags & 128) === 128);
            } catch {}
        }
        function Ul(c, f) {
          return (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f);
        }
        var Qi = typeof Object.is == 'function' ? Object.is : Ul,
          kr = null,
          pc = !1,
          Zf = !1;
        function mc(c) {
          kr === null ? (kr = [c]) : kr.push(c);
        }
        function gc(c) {
          (pc = !0), mc(c);
        }
        function zr() {
          if (!Zf && kr !== null) {
            Zf = !0;
            var c = 0,
              f = vn;
            try {
              var y = kr;
              for (vn = 1; c < y.length; c++) {
                var M = y[c];
                do M = M(!0);
                while (M !== null);
              }
              (kr = null), (pc = !1);
            } catch (T) {
              throw (kr !== null && (kr = kr.slice(c + 1)), Wo(Xo, zr), T);
            } finally {
              (vn = f), (Zf = !1);
            }
          }
          return null;
        }
        var tp = u.ReactCurrentBatchConfig;
        function rs(c, f) {
          if (Qi(c, f)) return !0;
          if (typeof c != 'object' || c === null || typeof f != 'object' || f === null) return !1;
          var y = Object.keys(c),
            M = Object.keys(f);
          if (y.length !== M.length) return !1;
          for (M = 0; M < y.length; M++) {
            var T = y[M];
            if (!Ve.call(f, T) || !Qi(c[T], f[T])) return !1;
          }
          return !0;
        }
        function Qf(c) {
          switch (c.tag) {
            case 5:
              return le(c.type);
            case 16:
              return le('Lazy');
            case 13:
              return le('Suspense');
            case 19:
              return le('SuspenseList');
            case 0:
            case 2:
            case 15:
              return (c = Fe(c.type, !1)), c;
            case 11:
              return (c = Fe(c.type.render, !1)), c;
            case 1:
              return (c = Fe(c.type, !0)), c;
            default:
              return '';
          }
        }
        function cr(c, f) {
          if (c && c.defaultProps) {
            (f = o({}, f)), (c = c.defaultProps);
            for (var y in c) f[y] === void 0 && (f[y] = c[y]);
            return f;
          }
          return f;
        }
        var Ol = ut(null),
          Jo = null,
          Os = null,
          vc = null;
        function qi() {
          vc = Os = Jo = null;
        }
        function Yo(c, f, y) {
          ht
            ? (mt(Ol, f._currentValue), (f._currentValue = y))
            : (mt(Ol, f._currentValue2), (f._currentValue2 = y));
        }
        function kl(c) {
          var f = Ol.current;
          Xe(Ol), ht ? (c._currentValue = f) : (c._currentValue2 = f);
        }
        function Ko(c, f, y) {
          for (; c !== null; ) {
            var M = c.alternate;
            if (
              ((c.childLanes & f) !== f
                ? ((c.childLanes |= f), M !== null && (M.childLanes |= f))
                : M !== null && (M.childLanes & f) !== f && (M.childLanes |= f),
              c === y)
            )
              break;
            c = c.return;
          }
        }
        function Ua(c, f) {
          (Jo = c),
            (vc = Os = null),
            (c = c.dependencies),
            c !== null &&
              c.firstContext !== null &&
              (c.lanes & f && (Ci = !0), (c.firstContext = null));
        }
        function fr(c) {
          var f = ht ? c._currentValue : c._currentValue2;
          if (vc !== c)
            if (((c = { context: c, memoizedValue: f, next: null }), Os === null)) {
              if (Jo === null) throw Error(a(308));
              (Os = c), (Jo.dependencies = { lanes: 0, firstContext: c });
            } else Os = Os.next = c;
          return f;
        }
        var Hr = null,
          Gr = !1;
        function Oa(c) {
          c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function qf(c, f) {
          (c = c.updateQueue),
            f.updateQueue === c &&
              (f.updateQueue = {
                baseState: c.baseState,
                firstBaseUpdate: c.firstBaseUpdate,
                lastBaseUpdate: c.lastBaseUpdate,
                shared: c.shared,
                effects: c.effects,
              });
        }
        function ks(c, f) {
          return { eventTime: c, lane: f, tag: 0, payload: null, callback: null, next: null };
        }
        function Ao(c, f) {
          var y = c.updateQueue;
          y !== null &&
            ((y = y.shared),
            ui !== null && c.mode & 1 && !(fn & 2)
              ? ((c = y.interleaved),
                c === null
                  ? ((f.next = f), Hr === null ? (Hr = [y]) : Hr.push(y))
                  : ((f.next = c.next), (c.next = f)),
                (y.interleaved = f))
              : ((c = y.pending),
                c === null ? (f.next = f) : ((f.next = c.next), (c.next = f)),
                (y.pending = f)));
        }
        function yc(c, f, y) {
          if (((f = f.updateQueue), f !== null && ((f = f.shared), (y & 4194240) !== 0))) {
            var M = f.lanes;
            (M &= c.pendingLanes), (y |= M), (f.lanes = y), xs(c, y);
          }
        }
        function _c(c, f) {
          var y = c.updateQueue,
            M = c.alternate;
          if (M !== null && ((M = M.updateQueue), y === M)) {
            var T = null,
              P = null;
            if (((y = y.firstBaseUpdate), y !== null)) {
              do {
                var Z = {
                  eventTime: y.eventTime,
                  lane: y.lane,
                  tag: y.tag,
                  payload: y.payload,
                  callback: y.callback,
                  next: null,
                };
                P === null ? (T = P = Z) : (P = P.next = Z), (y = y.next);
              } while (y !== null);
              P === null ? (T = P = f) : (P = P.next = f);
            } else T = P = f;
            (y = {
              baseState: M.baseState,
              firstBaseUpdate: T,
              lastBaseUpdate: P,
              shared: M.shared,
              effects: M.effects,
            }),
              (c.updateQueue = y);
            return;
          }
          (c = y.lastBaseUpdate),
            c === null ? (y.firstBaseUpdate = f) : (c.next = f),
            (y.lastBaseUpdate = f);
        }
        function xc(c, f, y, M) {
          var T = c.updateQueue;
          Gr = !1;
          var P = T.firstBaseUpdate,
            Z = T.lastBaseUpdate,
            pe = T.shared.pending;
          if (pe !== null) {
            T.shared.pending = null;
            var Ne = pe,
              st = Ne.next;
            (Ne.next = null), Z === null ? (P = st) : (Z.next = st), (Z = Ne);
            var bt = c.alternate;
            bt !== null &&
              ((bt = bt.updateQueue),
              (pe = bt.lastBaseUpdate),
              pe !== Z &&
                (pe === null ? (bt.firstBaseUpdate = st) : (pe.next = st),
                (bt.lastBaseUpdate = Ne)));
          }
          if (P !== null) {
            var rn = T.baseState;
            (Z = 0), (bt = st = Ne = null), (pe = P);
            do {
              var Xt = pe.lane,
                mn = pe.eventTime;
              if ((M & Xt) === Xt) {
                bt !== null &&
                  (bt = bt.next =
                    {
                      eventTime: mn,
                      lane: 0,
                      tag: pe.tag,
                      payload: pe.payload,
                      callback: pe.callback,
                      next: null,
                    });
                e: {
                  var Et = c,
                    Ni = pe;
                  switch (((Xt = f), (mn = y), Ni.tag)) {
                    case 1:
                      if (((Et = Ni.payload), typeof Et == 'function')) {
                        rn = Et.call(mn, rn, Xt);
                        break e;
                      }
                      rn = Et;
                      break e;
                    case 3:
                      Et.flags = (Et.flags & -65537) | 128;
                    case 0:
                      if (
                        ((Et = Ni.payload),
                        (Xt = typeof Et == 'function' ? Et.call(mn, rn, Xt) : Et),
                        Xt == null)
                      )
                        break e;
                      rn = o({}, rn, Xt);
                      break e;
                    case 2:
                      Gr = !0;
                  }
                }
                pe.callback !== null &&
                  pe.lane !== 0 &&
                  ((c.flags |= 64),
                  (Xt = T.effects),
                  Xt === null ? (T.effects = [pe]) : Xt.push(pe));
              } else
                (mn = {
                  eventTime: mn,
                  lane: Xt,
                  tag: pe.tag,
                  payload: pe.payload,
                  callback: pe.callback,
                  next: null,
                }),
                  bt === null ? ((st = bt = mn), (Ne = rn)) : (bt = bt.next = mn),
                  (Z |= Xt);
              if (((pe = pe.next), pe === null)) {
                if (((pe = T.shared.pending), pe === null)) break;
                (Xt = pe),
                  (pe = Xt.next),
                  (Xt.next = null),
                  (T.lastBaseUpdate = Xt),
                  (T.shared.pending = null);
              }
            } while (!0);
            if (
              (bt === null && (Ne = rn),
              (T.baseState = Ne),
              (T.firstBaseUpdate = st),
              (T.lastBaseUpdate = bt),
              (f = T.shared.interleaved),
              f !== null)
            ) {
              T = f;
              do (Z |= T.lane), (T = T.next);
              while (T !== f);
            } else P === null && (T.shared.lanes = 0);
            (ws |= Z), (c.lanes = Z), (c.memoizedState = rn);
          }
        }
        function np(c, f, y) {
          if (((c = f.effects), (f.effects = null), c !== null))
            for (f = 0; f < c.length; f++) {
              var M = c[f],
                T = M.callback;
              if (T !== null) {
                if (((M.callback = null), (M = y), typeof T != 'function')) throw Error(a(191, T));
                T.call(M);
              }
            }
        }
        var ip = new n.Component().refs;
        function $f(c, f, y, M) {
          (f = c.memoizedState),
            (y = y(M, f)),
            (y = y == null ? f : o({}, f, y)),
            (c.memoizedState = y),
            c.lanes === 0 && (c.updateQueue.baseState = y);
        }
        var Ac = {
          isMounted: function (c) {
            return (c = c._reactInternals) ? L(c) === c : !1;
          },
          enqueueSetState: function (c, f, y) {
            c = c._reactInternals;
            var M = Tn(),
              T = fs(c),
              P = ks(M, T);
            (P.payload = f),
              y != null && (P.callback = y),
              Ao(c, P),
              (f = Vi(c, T, M)),
              f !== null && yc(f, c, T);
          },
          enqueueReplaceState: function (c, f, y) {
            c = c._reactInternals;
            var M = Tn(),
              T = fs(c),
              P = ks(M, T);
            (P.tag = 1),
              (P.payload = f),
              y != null && (P.callback = y),
              Ao(c, P),
              (f = Vi(c, T, M)),
              f !== null && yc(f, c, T);
          },
          enqueueForceUpdate: function (c, f) {
            c = c._reactInternals;
            var y = Tn(),
              M = fs(c),
              T = ks(y, M);
            (T.tag = 2),
              f != null && (T.callback = f),
              Ao(c, T),
              (f = Vi(c, M, y)),
              f !== null && yc(f, c, M);
          },
        };
        function ed(c, f, y, M, T, P, Z) {
          return (
            (c = c.stateNode),
            typeof c.shouldComponentUpdate == 'function'
              ? c.shouldComponentUpdate(M, P, Z)
              : f.prototype && f.prototype.isPureReactComponent
              ? !rs(y, M) || !rs(T, P)
              : !0
          );
        }
        function rp(c, f, y) {
          var M = !1,
            T = gt,
            P = f.contextType;
          return (
            typeof P == 'object' && P !== null
              ? (P = fr(P))
              : ((T = cn(f) ? Ut : qt.current),
                (M = f.contextTypes),
                (P = (M = M != null) ? Mt(c, T) : gt)),
            (f = new f(y, P)),
            (c.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null),
            (f.updater = Ac),
            (c.stateNode = f),
            (f._reactInternals = c),
            M &&
              ((c = c.stateNode),
              (c.__reactInternalMemoizedUnmaskedChildContext = T),
              (c.__reactInternalMemoizedMaskedChildContext = P)),
            f
          );
        }
        function sp(c, f, y, M) {
          (c = f.state),
            typeof f.componentWillReceiveProps == 'function' && f.componentWillReceiveProps(y, M),
            typeof f.UNSAFE_componentWillReceiveProps == 'function' &&
              f.UNSAFE_componentWillReceiveProps(y, M),
            f.state !== c && Ac.enqueueReplaceState(f, f.state, null);
        }
        function td(c, f, y, M) {
          var T = c.stateNode;
          (T.props = y), (T.state = c.memoizedState), (T.refs = ip), Oa(c);
          var P = f.contextType;
          typeof P == 'object' && P !== null
            ? (T.context = fr(P))
            : ((P = cn(f) ? Ut : qt.current), (T.context = Mt(c, P))),
            (T.state = c.memoizedState),
            (P = f.getDerivedStateFromProps),
            typeof P == 'function' && ($f(c, f, P, y), (T.state = c.memoizedState)),
            typeof f.getDerivedStateFromProps == 'function' ||
              typeof T.getSnapshotBeforeUpdate == 'function' ||
              (typeof T.UNSAFE_componentWillMount != 'function' &&
                typeof T.componentWillMount != 'function') ||
              ((f = T.state),
              typeof T.componentWillMount == 'function' && T.componentWillMount(),
              typeof T.UNSAFE_componentWillMount == 'function' && T.UNSAFE_componentWillMount(),
              f !== T.state && Ac.enqueueReplaceState(T, T.state, null),
              xc(c, y, T, M),
              (T.state = c.memoizedState)),
            typeof T.componentDidMount == 'function' && (c.flags |= 4194308);
        }
        var ka = [],
          So = 0,
          Sc = null,
          Mc = 0,
          Vr = [],
          wr = 0,
          jo = null,
          zs = 1,
          Hs = '';
        function Zo(c, f) {
          (ka[So++] = Mc), (ka[So++] = Sc), (Sc = c), (Mc = f);
        }
        function op(c, f, y) {
          (Vr[wr++] = zs), (Vr[wr++] = Hs), (Vr[wr++] = jo), (jo = c);
          var M = zs;
          c = Hs;
          var T = 32 - Yt(M) - 1;
          (M &= ~(1 << T)), (y += 1);
          var P = 32 - Yt(f) + T;
          if (30 < P) {
            var Z = T - (T % 5);
            (P = (M & ((1 << Z) - 1)).toString(32)),
              (M >>= Z),
              (T -= Z),
              (zs = (1 << (32 - Yt(f) + T)) | (y << T) | M),
              (Hs = P + c);
          } else (zs = (1 << P) | (y << T) | M), (Hs = c);
        }
        function nd(c) {
          c.return !== null && (Zo(c, 1), op(c, 1, 0));
        }
        function id(c) {
          for (; c === Sc; ) (Sc = ka[--So]), (ka[So] = null), (Mc = ka[--So]), (ka[So] = null);
          for (; c === jo; )
            (jo = Vr[--wr]),
              (Vr[wr] = null),
              (Hs = Vr[--wr]),
              (Vr[wr] = null),
              (zs = Vr[--wr]),
              (Vr[wr] = null);
        }
        var $i = null,
          Bi = null,
          jn = !1,
          za = !1,
          Wr = null;
        function rd(c, f) {
          var y = Pr(5, null, null, 0);
          (y.elementType = 'DELETED'),
            (y.stateNode = f),
            (y.return = c),
            (f = c.deletions),
            f === null ? ((c.deletions = [y]), (c.flags |= 16)) : f.push(y);
        }
        function sd(c, f) {
          switch (c.tag) {
            case 5:
              return (
                (f = ni(f, c.type, c.pendingProps)),
                f !== null ? ((c.stateNode = f), ($i = c), (Bi = nn(f)), !0) : !1
              );
            case 6:
              return (
                (f = yo(f, c.pendingProps)),
                f !== null ? ((c.stateNode = f), ($i = c), (Bi = null), !0) : !1
              );
            case 13:
              if (((f = _s(f)), f !== null)) {
                var y = jo !== null ? { id: zs, overflow: Hs } : null;
                return (
                  (c.memoizedState = { dehydrated: f, treeContext: y, retryLane: 1073741824 }),
                  (y = Pr(18, null, null, 0)),
                  (y.stateNode = f),
                  (y.return = c),
                  (c.child = y),
                  ($i = c),
                  (Bi = null),
                  !0
                );
              }
              return !1;
            default:
              return !1;
          }
        }
        function Ec(c) {
          return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
        }
        function Mo(c) {
          if (jn) {
            var f = Bi;
            if (f) {
              var y = f;
              if (!sd(c, f)) {
                if (Ec(c)) throw Error(a(418));
                f = Ii(y);
                var M = $i;
                f && sd(c, f) ? rd(M, y) : ((c.flags = (c.flags & -4097) | 2), (jn = !1), ($i = c));
              }
            } else {
              if (Ec(c)) throw Error(a(418));
              (c.flags = (c.flags & -4097) | 2), (jn = !1), ($i = c);
            }
          }
        }
        function ap(c) {
          for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; )
            c = c.return;
          $i = c;
        }
        function zl(c) {
          if (!ke || c !== $i) return !1;
          if (!jn) return ap(c), (jn = !0), !1;
          if (c.tag !== 3 && (c.tag !== 5 || (U(c.type) && !De(c.type, c.memoizedProps)))) {
            var f = Bi;
            if (f) {
              if (Ec(c)) {
                for (c = Bi; c; ) c = Ii(c);
                throw Error(a(418));
              }
              for (; f; ) rd(c, f), (f = Ii(f));
            }
          }
          if ((ap(c), c.tag === 13)) {
            if (!ke) throw Error(a(316));
            if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
              throw Error(a(317));
            Bi = Ee(c);
          } else Bi = $i ? Ii(c.stateNode) : null;
          return !0;
        }
        function Ha() {
          ke && ((Bi = $i = null), (za = jn = !1));
        }
        function wc(c) {
          Wr === null ? (Wr = [c]) : Wr.push(c);
        }
        function Ga(c, f, y) {
          if (((c = y.ref), c !== null && typeof c != 'function' && typeof c != 'object')) {
            if (y._owner) {
              if (((y = y._owner), y)) {
                if (y.tag !== 1) throw Error(a(309));
                var M = y.stateNode;
              }
              if (!M) throw Error(a(147, c));
              var T = M,
                P = '' + c;
              return f !== null &&
                f.ref !== null &&
                typeof f.ref == 'function' &&
                f.ref._stringRef === P
                ? f.ref
                : ((f = function (Z) {
                    var pe = T.refs;
                    pe === ip && (pe = T.refs = {}), Z === null ? delete pe[P] : (pe[P] = Z);
                  }),
                  (f._stringRef = P),
                  f);
            }
            if (typeof c != 'string') throw Error(a(284));
            if (!y._owner) throw Error(a(290, c));
          }
          return c;
        }
        function Eo(c, f) {
          throw (
            ((c = Object.prototype.toString.call(f)),
            Error(
              a(
                31,
                c === '[object Object]'
                  ? 'object with keys {' + Object.keys(f).join(', ') + '}'
                  : c,
              ),
            ))
          );
        }
        function Va(c) {
          var f = c._init;
          return f(c._payload);
        }
        function lp(c) {
          function f(Me, me) {
            if (c) {
              var be = Me.deletions;
              be === null ? ((Me.deletions = [me]), (Me.flags |= 16)) : be.push(me);
            }
          }
          function y(Me, me) {
            if (!c) return null;
            for (; me !== null; ) f(Me, me), (me = me.sibling);
            return null;
          }
          function M(Me, me) {
            for (Me = new Map(); me !== null; )
              me.key !== null ? Me.set(me.key, me) : Me.set(me.index, me), (me = me.sibling);
            return Me;
          }
          function T(Me, me) {
            return (Me = to(Me, me)), (Me.index = 0), (Me.sibling = null), Me;
          }
          function P(Me, me, be) {
            return (
              (Me.index = be),
              c
                ? ((be = Me.alternate),
                  be !== null
                    ? ((be = be.index), be < me ? ((Me.flags |= 2), me) : be)
                    : ((Me.flags |= 2), me))
                : ((Me.flags |= 1048576), me)
            );
          }
          function Z(Me) {
            return c && Me.alternate === null && (Me.flags |= 2), Me;
          }
          function pe(Me, me, be, _t) {
            return me === null || me.tag !== 6
              ? ((me = qc(be, Me.mode, _t)), (me.return = Me), me)
              : ((me = T(me, be)), (me.return = Me), me);
          }
          function Ne(Me, me, be, _t) {
            var Ot = be.type;
            return Ot === m
              ? bt(Me, me, be.props.children, _t, be.key)
              : me !== null &&
                (me.elementType === Ot ||
                  (typeof Ot == 'object' && Ot !== null && Ot.$$typeof === I && Va(Ot) === me.type))
              ? ((_t = T(me, be.props)), (_t.ref = Ga(Me, me, be)), (_t.return = Me), _t)
              : ((_t = Qc(be.type, be.key, be.props, null, Me.mode, _t)),
                (_t.ref = Ga(Me, me, be)),
                (_t.return = Me),
                _t);
          }
          function st(Me, me, be, _t) {
            return me === null ||
              me.tag !== 4 ||
              me.stateNode.containerInfo !== be.containerInfo ||
              me.stateNode.implementation !== be.implementation
              ? ((me = $c(be, Me.mode, _t)), (me.return = Me), me)
              : ((me = T(me, be.children || [])), (me.return = Me), me);
          }
          function bt(Me, me, be, _t, Ot) {
            return me === null || me.tag !== 7
              ? ((me = ya(be, Me.mode, _t, Ot)), (me.return = Me), me)
              : ((me = T(me, be)), (me.return = Me), me);
          }
          function rn(Me, me, be) {
            if ((typeof me == 'string' && me !== '') || typeof me == 'number')
              return (me = qc('' + me, Me.mode, be)), (me.return = Me), me;
            if (typeof me == 'object' && me !== null) {
              switch (me.$$typeof) {
                case d:
                  return (
                    (be = Qc(me.type, me.key, me.props, null, Me.mode, be)),
                    (be.ref = Ga(Me, null, me)),
                    (be.return = Me),
                    be
                  );
                case h:
                  return (me = $c(me, Me.mode, be)), (me.return = Me), me;
                case I:
                  var _t = me._init;
                  return rn(Me, _t(me._payload), be);
              }
              if (xe(me) || N(me)) return (me = ya(me, Me.mode, be, null)), (me.return = Me), me;
              Eo(Me, me);
            }
            return null;
          }
          function Xt(Me, me, be, _t) {
            var Ot = me !== null ? me.key : null;
            if ((typeof be == 'string' && be !== '') || typeof be == 'number')
              return Ot !== null ? null : pe(Me, me, '' + be, _t);
            if (typeof be == 'object' && be !== null) {
              switch (be.$$typeof) {
                case d:
                  return be.key === Ot ? Ne(Me, me, be, _t) : null;
                case h:
                  return be.key === Ot ? st(Me, me, be, _t) : null;
                case I:
                  return (Ot = be._init), Xt(Me, me, Ot(be._payload), _t);
              }
              if (xe(be) || N(be)) return Ot !== null ? null : bt(Me, me, be, _t, null);
              Eo(Me, be);
            }
            return null;
          }
          function mn(Me, me, be, _t, Ot) {
            if ((typeof _t == 'string' && _t !== '') || typeof _t == 'number')
              return (Me = Me.get(be) || null), pe(me, Me, '' + _t, Ot);
            if (typeof _t == 'object' && _t !== null) {
              switch (_t.$$typeof) {
                case d:
                  return (Me = Me.get(_t.key === null ? be : _t.key) || null), Ne(me, Me, _t, Ot);
                case h:
                  return (Me = Me.get(_t.key === null ? be : _t.key) || null), st(me, Me, _t, Ot);
                case I:
                  var ln = _t._init;
                  return mn(Me, me, be, ln(_t._payload), Ot);
              }
              if (xe(_t) || N(_t)) return (Me = Me.get(be) || null), bt(me, Me, _t, Ot, null);
              Eo(me, _t);
            }
            return null;
          }
          function Et(Me, me, be, _t) {
            for (
              var Ot = null, ln = null, sn = me, En = (me = 0), hi = null;
              sn !== null && En < be.length;
              En++
            ) {
              sn.index > En ? ((hi = sn), (sn = null)) : (hi = sn.sibling);
              var Mn = Xt(Me, sn, be[En], _t);
              if (Mn === null) {
                sn === null && (sn = hi);
                break;
              }
              c && sn && Mn.alternate === null && f(Me, sn),
                (me = P(Mn, me, En)),
                ln === null ? (Ot = Mn) : (ln.sibling = Mn),
                (ln = Mn),
                (sn = hi);
            }
            if (En === be.length) return y(Me, sn), jn && Zo(Me, En), Ot;
            if (sn === null) {
              for (; En < be.length; En++)
                (sn = rn(Me, be[En], _t)),
                  sn !== null &&
                    ((me = P(sn, me, En)), ln === null ? (Ot = sn) : (ln.sibling = sn), (ln = sn));
              return jn && Zo(Me, En), Ot;
            }
            for (sn = M(Me, sn); En < be.length; En++)
              (hi = mn(sn, Me, En, be[En], _t)),
                hi !== null &&
                  (c && hi.alternate !== null && sn.delete(hi.key === null ? En : hi.key),
                  (me = P(hi, me, En)),
                  ln === null ? (Ot = hi) : (ln.sibling = hi),
                  (ln = hi));
            return (
              c &&
                sn.forEach(function (no) {
                  return f(Me, no);
                }),
              jn && Zo(Me, En),
              Ot
            );
          }
          function Ni(Me, me, be, _t) {
            var Ot = N(be);
            if (typeof Ot != 'function') throw Error(a(150));
            if (((be = Ot.call(be)), be == null)) throw Error(a(151));
            for (
              var ln = (Ot = null), sn = me, En = (me = 0), hi = null, Mn = be.next();
              sn !== null && !Mn.done;
              En++, Mn = be.next()
            ) {
              sn.index > En ? ((hi = sn), (sn = null)) : (hi = sn.sibling);
              var no = Xt(Me, sn, Mn.value, _t);
              if (no === null) {
                sn === null && (sn = hi);
                break;
              }
              c && sn && no.alternate === null && f(Me, sn),
                (me = P(no, me, En)),
                ln === null ? (Ot = no) : (ln.sibling = no),
                (ln = no),
                (sn = hi);
            }
            if (Mn.done) return y(Me, sn), jn && Zo(Me, En), Ot;
            if (sn === null) {
              for (; !Mn.done; En++, Mn = be.next())
                (Mn = rn(Me, Mn.value, _t)),
                  Mn !== null &&
                    ((me = P(Mn, me, En)), ln === null ? (Ot = Mn) : (ln.sibling = Mn), (ln = Mn));
              return jn && Zo(Me, En), Ot;
            }
            for (sn = M(Me, sn); !Mn.done; En++, Mn = be.next())
              (Mn = mn(sn, Me, En, Mn.value, _t)),
                Mn !== null &&
                  (c && Mn.alternate !== null && sn.delete(Mn.key === null ? En : Mn.key),
                  (me = P(Mn, me, En)),
                  ln === null ? (Ot = Mn) : (ln.sibling = Mn),
                  (ln = Mn));
            return (
              c &&
                sn.forEach(function (Nd) {
                  return f(Me, Nd);
                }),
              jn && Zo(Me, En),
              Ot
            );
          }
          function Dr(Me, me, be, _t) {
            if (
              (typeof be == 'object' &&
                be !== null &&
                be.type === m &&
                be.key === null &&
                (be = be.props.children),
              typeof be == 'object' && be !== null)
            ) {
              switch (be.$$typeof) {
                case d:
                  e: {
                    for (var Ot = be.key, ln = me; ln !== null; ) {
                      if (ln.key === Ot) {
                        if (((Ot = be.type), Ot === m)) {
                          if (ln.tag === 7) {
                            y(Me, ln.sibling),
                              (me = T(ln, be.props.children)),
                              (me.return = Me),
                              (Me = me);
                            break e;
                          }
                        } else if (
                          ln.elementType === Ot ||
                          (typeof Ot == 'object' &&
                            Ot !== null &&
                            Ot.$$typeof === I &&
                            Va(Ot) === ln.type)
                        ) {
                          y(Me, ln.sibling),
                            (me = T(ln, be.props)),
                            (me.ref = Ga(Me, ln, be)),
                            (me.return = Me),
                            (Me = me);
                          break e;
                        }
                        y(Me, ln);
                        break;
                      } else f(Me, ln);
                      ln = ln.sibling;
                    }
                    be.type === m
                      ? ((me = ya(be.props.children, Me.mode, _t, be.key)),
                        (me.return = Me),
                        (Me = me))
                      : ((_t = Qc(be.type, be.key, be.props, null, Me.mode, _t)),
                        (_t.ref = Ga(Me, me, be)),
                        (_t.return = Me),
                        (Me = _t));
                  }
                  return Z(Me);
                case h:
                  e: {
                    for (ln = be.key; me !== null; ) {
                      if (me.key === ln)
                        if (
                          me.tag === 4 &&
                          me.stateNode.containerInfo === be.containerInfo &&
                          me.stateNode.implementation === be.implementation
                        ) {
                          y(Me, me.sibling),
                            (me = T(me, be.children || [])),
                            (me.return = Me),
                            (Me = me);
                          break e;
                        } else {
                          y(Me, me);
                          break;
                        }
                      else f(Me, me);
                      me = me.sibling;
                    }
                    (me = $c(be, Me.mode, _t)), (me.return = Me), (Me = me);
                  }
                  return Z(Me);
                case I:
                  return (ln = be._init), Dr(Me, me, ln(be._payload), _t);
              }
              if (xe(be)) return Et(Me, me, be, _t);
              if (N(be)) return Ni(Me, me, be, _t);
              Eo(Me, be);
            }
            return (typeof be == 'string' && be !== '') || typeof be == 'number'
              ? ((be = '' + be),
                me !== null && me.tag === 6
                  ? (y(Me, me.sibling), (me = T(me, be)), (me.return = Me), (Me = me))
                  : (y(Me, me), (me = qc(be, Me.mode, _t)), (me.return = Me), (Me = me)),
                Z(Me))
              : y(Me, me);
          }
          return Dr;
        }
        var Gs = lp(!0),
          up = lp(!1),
          Wa = {},
          dr = ut(Wa),
          Qo = ut(Wa),
          qo = ut(Wa);
        function ss(c) {
          if (c === Wa) throw Error(a(174));
          return c;
        }
        function Cc(c, f) {
          mt(qo, f), mt(Qo, c), mt(dr, Wa), (c = Ce(f)), Xe(dr), mt(dr, c);
        }
        function Xa() {
          Xe(dr), Xe(Qo), Xe(qo);
        }
        function cp(c) {
          var f = ss(qo.current),
            y = ss(dr.current);
          (f = X(y, c.type, f)), y !== f && (mt(Qo, c), mt(dr, f));
        }
        function od(c) {
          Qo.current === c && (Xe(dr), Xe(Qo));
        }
        var $n = ut(0);
        function Tc(c) {
          for (var f = c; f !== null; ) {
            if (f.tag === 13) {
              var y = f.memoizedState;
              if (y !== null && ((y = y.dehydrated), y === null || Zi(y) || Mr(y))) return f;
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
              if (f.flags & 128) return f;
            } else if (f.child !== null) {
              (f.child.return = f), (f = f.child);
              continue;
            }
            if (f === c) break;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === c) return null;
              f = f.return;
            }
            (f.sibling.return = f.return), (f = f.sibling);
          }
          return null;
        }
        var Cr = [];
        function $o() {
          for (var c = 0; c < Cr.length; c++) {
            var f = Cr[c];
            ht
              ? (f._workInProgressVersionPrimary = null)
              : (f._workInProgressVersionSecondary = null);
          }
          Cr.length = 0;
        }
        var Hl = u.ReactCurrentDispatcher,
          Tr = u.ReactCurrentBatchConfig,
          ea = 0,
          ei = null,
          Mi = null,
          Ei = null,
          Rc = !1,
          Ss = !1,
          ta = 0,
          Gl = 0;
        function wi() {
          throw Error(a(321));
        }
        function bc(c, f) {
          if (f === null) return !1;
          for (var y = 0; y < f.length && y < c.length; y++) if (!Qi(c[y], f[y])) return !1;
          return !0;
        }
        function Ja(c, f, y, M, T, P) {
          if (
            ((ea = P),
            (ei = f),
            (f.memoizedState = null),
            (f.updateQueue = null),
            (f.lanes = 0),
            (Hl.current = c === null || c.memoizedState === null ? dd : hd),
            (c = y(M, T)),
            Ss)
          ) {
            P = 0;
            do {
              if (((Ss = !1), (ta = 0), 25 <= P)) throw Error(a(301));
              (P += 1), (Ei = Mi = null), (f.updateQueue = null), (Hl.current = pd), (c = y(M, T));
            } while (Ss);
          }
          if (
            ((Hl.current = Za),
            (f = Mi !== null && Mi.next !== null),
            (ea = 0),
            (Ei = Mi = ei = null),
            (Rc = !1),
            f)
          )
            throw Error(a(300));
          return c;
        }
        function wo() {
          var c = ta !== 0;
          return (ta = 0), c;
        }
        function os() {
          var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return Ei === null ? (ei.memoizedState = Ei = c) : (Ei = Ei.next = c), Ei;
        }
        function as() {
          if (Mi === null) {
            var c = ei.alternate;
            c = c !== null ? c.memoizedState : null;
          } else c = Mi.next;
          var f = Ei === null ? ei.memoizedState : Ei.next;
          if (f !== null) (Ei = f), (Mi = c);
          else {
            if (c === null) throw Error(a(310));
            (Mi = c),
              (c = {
                memoizedState: Mi.memoizedState,
                baseState: Mi.baseState,
                baseQueue: Mi.baseQueue,
                queue: Mi.queue,
                next: null,
              }),
              Ei === null ? (ei.memoizedState = Ei = c) : (Ei = Ei.next = c);
          }
          return Ei;
        }
        function Ms(c, f) {
          return typeof f == 'function' ? f(c) : f;
        }
        function Vl(c) {
          var f = as(),
            y = f.queue;
          if (y === null) throw Error(a(311));
          y.lastRenderedReducer = c;
          var M = Mi,
            T = M.baseQueue,
            P = y.pending;
          if (P !== null) {
            if (T !== null) {
              var Z = T.next;
              (T.next = P.next), (P.next = Z);
            }
            (M.baseQueue = T = P), (y.pending = null);
          }
          if (T !== null) {
            (P = T.next), (M = M.baseState);
            var pe = (Z = null),
              Ne = null,
              st = P;
            do {
              var bt = st.lane;
              if ((ea & bt) === bt)
                Ne !== null &&
                  (Ne = Ne.next =
                    {
                      lane: 0,
                      action: st.action,
                      hasEagerState: st.hasEagerState,
                      eagerState: st.eagerState,
                      next: null,
                    }),
                  (M = st.hasEagerState ? st.eagerState : c(M, st.action));
              else {
                var rn = {
                  lane: bt,
                  action: st.action,
                  hasEagerState: st.hasEagerState,
                  eagerState: st.eagerState,
                  next: null,
                };
                Ne === null ? ((pe = Ne = rn), (Z = M)) : (Ne = Ne.next = rn),
                  (ei.lanes |= bt),
                  (ws |= bt);
              }
              st = st.next;
            } while (st !== null && st !== P);
            Ne === null ? (Z = M) : (Ne.next = pe),
              Qi(M, f.memoizedState) || (Ci = !0),
              (f.memoizedState = M),
              (f.baseState = Z),
              (f.baseQueue = Ne),
              (y.lastRenderedState = M);
          }
          if (((c = y.interleaved), c !== null)) {
            T = c;
            do (P = T.lane), (ei.lanes |= P), (ws |= P), (T = T.next);
            while (T !== c);
          } else T === null && (y.lanes = 0);
          return [f.memoizedState, y.dispatch];
        }
        function Wl(c) {
          var f = as(),
            y = f.queue;
          if (y === null) throw Error(a(311));
          y.lastRenderedReducer = c;
          var M = y.dispatch,
            T = y.pending,
            P = f.memoizedState;
          if (T !== null) {
            y.pending = null;
            var Z = (T = T.next);
            do (P = c(P, Z.action)), (Z = Z.next);
            while (Z !== T);
            Qi(P, f.memoizedState) || (Ci = !0),
              (f.memoizedState = P),
              f.baseQueue === null && (f.baseState = P),
              (y.lastRenderedState = P);
          }
          return [P, M];
        }
        function ad() {}
        function ld(c, f) {
          var y = ei,
            M = as(),
            T = f(),
            P = !Qi(M.memoizedState, T);
          if (
            (P && ((M.memoizedState = T), (Ci = !0)),
            (M = M.queue),
            Ya(Vs.bind(null, y, M, c), [c]),
            M.getSnapshot !== f || P || (Ei !== null && Ei.memoizedState.tag & 1))
          ) {
            if (((y.flags |= 2048), Jl(9, cd.bind(null, y, M, T, f), void 0, null), ui === null))
              throw Error(a(349));
            ea & 30 || ud(y, f, T);
          }
          return T;
        }
        function ud(c, f, y) {
          (c.flags |= 16384),
            (c = { getSnapshot: f, value: y }),
            (f = ei.updateQueue),
            f === null
              ? ((f = { lastEffect: null, stores: null }), (ei.updateQueue = f), (f.stores = [c]))
              : ((y = f.stores), y === null ? (f.stores = [c]) : y.push(c));
        }
        function cd(c, f, y, M) {
          (f.value = y), (f.getSnapshot = M), Ic(f) && Vi(c, 1, -1);
        }
        function Vs(c, f, y) {
          return y(function () {
            Ic(f) && Vi(c, 1, -1);
          });
        }
        function Ic(c) {
          var f = c.getSnapshot;
          c = c.value;
          try {
            var y = f();
            return !Qi(c, y);
          } catch {
            return !0;
          }
        }
        function Xl(c) {
          var f = os();
          return (
            typeof c == 'function' && (c = c()),
            (f.memoizedState = f.baseState = c),
            (c = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: Ms,
              lastRenderedState: c,
            }),
            (f.queue = c),
            (c = c.dispatch = yv.bind(null, ei, c)),
            [f.memoizedState, c]
          );
        }
        function Jl(c, f, y, M) {
          return (
            (c = { tag: c, create: f, destroy: y, deps: M, next: null }),
            (f = ei.updateQueue),
            f === null
              ? ((f = { lastEffect: null, stores: null }),
                (ei.updateQueue = f),
                (f.lastEffect = c.next = c))
              : ((y = f.lastEffect),
                y === null
                  ? (f.lastEffect = c.next = c)
                  : ((M = y.next), (y.next = c), (c.next = M), (f.lastEffect = c))),
            c
          );
        }
        function fp() {
          return as().memoizedState;
        }
        function Co(c, f, y, M) {
          var T = os();
          (ei.flags |= c), (T.memoizedState = Jl(1 | f, y, void 0, M === void 0 ? null : M));
        }
        function Bc(c, f, y, M) {
          var T = as();
          M = M === void 0 ? null : M;
          var P = void 0;
          if (Mi !== null) {
            var Z = Mi.memoizedState;
            if (((P = Z.destroy), M !== null && bc(M, Z.deps))) {
              T.memoizedState = Jl(f, y, P, M);
              return;
            }
          }
          (ei.flags |= c), (T.memoizedState = Jl(1 | f, y, P, M));
        }
        function Pc(c, f) {
          return Co(8390656, 8, c, f);
        }
        function Ya(c, f) {
          return Bc(2048, 8, c, f);
        }
        function Vn(c, f) {
          return Bc(4, 2, c, f);
        }
        function Dc(c, f) {
          return Bc(4, 4, c, f);
        }
        function Yl(c, f) {
          if (typeof f == 'function')
            return (
              (c = c()),
              f(c),
              function () {
                f(null);
              }
            );
          if (f != null)
            return (
              (c = c()),
              (f.current = c),
              function () {
                f.current = null;
              }
            );
        }
        function Ka(c, f, y) {
          return (y = y != null ? y.concat([c]) : null), Bc(4, 4, Yl.bind(null, f, c), y);
        }
        function Lc() {}
        function Fc(c, f) {
          var y = as();
          f = f === void 0 ? null : f;
          var M = y.memoizedState;
          return M !== null && f !== null && bc(f, M[1]) ? M[0] : ((y.memoizedState = [c, f]), c);
        }
        function ja(c, f) {
          var y = as();
          f = f === void 0 ? null : f;
          var M = y.memoizedState;
          return M !== null && f !== null && bc(f, M[1])
            ? M[0]
            : ((c = c()), (y.memoizedState = [c, f]), c);
        }
        function Nc(c, f) {
          var y = vn;
          (vn = y !== 0 && 4 > y ? y : 4), c(!0);
          var M = Tr.transition;
          Tr.transition = {};
          try {
            c(!1), f();
          } finally {
            (vn = y), (Tr.transition = M);
          }
        }
        function na() {
          return as().memoizedState;
        }
        function dp(c, f, y) {
          var M = fs(c);
          (y = { lane: M, action: y, hasEagerState: !1, eagerState: null, next: null }),
            hp(c)
              ? fd(f, y)
              : (Kl(c, f, y), (y = Tn()), (c = Vi(c, M, y)), c !== null && jl(c, f, M));
        }
        function yv(c, f, y) {
          var M = fs(c),
            T = { lane: M, action: y, hasEagerState: !1, eagerState: null, next: null };
          if (hp(c)) fd(f, T);
          else {
            Kl(c, f, T);
            var P = c.alternate;
            if (
              c.lanes === 0 &&
              (P === null || P.lanes === 0) &&
              ((P = f.lastRenderedReducer), P !== null)
            )
              try {
                var Z = f.lastRenderedState,
                  pe = P(Z, y);
                if (((T.hasEagerState = !0), (T.eagerState = pe), Qi(pe, Z))) return;
              } catch {
              } finally {
              }
            (y = Tn()), (c = Vi(c, M, y)), c !== null && jl(c, f, M);
          }
        }
        function hp(c) {
          var f = c.alternate;
          return c === ei || (f !== null && f === ei);
        }
        function fd(c, f) {
          Ss = Rc = !0;
          var y = c.pending;
          y === null ? (f.next = f) : ((f.next = y.next), (y.next = f)), (c.pending = f);
        }
        function Kl(c, f, y) {
          ui !== null && c.mode & 1 && !(fn & 2)
            ? ((c = f.interleaved),
              c === null
                ? ((y.next = y), Hr === null ? (Hr = [f]) : Hr.push(f))
                : ((y.next = c.next), (c.next = y)),
              (f.interleaved = y))
            : ((c = f.pending),
              c === null ? (y.next = y) : ((y.next = c.next), (c.next = y)),
              (f.pending = y));
        }
        function jl(c, f, y) {
          if (y & 4194240) {
            var M = f.lanes;
            (M &= c.pendingLanes), (y |= M), (f.lanes = y), xs(c, y);
          }
        }
        var Za = {
            readContext: fr,
            useCallback: wi,
            useContext: wi,
            useEffect: wi,
            useImperativeHandle: wi,
            useInsertionEffect: wi,
            useLayoutEffect: wi,
            useMemo: wi,
            useReducer: wi,
            useRef: wi,
            useState: wi,
            useDebugValue: wi,
            useDeferredValue: wi,
            useTransition: wi,
            useMutableSource: wi,
            useSyncExternalStore: wi,
            useId: wi,
            unstable_isNewReconciler: !1,
          },
          dd = {
            readContext: fr,
            useCallback: function (c, f) {
              return (os().memoizedState = [c, f === void 0 ? null : f]), c;
            },
            useContext: fr,
            useEffect: Pc,
            useImperativeHandle: function (c, f, y) {
              return (y = y != null ? y.concat([c]) : null), Co(4194308, 4, Yl.bind(null, f, c), y);
            },
            useLayoutEffect: function (c, f) {
              return Co(4194308, 4, c, f);
            },
            useInsertionEffect: function (c, f) {
              return Co(4, 2, c, f);
            },
            useMemo: function (c, f) {
              var y = os();
              return (f = f === void 0 ? null : f), (c = c()), (y.memoizedState = [c, f]), c;
            },
            useReducer: function (c, f, y) {
              var M = os();
              return (
                (f = y !== void 0 ? y(f) : f),
                (M.memoizedState = M.baseState = f),
                (c = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: c,
                  lastRenderedState: f,
                }),
                (M.queue = c),
                (c = c.dispatch = dp.bind(null, ei, c)),
                [M.memoizedState, c]
              );
            },
            useRef: function (c) {
              var f = os();
              return (c = { current: c }), (f.memoizedState = c);
            },
            useState: Xl,
            useDebugValue: Lc,
            useDeferredValue: function (c) {
              var f = Xl(c),
                y = f[0],
                M = f[1];
              return (
                Pc(
                  function () {
                    var T = Tr.transition;
                    Tr.transition = {};
                    try {
                      M(c);
                    } finally {
                      Tr.transition = T;
                    }
                  },
                  [c],
                ),
                y
              );
            },
            useTransition: function () {
              var c = Xl(!1),
                f = c[0];
              return (c = Nc.bind(null, c[1])), (os().memoizedState = c), [f, c];
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (c, f, y) {
              var M = ei,
                T = os();
              if (jn) {
                if (y === void 0) throw Error(a(407));
                y = y();
              } else {
                if (((y = f()), ui === null)) throw Error(a(349));
                ea & 30 || ud(M, f, y);
              }
              T.memoizedState = y;
              var P = { value: y, getSnapshot: f };
              return (
                (T.queue = P),
                Pc(Vs.bind(null, M, P, c), [c]),
                (M.flags |= 2048),
                Jl(9, cd.bind(null, M, P, y, f), void 0, null),
                y
              );
            },
            useId: function () {
              var c = os(),
                f = ui.identifierPrefix;
              if (jn) {
                var y = Hs,
                  M = zs;
                (y = (M & ~(1 << (32 - Yt(M) - 1))).toString(32) + y),
                  (f = ':' + f + 'R' + y),
                  (y = ta++),
                  0 < y && (f += 'H' + y.toString(32)),
                  (f += ':');
              } else (y = Gl++), (f = ':' + f + 'r' + y.toString(32) + ':');
              return (c.memoizedState = f);
            },
            unstable_isNewReconciler: !1,
          },
          hd = {
            readContext: fr,
            useCallback: Fc,
            useContext: fr,
            useEffect: Ya,
            useImperativeHandle: Ka,
            useInsertionEffect: Vn,
            useLayoutEffect: Dc,
            useMemo: ja,
            useReducer: Vl,
            useRef: fp,
            useState: function () {
              return Vl(Ms);
            },
            useDebugValue: Lc,
            useDeferredValue: function (c) {
              var f = Vl(Ms),
                y = f[0],
                M = f[1];
              return (
                Ya(
                  function () {
                    var T = Tr.transition;
                    Tr.transition = {};
                    try {
                      M(c);
                    } finally {
                      Tr.transition = T;
                    }
                  },
                  [c],
                ),
                y
              );
            },
            useTransition: function () {
              var c = Vl(Ms)[0],
                f = as().memoizedState;
              return [c, f];
            },
            useMutableSource: ad,
            useSyncExternalStore: ld,
            useId: na,
            unstable_isNewReconciler: !1,
          },
          pd = {
            readContext: fr,
            useCallback: Fc,
            useContext: fr,
            useEffect: Ya,
            useImperativeHandle: Ka,
            useInsertionEffect: Vn,
            useLayoutEffect: Dc,
            useMemo: ja,
            useReducer: Wl,
            useRef: fp,
            useState: function () {
              return Wl(Ms);
            },
            useDebugValue: Lc,
            useDeferredValue: function (c) {
              var f = Wl(Ms),
                y = f[0],
                M = f[1];
              return (
                Ya(
                  function () {
                    var T = Tr.transition;
                    Tr.transition = {};
                    try {
                      M(c);
                    } finally {
                      Tr.transition = T;
                    }
                  },
                  [c],
                ),
                y
              );
            },
            useTransition: function () {
              var c = Wl(Ms)[0],
                f = as().memoizedState;
              return [c, f];
            },
            useMutableSource: ad,
            useSyncExternalStore: ld,
            useId: na,
            unstable_isNewReconciler: !1,
          };
        function md(c, f) {
          try {
            var y = '',
              M = f;
            do (y += Qf(M)), (M = M.return);
            while (M);
            var T = y;
          } catch (P) {
            T =
              `
Error generating stack: ` +
              P.message +
              `
` +
              P.stack;
          }
          return { value: c, source: f, stack: T };
        }
        function Uc(c, f) {
          try {
            console.error(f.value);
          } catch (y) {
            setTimeout(function () {
              throw y;
            });
          }
        }
        var _v = typeof WeakMap == 'function' ? WeakMap : Map;
        function pp(c, f, y) {
          (y = ks(-1, y)), (y.tag = 3), (y.payload = { element: null });
          var M = f.value;
          return (
            (y.callback = function () {
              nl || ((nl = !0), (Yn = M)), Uc(c, f);
            }),
            y
          );
        }
        function Oc(c, f, y) {
          (y = ks(-1, y)), (y.tag = 3);
          var M = c.type.getDerivedStateFromError;
          if (typeof M == 'function') {
            var T = f.value;
            (y.payload = function () {
              return M(T);
            }),
              (y.callback = function () {
                Uc(c, f);
              });
          }
          var P = c.stateNode;
          return (
            P !== null &&
              typeof P.componentDidCatch == 'function' &&
              (y.callback = function () {
                Uc(c, f),
                  typeof M != 'function' && (cs === null ? (cs = new Set([this])) : cs.add(this));
                var Z = f.stack;
                this.componentDidCatch(f.value, { componentStack: Z !== null ? Z : '' });
              }),
            y
          );
        }
        function Ws(c, f, y) {
          var M = c.pingCache;
          if (M === null) {
            M = c.pingCache = new _v();
            var T = new Set();
            M.set(f, T);
          } else (T = M.get(f)), T === void 0 && ((T = new Set()), M.set(f, T));
          T.has(y) || (T.add(y), (c = Dd.bind(null, c, f, y)), f.then(c, c));
        }
        function gd(c) {
          do {
            var f;
            if (
              ((f = c.tag === 13) &&
                ((f = c.memoizedState), (f = f !== null ? f.dehydrated !== null : !0)),
              f)
            )
              return c;
            c = c.return;
          } while (c !== null);
          return null;
        }
        function ia(c, f, y, M, T) {
          return c.mode & 1
            ? ((c.flags |= 65536), (c.lanes = T), c)
            : (c === f
                ? (c.flags |= 65536)
                : ((c.flags |= 128),
                  (y.flags |= 131072),
                  (y.flags &= -52805),
                  y.tag === 1 &&
                    (y.alternate === null
                      ? (y.tag = 17)
                      : ((f = ks(-1, 1)), (f.tag = 2), Ao(y, f))),
                  (y.lanes |= 1)),
              c);
        }
        function yi(c) {
          c.flags |= 4;
        }
        function Qa(c, f) {
          if (c !== null && c.child === f.child) return !0;
          if (f.flags & 16) return !1;
          for (c = f.child; c !== null; ) {
            if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
            c = c.sibling;
          }
          return !0;
        }
        var Rr, ra, kc, zc;
        if (Jt)
          (Rr = function (c, f) {
            for (var y = f.child; y !== null; ) {
              if (y.tag === 5 || y.tag === 6) ue(c, y.stateNode);
              else if (y.tag !== 4 && y.child !== null) {
                (y.child.return = y), (y = y.child);
                continue;
              }
              if (y === f) break;
              for (; y.sibling === null; ) {
                if (y.return === null || y.return === f) return;
                y = y.return;
              }
              (y.sibling.return = y.return), (y = y.sibling);
            }
          }),
            (ra = function () {}),
            (kc = function (c, f, y, M, T) {
              if (((c = c.memoizedProps), c !== M)) {
                var P = f.stateNode,
                  Z = ss(dr.current);
                (y = ge(P, y, c, M, T, Z)), (f.updateQueue = y) && yi(f);
              }
            }),
            (zc = function (c, f, y, M) {
              y !== M && yi(f);
            });
        else if (Ye) {
          Rr = function (c, f, y, M) {
            for (var T = f.child; T !== null; ) {
              if (T.tag === 5) {
                var P = T.stateNode;
                y && M && (P = an(P, T.type, T.memoizedProps, T)), ue(c, P);
              } else if (T.tag === 6)
                (P = T.stateNode), y && M && (P = qn(P, T.memoizedProps, T)), ue(c, P);
              else if (T.tag !== 4) {
                if (T.tag === 22 && T.memoizedState !== null)
                  (P = T.child), P !== null && (P.return = T), Rr(c, T, !0, !0);
                else if (T.child !== null) {
                  (T.child.return = T), (T = T.child);
                  continue;
                }
              }
              if (T === f) break;
              for (; T.sibling === null; ) {
                if (T.return === null || T.return === f) return;
                T = T.return;
              }
              (T.sibling.return = T.return), (T = T.sibling);
            }
          };
          var To = function (c, f, y, M) {
            for (var T = f.child; T !== null; ) {
              if (T.tag === 5) {
                var P = T.stateNode;
                y && M && (P = an(P, T.type, T.memoizedProps, T)), Gt(c, P);
              } else if (T.tag === 6)
                (P = T.stateNode), y && M && (P = qn(P, T.memoizedProps, T)), Gt(c, P);
              else if (T.tag !== 4) {
                if (T.tag === 22 && T.memoizedState !== null)
                  (P = T.child), P !== null && (P.return = T), To(c, T, !0, !0);
                else if (T.child !== null) {
                  (T.child.return = T), (T = T.child);
                  continue;
                }
              }
              if (T === f) break;
              for (; T.sibling === null; ) {
                if (T.return === null || T.return === f) return;
                T = T.return;
              }
              (T.sibling.return = T.return), (T = T.sibling);
            }
          };
          (ra = function (c, f) {
            var y = f.stateNode;
            if (!Qa(c, f)) {
              c = y.containerInfo;
              var M = dt(c);
              To(M, f, !1, !1), (y.pendingChildren = M), yi(f), _n(c, M);
            }
          }),
            (kc = function (c, f, y, M, T) {
              var P = c.stateNode,
                Z = c.memoizedProps;
              if ((c = Qa(c, f)) && Z === M) f.stateNode = P;
              else {
                var pe = f.stateNode,
                  Ne = ss(dr.current),
                  st = null;
                Z !== M && (st = ge(pe, y, Z, M, T, Ne)),
                  c && st === null
                    ? (f.stateNode = P)
                    : ((P = vt(P, st, y, Z, M, f, c, pe)),
                      He(P, y, M, T, Ne) && yi(f),
                      (f.stateNode = P),
                      c ? yi(f) : Rr(P, f, !1, !1));
              }
            }),
            (zc = function (c, f, y, M) {
              y !== M
                ? ((c = ss(qo.current)),
                  (y = ss(dr.current)),
                  (f.stateNode = Ie(M, c, y, f)),
                  yi(f))
                : (f.stateNode = c.stateNode);
            });
        } else (ra = function () {}), (kc = function () {}), (zc = function () {});
        function Xs(c, f) {
          if (!jn)
            switch (c.tailMode) {
              case 'hidden':
                f = c.tail;
                for (var y = null; f !== null; ) f.alternate !== null && (y = f), (f = f.sibling);
                y === null ? (c.tail = null) : (y.sibling = null);
                break;
              case 'collapsed':
                y = c.tail;
                for (var M = null; y !== null; ) y.alternate !== null && (M = y), (y = y.sibling);
                M === null
                  ? f || c.tail === null
                    ? (c.tail = null)
                    : (c.tail.sibling = null)
                  : (M.sibling = null);
            }
        }
        function li(c) {
          var f = c.alternate !== null && c.alternate.child === c.child,
            y = 0,
            M = 0;
          if (f)
            for (var T = c.child; T !== null; )
              (y |= T.lanes | T.childLanes),
                (M |= T.subtreeFlags & 14680064),
                (M |= T.flags & 14680064),
                (T.return = c),
                (T = T.sibling);
          else
            for (T = c.child; T !== null; )
              (y |= T.lanes | T.childLanes),
                (M |= T.subtreeFlags),
                (M |= T.flags),
                (T.return = c),
                (T = T.sibling);
          return (c.subtreeFlags |= M), (c.childLanes = y), f;
        }
        function Hc(c, f, y) {
          var M = f.pendingProps;
          switch ((id(f), f.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return li(f), null;
            case 1:
              return cn(f.type) && Wt(), li(f), null;
            case 3:
              return (
                (M = f.stateNode),
                Xa(),
                Xe(Dt),
                Xe(qt),
                $o(),
                M.pendingContext && ((M.context = M.pendingContext), (M.pendingContext = null)),
                (c === null || c.child === null) &&
                  (zl(f)
                    ? yi(f)
                    : c === null ||
                      (c.memoizedState.isDehydrated && !(f.flags & 256)) ||
                      ((f.flags |= 1024), Wr !== null && (lu(Wr), (Wr = null)))),
                ra(c, f),
                li(f),
                null
              );
            case 5:
              od(f), (y = ss(qo.current));
              var T = f.type;
              if (c !== null && f.stateNode != null)
                kc(c, f, T, M, y), c.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
              else {
                if (!M) {
                  if (f.stateNode === null) throw Error(a(166));
                  return li(f), null;
                }
                if (((c = ss(dr.current)), zl(f))) {
                  if (!ke) throw Error(a(175));
                  (c = F(f.stateNode, f.type, f.memoizedProps, y, c, f, !za)),
                    (f.updateQueue = c),
                    c !== null && yi(f);
                } else {
                  var P = Y(T, M, y, c, f);
                  Rr(P, f, !1, !1), (f.stateNode = P), He(P, T, M, y, c) && yi(f);
                }
                f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
              }
              return li(f), null;
            case 6:
              if (c && f.stateNode != null) zc(c, f, c.memoizedProps, M);
              else {
                if (typeof M != 'string' && f.stateNode === null) throw Error(a(166));
                if (((c = ss(qo.current)), (y = ss(dr.current)), zl(f))) {
                  if (!ke) throw Error(a(176));
                  if (
                    ((c = f.stateNode),
                    (M = f.memoizedProps),
                    (y = W(c, M, f, !za)) && ((T = $i), T !== null))
                  )
                    switch (((P = (T.mode & 1) !== 0), T.tag)) {
                      case 3:
                        Q(T.stateNode.containerInfo, c, M, P);
                        break;
                      case 5:
                        ee(T.type, T.memoizedProps, T.stateNode, c, M, P);
                    }
                  y && yi(f);
                } else f.stateNode = Ie(M, c, y, f);
              }
              return li(f), null;
            case 13:
              if (
                (Xe($n), (M = f.memoizedState), jn && Bi !== null && f.mode & 1 && !(f.flags & 128))
              ) {
                for (c = Bi; c; ) c = Ii(c);
                return Ha(), (f.flags |= 98560), f;
              }
              if (M !== null && M.dehydrated !== null) {
                if (((M = zl(f)), c === null)) {
                  if (!M) throw Error(a(318));
                  if (!ke) throw Error(a(344));
                  if (((c = f.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
                    throw Error(a(317));
                  se(c, f);
                } else Ha(), !(f.flags & 128) && (f.memoizedState = null), (f.flags |= 4);
                return li(f), null;
              }
              return (
                Wr !== null && (lu(Wr), (Wr = null)),
                f.flags & 128
                  ? ((f.lanes = y), f)
                  : ((M = M !== null),
                    (y = !1),
                    c === null ? zl(f) : (y = c.memoizedState !== null),
                    M &&
                      !y &&
                      ((f.child.flags |= 8192),
                      f.mode & 1 && (c === null || $n.current & 1 ? ri === 0 && (ri = 3) : Kc())),
                    f.updateQueue !== null && (f.flags |= 4),
                    li(f),
                    null)
              );
            case 4:
              return Xa(), ra(c, f), c === null && It(f.stateNode.containerInfo), li(f), null;
            case 10:
              return kl(f.type._context), li(f), null;
            case 17:
              return cn(f.type) && Wt(), li(f), null;
            case 19:
              if ((Xe($n), (T = f.memoizedState), T === null)) return li(f), null;
              if (((M = (f.flags & 128) !== 0), (P = T.rendering), P === null))
                if (M) Xs(T, !1);
                else {
                  if (ri !== 0 || (c !== null && c.flags & 128))
                    for (c = f.child; c !== null; ) {
                      if (((P = Tc(c)), P !== null)) {
                        for (
                          f.flags |= 128,
                            Xs(T, !1),
                            c = P.updateQueue,
                            c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                            f.subtreeFlags = 0,
                            c = y,
                            M = f.child;
                          M !== null;

                        )
                          (y = M),
                            (T = c),
                            (y.flags &= 14680066),
                            (P = y.alternate),
                            P === null
                              ? ((y.childLanes = 0),
                                (y.lanes = T),
                                (y.child = null),
                                (y.subtreeFlags = 0),
                                (y.memoizedProps = null),
                                (y.memoizedState = null),
                                (y.updateQueue = null),
                                (y.dependencies = null),
                                (y.stateNode = null))
                              : ((y.childLanes = P.childLanes),
                                (y.lanes = P.lanes),
                                (y.child = P.child),
                                (y.subtreeFlags = 0),
                                (y.deletions = null),
                                (y.memoizedProps = P.memoizedProps),
                                (y.memoizedState = P.memoizedState),
                                (y.updateQueue = P.updateQueue),
                                (y.type = P.type),
                                (T = P.dependencies),
                                (y.dependencies =
                                  T === null
                                    ? null
                                    : { lanes: T.lanes, firstContext: T.firstContext })),
                            (M = M.sibling);
                        return mt($n, ($n.current & 1) | 2), f.child;
                      }
                      c = c.sibling;
                    }
                  T.tail !== null &&
                    vi() > Io &&
                    ((f.flags |= 128), (M = !0), Xs(T, !1), (f.lanes = 4194304));
                }
              else {
                if (!M)
                  if (((c = Tc(P)), c !== null)) {
                    if (
                      ((f.flags |= 128),
                      (M = !0),
                      (c = c.updateQueue),
                      c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                      Xs(T, !0),
                      T.tail === null && T.tailMode === 'hidden' && !P.alternate && !jn)
                    )
                      return li(f), null;
                  } else
                    2 * vi() - T.renderingStartTime > Io &&
                      y !== 1073741824 &&
                      ((f.flags |= 128), (M = !0), Xs(T, !1), (f.lanes = 4194304));
                T.isBackwards
                  ? ((P.sibling = f.child), (f.child = P))
                  : ((c = T.last), c !== null ? (c.sibling = P) : (f.child = P), (T.last = P));
              }
              return T.tail !== null
                ? ((f = T.tail),
                  (T.rendering = f),
                  (T.tail = f.sibling),
                  (T.renderingStartTime = vi()),
                  (f.sibling = null),
                  (c = $n.current),
                  mt($n, M ? (c & 1) | 2 : c & 1),
                  f)
                : (li(f), null);
            case 22:
            case 23:
              return (
                uu(),
                (M = f.memoizedState !== null),
                c !== null && (c.memoizedState !== null) !== M && (f.flags |= 8192),
                M && f.mode & 1
                  ? Gi & 1073741824 && (li(f), Jt && f.subtreeFlags & 6 && (f.flags |= 8192))
                  : li(f),
                null
              );
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(a(156, f.tag));
        }
        var vd = u.ReactCurrentOwner,
          Ci = !1;
        function ii(c, f, y, M) {
          f.child = c === null ? up(f, null, y, M) : Gs(f, c.child, y, M);
        }
        function Wn(c, f, y, M, T) {
          y = y.render;
          var P = f.ref;
          return (
            Ua(f, T),
            (M = Ja(c, f, y, M, P, T)),
            (y = wo()),
            c !== null && !Ci
              ? ((f.updateQueue = c.updateQueue), (f.flags &= -2053), (c.lanes &= ~T), hr(c, f, T))
              : (jn && y && nd(f), (f.flags |= 1), ii(c, f, M, T), f.child)
          );
        }
        function kn(c, f, y, M, T) {
          if (c === null) {
            var P = y.type;
            return typeof P == 'function' &&
              !Zc(P) &&
              P.defaultProps === void 0 &&
              y.compare === null &&
              y.defaultProps === void 0
              ? ((f.tag = 15), (f.type = P), Js(c, f, P, M, T))
              : ((c = Qc(y.type, null, M, f, f.mode, T)),
                (c.ref = f.ref),
                (c.return = f),
                (f.child = c));
          }
          if (((P = c.child), !(c.lanes & T))) {
            var Z = P.memoizedProps;
            if (((y = y.compare), (y = y !== null ? y : rs), y(Z, M) && c.ref === f.ref))
              return hr(c, f, T);
          }
          return (f.flags |= 1), (c = to(P, M)), (c.ref = f.ref), (c.return = f), (f.child = c);
        }
        function Js(c, f, y, M, T) {
          if (c !== null && rs(c.memoizedProps, M) && c.ref === f.ref)
            if (((Ci = !1), (c.lanes & T) !== 0)) c.flags & 131072 && (Ci = !0);
            else return (f.lanes = c.lanes), hr(c, f, T);
          return Ys(c, f, y, M, T);
        }
        function Pi(c, f, y) {
          var M = f.pendingProps,
            T = M.children,
            P = c !== null ? c.memoizedState : null;
          if (M.mode === 'hidden')
            if (!(f.mode & 1))
              (f.memoizedState = { baseLanes: 0, cachePool: null }), mt(ha, Gi), (Gi |= y);
            else if (y & 1073741824)
              (f.memoizedState = { baseLanes: 0, cachePool: null }),
                (M = P !== null ? P.baseLanes : y),
                mt(ha, Gi),
                (Gi |= M);
            else
              return (
                (c = P !== null ? P.baseLanes | y : y),
                (f.lanes = f.childLanes = 1073741824),
                (f.memoizedState = { baseLanes: c, cachePool: null }),
                (f.updateQueue = null),
                mt(ha, Gi),
                (Gi |= c),
                null
              );
          else
            P !== null ? ((M = P.baseLanes | y), (f.memoizedState = null)) : (M = y),
              mt(ha, Gi),
              (Gi |= M);
          return ii(c, f, T, y), f.child;
        }
        function er(c, f) {
          var y = f.ref;
          ((c === null && y !== null) || (c !== null && c.ref !== y)) &&
            ((f.flags |= 512), (f.flags |= 2097152));
        }
        function Ys(c, f, y, M, T) {
          var P = cn(y) ? Ut : qt.current;
          return (
            (P = Mt(f, P)),
            Ua(f, T),
            (y = Ja(c, f, y, M, P, T)),
            (M = wo()),
            c !== null && !Ci
              ? ((f.updateQueue = c.updateQueue), (f.flags &= -2053), (c.lanes &= ~T), hr(c, f, T))
              : (jn && M && nd(f), (f.flags |= 1), ii(c, f, y, T), f.child)
          );
        }
        function sa(c, f, y, M, T) {
          if (cn(y)) {
            var P = !0;
            on(f);
          } else P = !1;
          if ((Ua(f, T), f.stateNode === null))
            c !== null && ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
              rp(f, y, M),
              td(f, y, M, T),
              (M = !0);
          else if (c === null) {
            var Z = f.stateNode,
              pe = f.memoizedProps;
            Z.props = pe;
            var Ne = Z.context,
              st = y.contextType;
            typeof st == 'object' && st !== null
              ? (st = fr(st))
              : ((st = cn(y) ? Ut : qt.current), (st = Mt(f, st)));
            var bt = y.getDerivedStateFromProps,
              rn = typeof bt == 'function' || typeof Z.getSnapshotBeforeUpdate == 'function';
            rn ||
              (typeof Z.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof Z.componentWillReceiveProps != 'function') ||
              ((pe !== M || Ne !== st) && sp(f, Z, M, st)),
              (Gr = !1);
            var Xt = f.memoizedState;
            (Z.state = Xt),
              xc(f, M, Z, T),
              (Ne = f.memoizedState),
              pe !== M || Xt !== Ne || Dt.current || Gr
                ? (typeof bt == 'function' && ($f(f, y, bt, M), (Ne = f.memoizedState)),
                  (pe = Gr || ed(f, y, pe, M, Xt, Ne, st))
                    ? (rn ||
                        (typeof Z.UNSAFE_componentWillMount != 'function' &&
                          typeof Z.componentWillMount != 'function') ||
                        (typeof Z.componentWillMount == 'function' && Z.componentWillMount(),
                        typeof Z.UNSAFE_componentWillMount == 'function' &&
                          Z.UNSAFE_componentWillMount()),
                      typeof Z.componentDidMount == 'function' && (f.flags |= 4194308))
                    : (typeof Z.componentDidMount == 'function' && (f.flags |= 4194308),
                      (f.memoizedProps = M),
                      (f.memoizedState = Ne)),
                  (Z.props = M),
                  (Z.state = Ne),
                  (Z.context = st),
                  (M = pe))
                : (typeof Z.componentDidMount == 'function' && (f.flags |= 4194308), (M = !1));
          } else {
            (Z = f.stateNode),
              qf(c, f),
              (pe = f.memoizedProps),
              (st = f.type === f.elementType ? pe : cr(f.type, pe)),
              (Z.props = st),
              (rn = f.pendingProps),
              (Xt = Z.context),
              (Ne = y.contextType),
              typeof Ne == 'object' && Ne !== null
                ? (Ne = fr(Ne))
                : ((Ne = cn(y) ? Ut : qt.current), (Ne = Mt(f, Ne)));
            var mn = y.getDerivedStateFromProps;
            (bt = typeof mn == 'function' || typeof Z.getSnapshotBeforeUpdate == 'function') ||
              (typeof Z.UNSAFE_componentWillReceiveProps != 'function' &&
                typeof Z.componentWillReceiveProps != 'function') ||
              ((pe !== rn || Xt !== Ne) && sp(f, Z, M, Ne)),
              (Gr = !1),
              (Xt = f.memoizedState),
              (Z.state = Xt),
              xc(f, M, Z, T);
            var Et = f.memoizedState;
            pe !== rn || Xt !== Et || Dt.current || Gr
              ? (typeof mn == 'function' && ($f(f, y, mn, M), (Et = f.memoizedState)),
                (st = Gr || ed(f, y, st, M, Xt, Et, Ne) || !1)
                  ? (bt ||
                      (typeof Z.UNSAFE_componentWillUpdate != 'function' &&
                        typeof Z.componentWillUpdate != 'function') ||
                      (typeof Z.componentWillUpdate == 'function' &&
                        Z.componentWillUpdate(M, Et, Ne),
                      typeof Z.UNSAFE_componentWillUpdate == 'function' &&
                        Z.UNSAFE_componentWillUpdate(M, Et, Ne)),
                    typeof Z.componentDidUpdate == 'function' && (f.flags |= 4),
                    typeof Z.getSnapshotBeforeUpdate == 'function' && (f.flags |= 1024))
                  : (typeof Z.componentDidUpdate != 'function' ||
                      (pe === c.memoizedProps && Xt === c.memoizedState) ||
                      (f.flags |= 4),
                    typeof Z.getSnapshotBeforeUpdate != 'function' ||
                      (pe === c.memoizedProps && Xt === c.memoizedState) ||
                      (f.flags |= 1024),
                    (f.memoizedProps = M),
                    (f.memoizedState = Et)),
                (Z.props = M),
                (Z.state = Et),
                (Z.context = Ne),
                (M = st))
              : (typeof Z.componentDidUpdate != 'function' ||
                  (pe === c.memoizedProps && Xt === c.memoizedState) ||
                  (f.flags |= 4),
                typeof Z.getSnapshotBeforeUpdate != 'function' ||
                  (pe === c.memoizedProps && Xt === c.memoizedState) ||
                  (f.flags |= 1024),
                (M = !1));
          }
          return Hi(c, f, y, M, P, T);
        }
        function Hi(c, f, y, M, T, P) {
          er(c, f);
          var Z = (f.flags & 128) !== 0;
          if (!M && !Z) return T && pn(f, y, !1), hr(c, f, P);
          (M = f.stateNode), (vd.current = f);
          var pe = Z && typeof y.getDerivedStateFromError != 'function' ? null : M.render();
          return (
            (f.flags |= 1),
            c !== null && Z
              ? ((f.child = Gs(f, c.child, null, P)), (f.child = Gs(f, null, pe, P)))
              : ii(c, f, pe, P),
            (f.memoizedState = M.state),
            T && pn(f, y, !0),
            f.child
          );
        }
        function Zl(c) {
          var f = c.stateNode;
          f.pendingContext
            ? en(c, f.pendingContext, f.pendingContext !== f.context)
            : f.context && en(c, f.context, !1),
            Cc(c, f.containerInfo);
        }
        function yd(c, f, y, M, T) {
          return Ha(), wc(T), (f.flags |= 256), ii(c, f, y, M), f.child;
        }
        var Ql = { dehydrated: null, treeContext: null, retryLane: 0 };
        function oa(c) {
          return { baseLanes: c, cachePool: null };
        }
        function _d(c, f, y) {
          var M = f.pendingProps,
            T = $n.current,
            P = !1,
            Z = (f.flags & 128) !== 0,
            pe;
          if (
            ((pe = Z) || (pe = c !== null && c.memoizedState === null ? !1 : (T & 2) !== 0),
            pe
              ? ((P = !0), (f.flags &= -129))
              : (c === null || c.memoizedState !== null) && (T |= 1),
            mt($n, T & 1),
            c === null)
          )
            return (
              Mo(f),
              (c = f.memoizedState),
              c !== null && ((c = c.dehydrated), c !== null)
                ? (f.mode & 1 ? (Mr(c) ? (f.lanes = 8) : (f.lanes = 1073741824)) : (f.lanes = 1),
                  null)
                : ((T = M.children),
                  (c = M.fallback),
                  P
                    ? ((M = f.mode),
                      (P = f.child),
                      (T = { mode: 'hidden', children: T }),
                      !(M & 1) && P !== null
                        ? ((P.childLanes = 0), (P.pendingProps = T))
                        : (P = du(T, M, 0, null)),
                      (c = ya(c, M, y, null)),
                      (P.return = f),
                      (c.return = f),
                      (P.sibling = c),
                      (f.child = P),
                      (f.child.memoizedState = oa(y)),
                      (f.memoizedState = Ql),
                      c)
                    : ls(f, T))
            );
          if (((T = c.memoizedState), T !== null)) {
            if (((pe = T.dehydrated), pe !== null)) {
              if (Z)
                return f.flags & 256
                  ? ((f.flags &= -257), $l(c, f, y, Error(a(422))))
                  : f.memoizedState !== null
                  ? ((f.child = c.child), (f.flags |= 128), null)
                  : ((P = M.fallback),
                    (T = f.mode),
                    (M = du({ mode: 'visible', children: M.children }, T, 0, null)),
                    (P = ya(P, T, y, null)),
                    (P.flags |= 2),
                    (M.return = f),
                    (P.return = f),
                    (M.sibling = P),
                    (f.child = M),
                    f.mode & 1 && Gs(f, c.child, null, y),
                    (f.child.memoizedState = oa(y)),
                    (f.memoizedState = Ql),
                    P);
              if (!(f.mode & 1)) f = $l(c, f, y, null);
              else if (Mr(pe)) f = $l(c, f, y, Error(a(419)));
              else if (((M = (y & c.childLanes) !== 0), Ci || M)) {
                if (((M = ui), M !== null)) {
                  switch (y & -y) {
                    case 4:
                      P = 2;
                      break;
                    case 16:
                      P = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      P = 32;
                      break;
                    case 536870912:
                      P = 268435456;
                      break;
                    default:
                      P = 0;
                  }
                  (M = P & (M.suspendedLanes | y) ? 0 : P),
                    M !== 0 && M !== T.retryLane && ((T.retryLane = M), Vi(c, M, -1));
                }
                Kc(), (f = $l(c, f, y, Error(a(421))));
              } else
                Zi(pe)
                  ? ((f.flags |= 128),
                    (f.child = c.child),
                    (f = _p.bind(null, c)),
                    Er(pe, f),
                    (f = null))
                  : ((y = T.treeContext),
                    ke &&
                      ((Bi = _o(pe)),
                      ($i = f),
                      (jn = !0),
                      (Wr = null),
                      (za = !1),
                      y !== null &&
                        ((Vr[wr++] = zs),
                        (Vr[wr++] = Hs),
                        (Vr[wr++] = jo),
                        (zs = y.id),
                        (Hs = y.overflow),
                        (jo = f))),
                    (f = ls(f, f.pendingProps.children)),
                    (f.flags |= 4096));
              return f;
            }
            return P
              ? ((M = Gc(c, f, M.children, M.fallback, y)),
                (P = f.child),
                (T = c.child.memoizedState),
                (P.memoizedState =
                  T === null ? oa(y) : { baseLanes: T.baseLanes | y, cachePool: null }),
                (P.childLanes = c.childLanes & ~y),
                (f.memoizedState = Ql),
                M)
              : ((y = ql(c, f, M.children, y)), (f.memoizedState = null), y);
          }
          return P
            ? ((M = Gc(c, f, M.children, M.fallback, y)),
              (P = f.child),
              (T = c.child.memoizedState),
              (P.memoizedState =
                T === null ? oa(y) : { baseLanes: T.baseLanes | y, cachePool: null }),
              (P.childLanes = c.childLanes & ~y),
              (f.memoizedState = Ql),
              M)
            : ((y = ql(c, f, M.children, y)), (f.memoizedState = null), y);
        }
        function ls(c, f) {
          return (
            (f = du({ mode: 'visible', children: f }, c.mode, 0, null)),
            (f.return = c),
            (c.child = f)
          );
        }
        function ql(c, f, y, M) {
          var T = c.child;
          return (
            (c = T.sibling),
            (y = to(T, { mode: 'visible', children: y })),
            !(f.mode & 1) && (y.lanes = M),
            (y.return = f),
            (y.sibling = null),
            c !== null &&
              ((M = f.deletions), M === null ? ((f.deletions = [c]), (f.flags |= 16)) : M.push(c)),
            (f.child = y)
          );
        }
        function Gc(c, f, y, M, T) {
          var P = f.mode;
          c = c.child;
          var Z = c.sibling,
            pe = { mode: 'hidden', children: y };
          return (
            !(P & 1) && f.child !== c
              ? ((y = f.child), (y.childLanes = 0), (y.pendingProps = pe), (f.deletions = null))
              : ((y = to(c, pe)), (y.subtreeFlags = c.subtreeFlags & 14680064)),
            Z !== null ? (M = to(Z, M)) : ((M = ya(M, P, T, null)), (M.flags |= 2)),
            (M.return = f),
            (y.return = f),
            (y.sibling = M),
            (f.child = y),
            M
          );
        }
        function $l(c, f, y, M) {
          return (
            M !== null && wc(M),
            Gs(f, c.child, null, y),
            (c = ls(f, f.pendingProps.children)),
            (c.flags |= 2),
            (f.memoizedState = null),
            c
          );
        }
        function mp(c, f, y) {
          c.lanes |= f;
          var M = c.alternate;
          M !== null && (M.lanes |= f), Ko(c.return, f, y);
        }
        function Es(c, f, y, M, T) {
          var P = c.memoizedState;
          P === null
            ? (c.memoizedState = {
                isBackwards: f,
                rendering: null,
                renderingStartTime: 0,
                last: M,
                tail: y,
                tailMode: T,
              })
            : ((P.isBackwards = f),
              (P.rendering = null),
              (P.renderingStartTime = 0),
              (P.last = M),
              (P.tail = y),
              (P.tailMode = T));
        }
        function aa(c, f, y) {
          var M = f.pendingProps,
            T = M.revealOrder,
            P = M.tail;
          if ((ii(c, f, M.children, y), (M = $n.current), M & 2))
            (M = (M & 1) | 2), (f.flags |= 128);
          else {
            if (c !== null && c.flags & 128)
              e: for (c = f.child; c !== null; ) {
                if (c.tag === 13) c.memoizedState !== null && mp(c, y, f);
                else if (c.tag === 19) mp(c, y, f);
                else if (c.child !== null) {
                  (c.child.return = c), (c = c.child);
                  continue;
                }
                if (c === f) break e;
                for (; c.sibling === null; ) {
                  if (c.return === null || c.return === f) break e;
                  c = c.return;
                }
                (c.sibling.return = c.return), (c = c.sibling);
              }
            M &= 1;
          }
          if ((mt($n, M), !(f.mode & 1))) f.memoizedState = null;
          else
            switch (T) {
              case 'forwards':
                for (y = f.child, T = null; y !== null; )
                  (c = y.alternate), c !== null && Tc(c) === null && (T = y), (y = y.sibling);
                (y = T),
                  y === null
                    ? ((T = f.child), (f.child = null))
                    : ((T = y.sibling), (y.sibling = null)),
                  Es(f, !1, T, y, P);
                break;
              case 'backwards':
                for (y = null, T = f.child, f.child = null; T !== null; ) {
                  if (((c = T.alternate), c !== null && Tc(c) === null)) {
                    f.child = T;
                    break;
                  }
                  (c = T.sibling), (T.sibling = y), (y = T), (T = c);
                }
                Es(f, !0, y, null, P);
                break;
              case 'together':
                Es(f, !1, null, null, void 0);
                break;
              default:
                f.memoizedState = null;
            }
          return f.child;
        }
        function hr(c, f, y) {
          if (
            (c !== null && (f.dependencies = c.dependencies), (ws |= f.lanes), !(y & f.childLanes))
          )
            return null;
          if (c !== null && f.child !== c.child) throw Error(a(153));
          if (f.child !== null) {
            for (
              c = f.child, y = to(c, c.pendingProps), f.child = y, y.return = f;
              c.sibling !== null;

            )
              (c = c.sibling), (y = y.sibling = to(c, c.pendingProps)), (y.return = f);
            y.sibling = null;
          }
          return f.child;
        }
        function Vc(c, f, y) {
          switch (f.tag) {
            case 3:
              Zl(f), Ha();
              break;
            case 5:
              cp(f);
              break;
            case 1:
              cn(f.type) && on(f);
              break;
            case 4:
              Cc(f, f.stateNode.containerInfo);
              break;
            case 10:
              Yo(f, f.type._context, f.memoizedProps.value);
              break;
            case 13:
              var M = f.memoizedState;
              if (M !== null)
                return M.dehydrated !== null
                  ? (mt($n, $n.current & 1), (f.flags |= 128), null)
                  : y & f.child.childLanes
                  ? _d(c, f, y)
                  : (mt($n, $n.current & 1), (c = hr(c, f, y)), c !== null ? c.sibling : null);
              mt($n, $n.current & 1);
              break;
            case 19:
              if (((M = (y & f.childLanes) !== 0), c.flags & 128)) {
                if (M) return aa(c, f, y);
                f.flags |= 128;
              }
              var T = f.memoizedState;
              if (
                (T !== null && ((T.rendering = null), (T.tail = null), (T.lastEffect = null)),
                mt($n, $n.current),
                M)
              )
                break;
              return null;
            case 22:
            case 23:
              return (f.lanes = 0), Pi(c, f, y);
          }
          return hr(c, f, y);
        }
        function Wc(c, f) {
          switch ((id(f), f.tag)) {
            case 1:
              return (
                cn(f.type) && Wt(),
                (c = f.flags),
                c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
              );
            case 3:
              return (
                Xa(),
                Xe(Dt),
                Xe(qt),
                $o(),
                (c = f.flags),
                c & 65536 && !(c & 128) ? ((f.flags = (c & -65537) | 128), f) : null
              );
            case 5:
              return od(f), null;
            case 13:
              if ((Xe($n), (c = f.memoizedState), c !== null && c.dehydrated !== null)) {
                if (f.alternate === null) throw Error(a(340));
                Ha();
              }
              return (c = f.flags), c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null;
            case 19:
              return Xe($n), null;
            case 4:
              return Xa(), null;
            case 10:
              return kl(f.type._context), null;
            case 22:
            case 23:
              return uu(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var tr = !1,
          Ti = !1,
          la = typeof WeakSet == 'function' ? WeakSet : Set,
          ct = null;
        function Xr(c, f) {
          var y = c.ref;
          if (y !== null)
            if (typeof y == 'function')
              try {
                y(null);
              } catch (M) {
                ir(c, f, M);
              }
            else y.current = null;
        }
        function Ks(c, f, y) {
          try {
            y();
          } catch (M) {
            ir(c, f, M);
          }
        }
        var xd = !1;
        function Ad(c, f) {
          for (fe(c.containerInfo), ct = f; ct !== null; )
            if (((c = ct), (f = c.child), (c.subtreeFlags & 1028) !== 0 && f !== null))
              (f.return = c), (ct = f);
            else
              for (; ct !== null; ) {
                c = ct;
                try {
                  var y = c.alternate;
                  if (c.flags & 1024)
                    switch (c.tag) {
                      case 0:
                      case 11:
                      case 15:
                        break;
                      case 1:
                        if (y !== null) {
                          var M = y.memoizedProps,
                            T = y.memoizedState,
                            P = c.stateNode,
                            Z = P.getSnapshotBeforeUpdate(
                              c.elementType === c.type ? M : cr(c.type, M),
                              T,
                            );
                          P.__reactInternalSnapshotBeforeUpdate = Z;
                        }
                        break;
                      case 3:
                        Jt && Oe(c.stateNode.containerInfo);
                        break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                        break;
                      default:
                        throw Error(a(163));
                    }
                } catch (pe) {
                  ir(c, c.return, pe);
                }
                if (((f = c.sibling), f !== null)) {
                  (f.return = c.return), (ct = f);
                  break;
                }
                ct = c.return;
              }
          return (y = xd), (xd = !1), y;
        }
        function js(c, f, y) {
          var M = f.updateQueue;
          if (((M = M !== null ? M.lastEffect : null), M !== null)) {
            var T = (M = M.next);
            do {
              if ((T.tag & c) === c) {
                var P = T.destroy;
                (T.destroy = void 0), P !== void 0 && Ks(f, y, P);
              }
              T = T.next;
            } while (T !== M);
          }
        }
        function Di(c, f) {
          if (((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)) {
            var y = (f = f.next);
            do {
              if ((y.tag & c) === c) {
                var M = y.create;
                y.destroy = M();
              }
              y = y.next;
            } while (y !== f);
          }
        }
        function nr(c) {
          var f = c.ref;
          if (f !== null) {
            var y = c.stateNode;
            switch (c.tag) {
              case 5:
                c = de(y);
                break;
              default:
                c = y;
            }
            typeof f == 'function' ? f(c) : (f.current = c);
          }
        }
        function Jn(c, f, y) {
          if (As && typeof As.onCommitFiberUnmount == 'function')
            try {
              As.onCommitFiberUnmount(Fl, f);
            } catch {}
          switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if (((c = f.updateQueue), c !== null && ((c = c.lastEffect), c !== null))) {
                var M = (c = c.next);
                do {
                  var T = M,
                    P = T.destroy;
                  (T = T.tag), P !== void 0 && (T & 2 || T & 4) && Ks(f, y, P), (M = M.next);
                } while (M !== c);
              }
              break;
            case 1:
              if ((Xr(f, y), (c = f.stateNode), typeof c.componentWillUnmount == 'function'))
                try {
                  (c.props = f.memoizedProps),
                    (c.state = f.memoizedState),
                    c.componentWillUnmount();
                } catch (Z) {
                  ir(f, y, Z);
                }
              break;
            case 5:
              Xr(f, y);
              break;
            case 4:
              Jt
                ? Ed(c, f, y)
                : Ye && Ye && ((f = f.stateNode.containerInfo), (y = dt(f)), Nn(f, y));
          }
        }
        function Jr(c, f, y) {
          for (var M = f; ; )
            if ((Jn(c, M, y), M.child === null || (Jt && M.tag === 4))) {
              if (M === f) break;
              for (; M.sibling === null; ) {
                if (M.return === null || M.return === f) return;
                M = M.return;
              }
              (M.sibling.return = M.return), (M = M.sibling);
            } else (M.child.return = M), (M = M.child);
        }
        function Sd(c) {
          var f = c.alternate;
          f !== null && ((c.alternate = null), Sd(f)),
            (c.child = null),
            (c.deletions = null),
            (c.sibling = null),
            c.tag === 5 && ((f = c.stateNode), f !== null && yt(f)),
            (c.stateNode = null),
            (c.return = null),
            (c.dependencies = null),
            (c.memoizedProps = null),
            (c.memoizedState = null),
            (c.pendingProps = null),
            (c.stateNode = null),
            (c.updateQueue = null);
        }
        function Md(c) {
          return c.tag === 5 || c.tag === 3 || c.tag === 4;
        }
        function Xc(c) {
          e: for (;;) {
            for (; c.sibling === null; ) {
              if (c.return === null || Md(c.return)) return null;
              c = c.return;
            }
            for (
              c.sibling.return = c.return, c = c.sibling;
              c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

            ) {
              if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
              (c.child.return = c), (c = c.child);
            }
            if (!(c.flags & 2)) return c.stateNode;
          }
        }
        function Jc(c) {
          if (Jt) {
            e: {
              for (var f = c.return; f !== null; ) {
                if (Md(f)) break e;
                f = f.return;
              }
              throw Error(a(160));
            }
            var y = f;
            switch (y.tag) {
              case 5:
                (f = y.stateNode),
                  y.flags & 32 && (Re(f), (y.flags &= -33)),
                  (y = Xc(c)),
                  qa(c, y, f);
                break;
              case 3:
              case 4:
                (f = y.stateNode.containerInfo), (y = Xc(c)), Yc(c, y, f);
                break;
              default:
                throw Error(a(161));
            }
          }
        }
        function Yc(c, f, y) {
          var M = c.tag;
          if (M === 5 || M === 6) (c = c.stateNode), f ? Rt(y, c, f) : pt(y, c);
          else if (M !== 4 && ((c = c.child), c !== null))
            for (Yc(c, f, y), c = c.sibling; c !== null; ) Yc(c, f, y), (c = c.sibling);
        }
        function qa(c, f, y) {
          var M = c.tag;
          if (M === 5 || M === 6) (c = c.stateNode), f ? Ft(y, c, f) : at(y, c);
          else if (M !== 4 && ((c = c.child), c !== null))
            for (qa(c, f, y), c = c.sibling; c !== null; ) qa(c, f, y), (c = c.sibling);
        }
        function Ed(c, f, y) {
          for (var M = f, T = !1, P, Z; ; ) {
            if (!T) {
              T = M.return;
              e: for (;;) {
                if (T === null) throw Error(a(160));
                switch (((P = T.stateNode), T.tag)) {
                  case 5:
                    Z = !1;
                    break e;
                  case 3:
                    (P = P.containerInfo), (Z = !0);
                    break e;
                  case 4:
                    (P = P.containerInfo), (Z = !0);
                    break e;
                }
                T = T.return;
              }
              T = !0;
            }
            if (M.tag === 5 || M.tag === 6)
              Jr(c, M, y), Z ? re(P, M.stateNode) : St(P, M.stateNode);
            else if (M.tag === 18) Z ? Qe(P, M.stateNode) : it(P, M.stateNode);
            else if (M.tag === 4) {
              if (M.child !== null) {
                (P = M.stateNode.containerInfo), (Z = !0), (M.child.return = M), (M = M.child);
                continue;
              }
            } else if ((Jn(c, M, y), M.child !== null)) {
              (M.child.return = M), (M = M.child);
              continue;
            }
            if (M === f) break;
            for (; M.sibling === null; ) {
              if (M.return === null || M.return === f) return;
              (M = M.return), M.tag === 4 && (T = !1);
            }
            (M.sibling.return = M.return), (M = M.sibling);
          }
        }
        function Ro(c, f) {
          if (Jt) {
            switch (f.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                js(3, f, f.return), Di(3, f), js(5, f, f.return);
                return;
              case 1:
                return;
              case 5:
                var y = f.stateNode;
                if (y != null) {
                  var M = f.memoizedProps;
                  c = c !== null ? c.memoizedProps : M;
                  var T = f.type,
                    P = f.updateQueue;
                  (f.updateQueue = null), P !== null && wt(y, P, T, c, M, f);
                }
                return;
              case 6:
                if (f.stateNode === null) throw Error(a(162));
                (y = f.memoizedProps), $t(f.stateNode, c !== null ? c.memoizedProps : y, y);
                return;
              case 3:
                ke && c !== null && c.memoizedState.isDehydrated && Be(f.stateNode.containerInfo);
                return;
              case 12:
                return;
              case 13:
                $a(f);
                return;
              case 19:
                $a(f);
                return;
              case 17:
                return;
            }
            throw Error(a(163));
          }
          switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              js(3, f, f.return), Di(3, f), js(5, f, f.return);
              return;
            case 12:
              return;
            case 13:
              $a(f);
              return;
            case 19:
              $a(f);
              return;
            case 3:
              ke && c !== null && c.memoizedState.isDehydrated && Be(f.stateNode.containerInfo);
              break;
            case 22:
            case 23:
              return;
          }
          e: if (Ye) {
            switch (f.tag) {
              case 1:
              case 5:
              case 6:
                break e;
              case 3:
              case 4:
                (f = f.stateNode), Nn(f.containerInfo, f.pendingChildren);
                break e;
            }
            throw Error(a(163));
          }
        }
        function $a(c) {
          var f = c.updateQueue;
          if (f !== null) {
            c.updateQueue = null;
            var y = c.stateNode;
            y === null && (y = c.stateNode = new la()),
              f.forEach(function (M) {
                var T = xp.bind(null, c, M);
                y.has(M) || (y.add(M), M.then(T, T));
              });
          }
        }
        function xv(c, f) {
          for (ct = f; ct !== null; ) {
            f = ct;
            var y = f.deletions;
            if (y !== null)
              for (var M = 0; M < y.length; M++) {
                var T = y[M];
                try {
                  var P = c;
                  Jt ? Ed(P, T, f) : Jr(P, T, f);
                  var Z = T.alternate;
                  Z !== null && (Z.return = null), (T.return = null);
                } catch (Ot) {
                  ir(T, f, Ot);
                }
              }
            if (((y = f.child), f.subtreeFlags & 12854 && y !== null)) (y.return = f), (ct = y);
            else
              for (; ct !== null; ) {
                f = ct;
                try {
                  var pe = f.flags;
                  if ((pe & 32 && Jt && Re(f.stateNode), pe & 512)) {
                    var Ne = f.alternate;
                    if (Ne !== null) {
                      var st = Ne.ref;
                      st !== null && (typeof st == 'function' ? st(null) : (st.current = null));
                    }
                  }
                  if (pe & 8192)
                    switch (f.tag) {
                      case 13:
                        if (f.memoizedState !== null) {
                          var bt = f.alternate;
                          (bt === null || bt.memoizedState === null) && (ou = vi());
                        }
                        break;
                      case 22:
                        var rn = f.memoizedState !== null,
                          Xt = f.alternate,
                          mn = Xt !== null && Xt.memoizedState !== null;
                        if (((y = f), Jt)) {
                          e: if (((M = y), (T = rn), (P = null), Jt))
                            for (var Et = M; ; ) {
                              if (Et.tag === 5) {
                                if (P === null) {
                                  P = Et;
                                  var Ni = Et.stateNode;
                                  T ? tt(Ni) : ye(Et.stateNode, Et.memoizedProps);
                                }
                              } else if (Et.tag === 6) {
                                if (P === null) {
                                  var Dr = Et.stateNode;
                                  T ? ne(Dr) : we(Dr, Et.memoizedProps);
                                }
                              } else if (
                                ((Et.tag !== 22 && Et.tag !== 23) ||
                                  Et.memoizedState === null ||
                                  Et === M) &&
                                Et.child !== null
                              ) {
                                (Et.child.return = Et), (Et = Et.child);
                                continue;
                              }
                              if (Et === M) break;
                              for (; Et.sibling === null; ) {
                                if (Et.return === null || Et.return === M) break e;
                                P === Et && (P = null), (Et = Et.return);
                              }
                              P === Et && (P = null),
                                (Et.sibling.return = Et.return),
                                (Et = Et.sibling);
                            }
                        }
                        if (rn && !mn && y.mode & 1) {
                          ct = y;
                          for (var Me = y.child; Me !== null; ) {
                            for (y = ct = Me; ct !== null; ) {
                              M = ct;
                              var me = M.child;
                              switch (M.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                  js(4, M, M.return);
                                  break;
                                case 1:
                                  Xr(M, M.return);
                                  var be = M.stateNode;
                                  if (typeof be.componentWillUnmount == 'function') {
                                    var _t = M.return;
                                    try {
                                      (be.props = M.memoizedProps),
                                        (be.state = M.memoizedState),
                                        be.componentWillUnmount();
                                    } catch (Ot) {
                                      ir(M, _t, Ot);
                                    }
                                  }
                                  break;
                                case 5:
                                  Xr(M, M.return);
                                  break;
                                case 22:
                                  if (M.memoizedState !== null) {
                                    Cd(y);
                                    continue;
                                  }
                              }
                              me !== null ? ((me.return = M), (ct = me)) : Cd(y);
                            }
                            Me = Me.sibling;
                          }
                        }
                    }
                  switch (pe & 4102) {
                    case 2:
                      Jc(f), (f.flags &= -3);
                      break;
                    case 6:
                      Jc(f), (f.flags &= -3), Ro(f.alternate, f);
                      break;
                    case 4096:
                      f.flags &= -4097;
                      break;
                    case 4100:
                      (f.flags &= -4097), Ro(f.alternate, f);
                      break;
                    case 4:
                      Ro(f.alternate, f);
                  }
                } catch (Ot) {
                  ir(f, f.return, Ot);
                }
                if (((y = f.sibling), y !== null)) {
                  (y.return = f.return), (ct = y);
                  break;
                }
                ct = f.return;
              }
          }
        }
        function eu(c, f, y) {
          (ct = c), tu(c);
        }
        function tu(c, f, y) {
          for (var M = (c.mode & 1) !== 0; ct !== null; ) {
            var T = ct,
              P = T.child;
            if (T.tag === 22 && M) {
              var Z = T.memoizedState !== null || tr;
              if (!Z) {
                var pe = T.alternate,
                  Ne = (pe !== null && pe.memoizedState !== null) || Ti;
                pe = tr;
                var st = Ti;
                if (((tr = Z), (Ti = Ne) && !st))
                  for (ct = T; ct !== null; )
                    (Z = ct),
                      (Ne = Z.child),
                      Z.tag === 22 && Z.memoizedState !== null
                        ? ua(T)
                        : Ne !== null
                        ? ((Ne.return = Z), (ct = Ne))
                        : ua(T);
                for (; P !== null; ) (ct = P), tu(P), (P = P.sibling);
                (ct = T), (tr = pe), (Ti = st);
              }
              wd(c);
            } else T.subtreeFlags & 8772 && P !== null ? ((P.return = T), (ct = P)) : wd(c);
          }
        }
        function wd(c) {
          for (; ct !== null; ) {
            var f = ct;
            if (f.flags & 8772) {
              var y = f.alternate;
              try {
                if (f.flags & 8772)
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ti || Di(5, f);
                      break;
                    case 1:
                      var M = f.stateNode;
                      if (f.flags & 4 && !Ti)
                        if (y === null) M.componentDidMount();
                        else {
                          var T =
                            f.elementType === f.type
                              ? y.memoizedProps
                              : cr(f.type, y.memoizedProps);
                          M.componentDidUpdate(
                            T,
                            y.memoizedState,
                            M.__reactInternalSnapshotBeforeUpdate,
                          );
                        }
                      var P = f.updateQueue;
                      P !== null && np(f, P, M);
                      break;
                    case 3:
                      var Z = f.updateQueue;
                      if (Z !== null) {
                        if (((y = null), f.child !== null))
                          switch (f.child.tag) {
                            case 5:
                              y = de(f.child.stateNode);
                              break;
                            case 1:
                              y = f.child.stateNode;
                          }
                        np(f, Z, y);
                      }
                      break;
                    case 5:
                      var pe = f.stateNode;
                      y === null && f.flags & 4 && Ze(pe, f.type, f.memoizedProps, f);
                      break;
                    case 6:
                      break;
                    case 4:
                      break;
                    case 12:
                      break;
                    case 13:
                      if (ke && f.memoizedState === null) {
                        var Ne = f.alternate;
                        if (Ne !== null) {
                          var st = Ne.memoizedState;
                          if (st !== null) {
                            var bt = st.dehydrated;
                            bt !== null && Pe(bt);
                          }
                        }
                      }
                      break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                      break;
                    default:
                      throw Error(a(163));
                  }
                Ti || (f.flags & 512 && nr(f));
              } catch (rn) {
                ir(f, f.return, rn);
              }
            }
            if (f === c) {
              ct = null;
              break;
            }
            if (((y = f.sibling), y !== null)) {
              (y.return = f.return), (ct = y);
              break;
            }
            ct = f.return;
          }
        }
        function Cd(c) {
          for (; ct !== null; ) {
            var f = ct;
            if (f === c) {
              ct = null;
              break;
            }
            var y = f.sibling;
            if (y !== null) {
              (y.return = f.return), (ct = y);
              break;
            }
            ct = f.return;
          }
        }
        function ua(c) {
          for (; ct !== null; ) {
            var f = ct;
            try {
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  var y = f.return;
                  try {
                    Di(4, f);
                  } catch (Ne) {
                    ir(f, y, Ne);
                  }
                  break;
                case 1:
                  var M = f.stateNode;
                  if (typeof M.componentDidMount == 'function') {
                    var T = f.return;
                    try {
                      M.componentDidMount();
                    } catch (Ne) {
                      ir(f, T, Ne);
                    }
                  }
                  var P = f.return;
                  try {
                    nr(f);
                  } catch (Ne) {
                    ir(f, P, Ne);
                  }
                  break;
                case 5:
                  var Z = f.return;
                  try {
                    nr(f);
                  } catch (Ne) {
                    ir(f, Z, Ne);
                  }
              }
            } catch (Ne) {
              ir(f, f.return, Ne);
            }
            if (f === c) {
              ct = null;
              break;
            }
            var pe = f.sibling;
            if (pe !== null) {
              (pe.return = f.return), (ct = pe);
              break;
            }
            ct = f.return;
          }
        }
        var nu = 0,
          ca = 1,
          fa = 2,
          Zs = 3,
          el = 4;
        if (typeof Symbol == 'function' && Symbol.for) {
          var da = Symbol.for;
          (nu = da('selector.component')),
            (ca = da('selector.has_pseudo_class')),
            (fa = da('selector.role')),
            (Zs = da('selector.test_id')),
            (el = da('selector.text'));
        }
        function iu(c) {
          var f = j(c);
          if (f != null) {
            if (typeof f.memoizedProps['data-testname'] != 'string') throw Error(a(364));
            return f;
          }
          if (((c = K(c)), c === null)) throw Error(a(362));
          return c.stateNode.current;
        }
        function ru(c, f) {
          switch (f.$$typeof) {
            case nu:
              if (c.type === f.value) return !0;
              break;
            case ca:
              e: {
                (f = f.value), (c = [c, 0]);
                for (var y = 0; y < c.length; ) {
                  var M = c[y++],
                    T = c[y++],
                    P = f[T];
                  if (M.tag !== 5 || !Le(M)) {
                    for (; P != null && ru(M, P); ) T++, (P = f[T]);
                    if (T === f.length) {
                      f = !0;
                      break e;
                    } else for (M = M.child; M !== null; ) c.push(M, T), (M = M.sibling);
                  }
                }
                f = !1;
              }
              return f;
            case fa:
              if (c.tag === 5 && We(c.stateNode, f.value)) return !0;
              break;
            case el:
              if (
                (c.tag === 5 || c.tag === 6) &&
                ((c = ve(c)), c !== null && 0 <= c.indexOf(f.value))
              )
                return !0;
              break;
            case Zs:
              if (
                c.tag === 5 &&
                ((c = c.memoizedProps['data-testname']),
                typeof c == 'string' && c.toLowerCase() === f.value.toLowerCase())
              )
                return !0;
              break;
            default:
              throw Error(a(365));
          }
          return !1;
        }
        function bo(c) {
          switch (c.$$typeof) {
            case nu:
              return '<' + (G(c.value) || 'Unknown') + '>';
            case ca:
              return ':has(' + (bo(c) || '') + ')';
            case fa:
              return '[role="' + c.value + '"]';
            case el:
              return '"' + c.value + '"';
            case Zs:
              return '[data-testname="' + c.value + '"]';
            default:
              throw Error(a(365));
          }
        }
        function br(c, f) {
          var y = [];
          c = [c, 0];
          for (var M = 0; M < c.length; ) {
            var T = c[M++],
              P = c[M++],
              Z = f[P];
            if (T.tag !== 5 || !Le(T)) {
              for (; Z != null && ru(T, Z); ) P++, (Z = f[P]);
              if (P === f.length) y.push(T);
              else for (T = T.child; T !== null; ) c.push(T, P), (T = T.sibling);
            }
          }
          return y;
        }
        function Qs(c, f) {
          if (!lt) throw Error(a(363));
          (c = iu(c)), (c = br(c, f)), (f = []), (c = Array.from(c));
          for (var y = 0; y < c.length; ) {
            var M = c[y++];
            if (M.tag === 5) Le(M) || f.push(M.stateNode);
            else for (M = M.child; M !== null; ) c.push(M), (M = M.sibling);
          }
          return f;
        }
        var Td = Math.ceil,
          su = u.ReactCurrentDispatcher,
          us = u.ReactCurrentOwner,
          Un = u.ReactCurrentBatchConfig,
          fn = 0,
          ui = null,
          On = null,
          Zn = 0,
          Gi = 0,
          ha = ut(0),
          ri = 0,
          tl = null,
          ws = 0,
          Ir = 0,
          pa = 0,
          qs = null,
          di = null,
          ou = 0,
          Io = 1 / 0;
        function ma() {
          Io = vi() + 500;
        }
        var nl = !1,
          Yn = null,
          cs = null,
          il = !1,
          Cs = null,
          ga = 0,
          va = 0,
          $s = null,
          Xn = -1,
          si = 0;
        function Tn() {
          return fn & 6 ? vi() : Xn !== -1 ? Xn : (Xn = vi());
        }
        function fs(c) {
          return c.mode & 1
            ? fn & 2 && Zn !== 0
              ? Zn & -Zn
              : tp.transition !== null
              ? (si === 0 && ((c = ai), (ai <<= 1), !(ai & 4194240) && (ai = 64), (si = c)), si)
              : ((c = vn), c !== 0 ? c : qe())
            : 1;
        }
        function Vi(c, f, y) {
          if (50 < va) throw ((va = 0), ($s = null), Error(a(185)));
          var M = Bo(c, f);
          return M === null
            ? null
            : (Vo(M, f, y),
              (!(fn & 2) || M !== ui) &&
                (M === ui && (!(fn & 2) && (Ir |= f), ri === 4 && Fi(M, Zn)),
                pr(M, y),
                f === 1 && fn === 0 && !(c.mode & 1) && (ma(), pc && zr())),
              M);
        }
        function Bo(c, f) {
          c.lanes |= f;
          var y = c.alternate;
          for (y !== null && (y.lanes |= f), y = c, c = c.return; c !== null; )
            (c.childLanes |= f),
              (y = c.alternate),
              y !== null && (y.childLanes |= f),
              (y = c),
              (c = c.return);
          return y.tag === 3 ? y.stateNode : null;
        }
        function pr(c, f) {
          var y = c.callbackNode;
          ep(c, f);
          var M = Ll(c, c === ui ? Zn : 0);
          if (M === 0) y !== null && Na(y), (c.callbackNode = null), (c.callbackPriority = 0);
          else if (((f = M & -M), c.callbackPriority !== f)) {
            if ((y != null && Na(y), f === 1))
              c.tag === 0 ? gc(Br.bind(null, c)) : mc(Br.bind(null, c)),
                rt
                  ? Ht(function () {
                      fn === 0 && zr();
                    })
                  : Wo(Xo, zr),
                (y = null);
            else {
              switch (Us(M)) {
                case 1:
                  y = Xo;
                  break;
                case 4:
                  y = vv;
                  break;
                case 16:
                  y = dc;
                  break;
                case 536870912:
                  y = hc;
                  break;
                default:
                  y = dc;
              }
              y = jc(y, Li.bind(null, c));
            }
            (c.callbackPriority = f), (c.callbackNode = y);
          }
        }
        function Li(c, f) {
          if (((Xn = -1), (si = 0), fn & 6)) throw Error(a(327));
          var y = c.callbackNode;
          if (Ts() && c.callbackNode !== y) return null;
          var M = Ll(c, c === ui ? Zn : 0);
          if (M === 0) return null;
          if (M & 30 || M & c.expiredLanes || f) f = cu(c, M);
          else {
            f = M;
            var T = fn;
            fn |= 2;
            var P = Id();
            (ui !== c || Zn !== f) && (ma(), eo(c, f));
            do
              try {
                vp();
                break;
              } catch (pe) {
                bd(c, pe);
              }
            while (!0);
            qi(),
              (su.current = P),
              (fn = T),
              On !== null ? (f = 0) : ((ui = null), (Zn = 0), (f = ri));
          }
          if (f !== 0) {
            if ((f === 2 && ((T = uc(c)), T !== 0 && ((M = T), (f = au(c, T)))), f === 1))
              throw ((y = tl), eo(c, 0), Fi(c, M), pr(c, vi()), y);
            if (f === 6) Fi(c, M);
            else {
              if (
                ((T = c.current.alternate),
                !(M & 30) &&
                  !Rd(T) &&
                  ((f = cu(c, M)),
                  f === 2 && ((P = uc(c)), P !== 0 && ((M = P), (f = au(c, P)))),
                  f === 1))
              )
                throw ((y = tl), eo(c, 0), Fi(c, M), pr(c, vi()), y);
              switch (((c.finishedWork = T), (c.finishedLanes = M), f)) {
                case 0:
                case 1:
                  throw Error(a(345));
                case 2:
                  ds(c, di);
                  break;
                case 3:
                  if ((Fi(c, M), (M & 130023424) === M && ((f = ou + 500 - vi()), 10 < f))) {
                    if (Ll(c, 0) !== 0) break;
                    if (((T = c.suspendedLanes), (T & M) !== M)) {
                      Tn(), (c.pingedLanes |= c.suspendedLanes & T);
                      break;
                    }
                    c.timeoutHandle = Ue(ds.bind(null, c, di), f);
                    break;
                  }
                  ds(c, di);
                  break;
                case 4:
                  if ((Fi(c, M), (M & 4194240) === M)) break;
                  for (f = c.eventTimes, T = -1; 0 < M; ) {
                    var Z = 31 - Yt(M);
                    (P = 1 << Z), (Z = f[Z]), Z > T && (T = Z), (M &= ~P);
                  }
                  if (
                    ((M = T),
                    (M = vi() - M),
                    (M =
                      (120 > M
                        ? 120
                        : 480 > M
                        ? 480
                        : 1080 > M
                        ? 1080
                        : 1920 > M
                        ? 1920
                        : 3e3 > M
                        ? 3e3
                        : 4320 > M
                        ? 4320
                        : 1960 * Td(M / 1960)) - M),
                    10 < M)
                  ) {
                    c.timeoutHandle = Ue(ds.bind(null, c, di), M);
                    break;
                  }
                  ds(c, di);
                  break;
                case 5:
                  ds(c, di);
                  break;
                default:
                  throw Error(a(329));
              }
            }
          }
          return pr(c, vi()), c.callbackNode === y ? Li.bind(null, c) : null;
        }
        function au(c, f) {
          var y = qs;
          return (
            c.current.memoizedState.isDehydrated && (eo(c, f).flags |= 256),
            (c = cu(c, f)),
            c !== 2 && ((f = di), (di = y), f !== null && lu(f)),
            c
          );
        }
        function lu(c) {
          di === null ? (di = c) : di.push.apply(di, c);
        }
        function Rd(c) {
          for (var f = c; ; ) {
            if (f.flags & 16384) {
              var y = f.updateQueue;
              if (y !== null && ((y = y.stores), y !== null))
                for (var M = 0; M < y.length; M++) {
                  var T = y[M],
                    P = T.getSnapshot;
                  T = T.value;
                  try {
                    if (!Qi(P(), T)) return !1;
                  } catch {
                    return !1;
                  }
                }
            }
            if (((y = f.child), f.subtreeFlags & 16384 && y !== null)) (y.return = f), (f = y);
            else {
              if (f === c) break;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === c) return !0;
                f = f.return;
              }
              (f.sibling.return = f.return), (f = f.sibling);
            }
          }
          return !0;
        }
        function Fi(c, f) {
          for (
            f &= ~pa, f &= ~Ir, c.suspendedLanes |= f, c.pingedLanes &= ~f, c = c.expirationTimes;
            0 < f;

          ) {
            var y = 31 - Yt(f),
              M = 1 << y;
            (c[y] = -1), (f &= ~M);
          }
        }
        function Br(c) {
          if (fn & 6) throw Error(a(327));
          Ts();
          var f = Ll(c, 0);
          if (!(f & 1)) return pr(c, vi()), null;
          var y = cu(c, f);
          if (c.tag !== 0 && y === 2) {
            var M = uc(c);
            M !== 0 && ((f = M), (y = au(c, M)));
          }
          if (y === 1) throw ((y = tl), eo(c, 0), Fi(c, f), pr(c, vi()), y);
          if (y === 6) throw Error(a(345));
          return (
            (c.finishedWork = c.current.alternate),
            (c.finishedLanes = f),
            ds(c, di),
            pr(c, vi()),
            null
          );
        }
        function rl(c) {
          Cs !== null && Cs.tag === 0 && !(fn & 6) && Ts();
          var f = fn;
          fn |= 1;
          var y = Un.transition,
            M = vn;
          try {
            if (((Un.transition = null), (vn = 1), c)) return c();
          } finally {
            (vn = M), (Un.transition = y), (fn = f), !(fn & 6) && zr();
          }
        }
        function uu() {
          (Gi = ha.current), Xe(ha);
        }
        function eo(c, f) {
          (c.finishedWork = null), (c.finishedLanes = 0);
          var y = c.timeoutHandle;
          if ((y !== Bt && ((c.timeoutHandle = Bt), et(y)), On !== null))
            for (y = On.return; y !== null; ) {
              var M = y;
              switch ((id(M), M.tag)) {
                case 1:
                  (M = M.type.childContextTypes), M != null && Wt();
                  break;
                case 3:
                  Xa(), Xe(Dt), Xe(qt), $o();
                  break;
                case 5:
                  od(M);
                  break;
                case 4:
                  Xa();
                  break;
                case 13:
                  Xe($n);
                  break;
                case 19:
                  Xe($n);
                  break;
                case 10:
                  kl(M.type._context);
                  break;
                case 22:
                case 23:
                  uu();
              }
              y = y.return;
            }
          if (
            ((ui = c),
            (On = c = to(c.current, null)),
            (Zn = Gi = f),
            (ri = 0),
            (tl = null),
            (pa = Ir = ws = 0),
            (di = qs = null),
            Hr !== null)
          ) {
            for (f = 0; f < Hr.length; f++)
              if (((y = Hr[f]), (M = y.interleaved), M !== null)) {
                y.interleaved = null;
                var T = M.next,
                  P = y.pending;
                if (P !== null) {
                  var Z = P.next;
                  (P.next = T), (M.next = Z);
                }
                y.pending = M;
              }
            Hr = null;
          }
          return c;
        }
        function bd(c, f) {
          do {
            var y = On;
            try {
              if ((qi(), (Hl.current = Za), Rc)) {
                for (var M = ei.memoizedState; M !== null; ) {
                  var T = M.queue;
                  T !== null && (T.pending = null), (M = M.next);
                }
                Rc = !1;
              }
              if (
                ((ea = 0),
                (Ei = Mi = ei = null),
                (Ss = !1),
                (ta = 0),
                (us.current = null),
                y === null || y.return === null)
              ) {
                (ri = 1), (tl = f), (On = null);
                break;
              }
              e: {
                var P = c,
                  Z = y.return,
                  pe = y,
                  Ne = f;
                if (
                  ((f = Zn),
                  (pe.flags |= 32768),
                  Ne !== null && typeof Ne == 'object' && typeof Ne.then == 'function')
                ) {
                  var st = Ne,
                    bt = pe,
                    rn = bt.tag;
                  if (!(bt.mode & 1) && (rn === 0 || rn === 11 || rn === 15)) {
                    var Xt = bt.alternate;
                    Xt
                      ? ((bt.updateQueue = Xt.updateQueue),
                        (bt.memoizedState = Xt.memoizedState),
                        (bt.lanes = Xt.lanes))
                      : ((bt.updateQueue = null), (bt.memoizedState = null));
                  }
                  var mn = gd(Z);
                  if (mn !== null) {
                    (mn.flags &= -257),
                      ia(mn, Z, pe, P, f),
                      mn.mode & 1 && Ws(P, st, f),
                      (f = mn),
                      (Ne = st);
                    var Et = f.updateQueue;
                    if (Et === null) {
                      var Ni = new Set();
                      Ni.add(Ne), (f.updateQueue = Ni);
                    } else Et.add(Ne);
                    break e;
                  } else {
                    if (!(f & 1)) {
                      Ws(P, st, f), Kc();
                      break e;
                    }
                    Ne = Error(a(426));
                  }
                } else if (jn && pe.mode & 1) {
                  var Dr = gd(Z);
                  if (Dr !== null) {
                    !(Dr.flags & 65536) && (Dr.flags |= 256), ia(Dr, Z, pe, P, f), wc(Ne);
                    break e;
                  }
                }
                (P = Ne),
                  ri !== 4 && (ri = 2),
                  qs === null ? (qs = [P]) : qs.push(P),
                  (Ne = md(Ne, pe)),
                  (pe = Z);
                do {
                  switch (pe.tag) {
                    case 3:
                      (pe.flags |= 65536), (f &= -f), (pe.lanes |= f);
                      var Me = pp(pe, Ne, f);
                      _c(pe, Me);
                      break e;
                    case 1:
                      P = Ne;
                      var me = pe.type,
                        be = pe.stateNode;
                      if (
                        !(pe.flags & 128) &&
                        (typeof me.getDerivedStateFromError == 'function' ||
                          (be !== null &&
                            typeof be.componentDidCatch == 'function' &&
                            (cs === null || !cs.has(be))))
                      ) {
                        (pe.flags |= 65536), (f &= -f), (pe.lanes |= f);
                        var _t = Oc(pe, P, f);
                        _c(pe, _t);
                        break e;
                      }
                  }
                  pe = pe.return;
                } while (pe !== null);
              }
              Pd(y);
            } catch (Ot) {
              (f = Ot), On === y && y !== null && (On = y = y.return);
              continue;
            }
            break;
          } while (!0);
        }
        function Id() {
          var c = su.current;
          return (su.current = Za), c === null ? Za : c;
        }
        function Kc() {
          (ri === 0 || ri === 3 || ri === 2) && (ri = 4),
            ui === null || (!(ws & 268435455) && !(Ir & 268435455)) || Fi(ui, Zn);
        }
        function cu(c, f) {
          var y = fn;
          fn |= 2;
          var M = Id();
          (ui === c && Zn === f) || eo(c, f);
          do
            try {
              gp();
              break;
            } catch (T) {
              bd(c, T);
            }
          while (!0);
          if ((qi(), (fn = y), (su.current = M), On !== null)) throw Error(a(261));
          return (ui = null), (Zn = 0), ri;
        }
        function gp() {
          for (; On !== null; ) Bd(On);
        }
        function vp() {
          for (; On !== null && !xo(); ) Bd(On);
        }
        function Bd(c) {
          var f = Fd(c.alternate, c, Gi);
          (c.memoizedProps = c.pendingProps), f === null ? Pd(c) : (On = f), (us.current = null);
        }
        function Pd(c) {
          var f = c;
          do {
            var y = f.alternate;
            if (((c = f.return), f.flags & 32768)) {
              if (((y = Wc(y, f)), y !== null)) {
                (y.flags &= 32767), (On = y);
                return;
              }
              if (c !== null) (c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null);
              else {
                (ri = 6), (On = null);
                return;
              }
            } else if (((y = Hc(y, f, Gi)), y !== null)) {
              On = y;
              return;
            }
            if (((f = f.sibling), f !== null)) {
              On = f;
              return;
            }
            On = f = c;
          } while (f !== null);
          ri === 0 && (ri = 5);
        }
        function ds(c, f) {
          var y = vn,
            M = Un.transition;
          try {
            (Un.transition = null), (vn = 1), yp(c, f, y);
          } finally {
            (Un.transition = M), (vn = y);
          }
          return null;
        }
        function yp(c, f, y) {
          do Ts();
          while (Cs !== null);
          if (fn & 6) throw Error(a(327));
          var M = c.finishedWork,
            T = c.finishedLanes;
          if (M === null) return null;
          if (((c.finishedWork = null), (c.finishedLanes = 0), M === c.current))
            throw Error(a(177));
          (c.callbackNode = null), (c.callbackPriority = 0);
          var P = M.lanes | M.childLanes;
          if (
            (fc(c, P),
            c === ui && ((On = ui = null), (Zn = 0)),
            (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
              il ||
              ((il = !0),
              jc(dc, function () {
                return Ts(), null;
              })),
            (P = (M.flags & 15990) !== 0),
            M.subtreeFlags & 15990 || P)
          ) {
            (P = Un.transition), (Un.transition = null);
            var Z = vn;
            vn = 1;
            var pe = fn;
            (fn |= 4),
              (us.current = null),
              Ad(c, M),
              xv(c, M),
              te(c.containerInfo),
              (c.current = M),
              eu(M),
              gv(),
              (fn = pe),
              (vn = Z),
              (Un.transition = P);
          } else c.current = M;
          if (
            (il && ((il = !1), (Cs = c), (ga = T)),
            (P = c.pendingLanes),
            P === 0 && (cs = null),
            Nl(M.stateNode),
            pr(c, vi()),
            f !== null)
          )
            for (y = c.onRecoverableError, M = 0; M < f.length; M++) y(f[M]);
          if (nl) throw ((nl = !1), (c = Yn), (Yn = null), c);
          return (
            ga & 1 && c.tag !== 0 && Ts(),
            (P = c.pendingLanes),
            P & 1 ? (c === $s ? va++ : ((va = 0), ($s = c))) : (va = 0),
            zr(),
            null
          );
        }
        function Ts() {
          if (Cs !== null) {
            var c = Us(ga),
              f = Un.transition,
              y = vn;
            try {
              if (((Un.transition = null), (vn = 16 > c ? 16 : c), Cs === null)) var M = !1;
              else {
                if (((c = Cs), (Cs = null), (ga = 0), fn & 6)) throw Error(a(331));
                var T = fn;
                for (fn |= 4, ct = c.current; ct !== null; ) {
                  var P = ct,
                    Z = P.child;
                  if (ct.flags & 16) {
                    var pe = P.deletions;
                    if (pe !== null) {
                      for (var Ne = 0; Ne < pe.length; Ne++) {
                        var st = pe[Ne];
                        for (ct = st; ct !== null; ) {
                          var bt = ct;
                          switch (bt.tag) {
                            case 0:
                            case 11:
                            case 15:
                              js(8, bt, P);
                          }
                          var rn = bt.child;
                          if (rn !== null) (rn.return = bt), (ct = rn);
                          else
                            for (; ct !== null; ) {
                              bt = ct;
                              var Xt = bt.sibling,
                                mn = bt.return;
                              if ((Sd(bt), bt === st)) {
                                ct = null;
                                break;
                              }
                              if (Xt !== null) {
                                (Xt.return = mn), (ct = Xt);
                                break;
                              }
                              ct = mn;
                            }
                        }
                      }
                      var Et = P.alternate;
                      if (Et !== null) {
                        var Ni = Et.child;
                        if (Ni !== null) {
                          Et.child = null;
                          do {
                            var Dr = Ni.sibling;
                            (Ni.sibling = null), (Ni = Dr);
                          } while (Ni !== null);
                        }
                      }
                      ct = P;
                    }
                  }
                  if (P.subtreeFlags & 2064 && Z !== null) (Z.return = P), (ct = Z);
                  else
                    e: for (; ct !== null; ) {
                      if (((P = ct), P.flags & 2048))
                        switch (P.tag) {
                          case 0:
                          case 11:
                          case 15:
                            js(9, P, P.return);
                        }
                      var Me = P.sibling;
                      if (Me !== null) {
                        (Me.return = P.return), (ct = Me);
                        break e;
                      }
                      ct = P.return;
                    }
                }
                var me = c.current;
                for (ct = me; ct !== null; ) {
                  Z = ct;
                  var be = Z.child;
                  if (Z.subtreeFlags & 2064 && be !== null) (be.return = Z), (ct = be);
                  else
                    e: for (Z = me; ct !== null; ) {
                      if (((pe = ct), pe.flags & 2048))
                        try {
                          switch (pe.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Di(9, pe);
                          }
                        } catch (Ot) {
                          ir(pe, pe.return, Ot);
                        }
                      if (pe === Z) {
                        ct = null;
                        break e;
                      }
                      var _t = pe.sibling;
                      if (_t !== null) {
                        (_t.return = pe.return), (ct = _t);
                        break e;
                      }
                      ct = pe.return;
                    }
                }
                if (((fn = T), zr(), As && typeof As.onPostCommitFiberRoot == 'function'))
                  try {
                    As.onPostCommitFiberRoot(Fl, c);
                  } catch {}
                M = !0;
              }
              return M;
            } finally {
              (vn = y), (Un.transition = f);
            }
          }
          return !1;
        }
        function fu(c, f, y) {
          (f = md(y, f)),
            (f = pp(c, f, 1)),
            Ao(c, f),
            (f = Tn()),
            (c = Bo(c, 1)),
            c !== null && (Vo(c, 1, f), pr(c, f));
        }
        function ir(c, f, y) {
          if (c.tag === 3) fu(c, c, y);
          else
            for (; f !== null; ) {
              if (f.tag === 3) {
                fu(f, c, y);
                break;
              } else if (f.tag === 1) {
                var M = f.stateNode;
                if (
                  typeof f.type.getDerivedStateFromError == 'function' ||
                  (typeof M.componentDidCatch == 'function' && (cs === null || !cs.has(M)))
                ) {
                  (c = md(y, c)),
                    (c = Oc(f, c, 1)),
                    Ao(f, c),
                    (c = Tn()),
                    (f = Bo(f, 1)),
                    f !== null && (Vo(f, 1, c), pr(f, c));
                  break;
                }
              }
              f = f.return;
            }
        }
        function Dd(c, f, y) {
          var M = c.pingCache;
          M !== null && M.delete(f),
            (f = Tn()),
            (c.pingedLanes |= c.suspendedLanes & y),
            ui === c &&
              (Zn & y) === y &&
              (ri === 4 || (ri === 3 && (Zn & 130023424) === Zn && 500 > vi() - ou)
                ? eo(c, 0)
                : (pa |= y)),
            pr(c, f);
        }
        function Ld(c, f) {
          f === 0 &&
            (c.mode & 1 ? ((f = xn), (xn <<= 1), !(xn & 130023424) && (xn = 4194304)) : (f = 1));
          var y = Tn();
          (c = Bo(c, f)), c !== null && (Vo(c, f, y), pr(c, y));
        }
        function _p(c) {
          var f = c.memoizedState,
            y = 0;
          f !== null && (y = f.retryLane), Ld(c, y);
        }
        function xp(c, f) {
          var y = 0;
          switch (c.tag) {
            case 13:
              var M = c.stateNode,
                T = c.memoizedState;
              T !== null && (y = T.retryLane);
              break;
            case 19:
              M = c.stateNode;
              break;
            default:
              throw Error(a(314));
          }
          M !== null && M.delete(f), Ld(c, y);
        }
        var Fd;
        Fd = function (c, f, y) {
          if (c !== null)
            if (c.memoizedProps !== f.pendingProps || Dt.current) Ci = !0;
            else {
              if (!(c.lanes & y) && !(f.flags & 128)) return (Ci = !1), Vc(c, f, y);
              Ci = !!(c.flags & 131072);
            }
          else (Ci = !1), jn && f.flags & 1048576 && op(f, Mc, f.index);
          switch (((f.lanes = 0), f.tag)) {
            case 2:
              var M = f.type;
              c !== null && ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
                (c = f.pendingProps);
              var T = Mt(f, qt.current);
              Ua(f, y), (T = Ja(null, f, M, c, T, y));
              var P = wo();
              return (
                (f.flags |= 1),
                typeof T == 'object' &&
                T !== null &&
                typeof T.render == 'function' &&
                T.$$typeof === void 0
                  ? ((f.tag = 1),
                    (f.memoizedState = null),
                    (f.updateQueue = null),
                    cn(M) ? ((P = !0), on(f)) : (P = !1),
                    (f.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null),
                    Oa(f),
                    (T.updater = Ac),
                    (f.stateNode = T),
                    (T._reactInternals = f),
                    td(f, M, c, y),
                    (f = Hi(null, f, M, !0, P, y)))
                  : ((f.tag = 0), jn && P && nd(f), ii(null, f, T, y), (f = f.child)),
                f
              );
            case 16:
              M = f.elementType;
              e: {
                switch (
                  (c !== null && ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
                  (c = f.pendingProps),
                  (T = M._init),
                  (M = T(M._payload)),
                  (f.type = M),
                  (T = f.tag = Av(M)),
                  (c = cr(M, c)),
                  T)
                ) {
                  case 0:
                    f = Ys(null, f, M, c, y);
                    break e;
                  case 1:
                    f = sa(null, f, M, c, y);
                    break e;
                  case 11:
                    f = Wn(null, f, M, c, y);
                    break e;
                  case 14:
                    f = kn(null, f, M, cr(M.type, c), y);
                    break e;
                }
                throw Error(a(306, M, ''));
              }
              return f;
            case 0:
              return (
                (M = f.type),
                (T = f.pendingProps),
                (T = f.elementType === M ? T : cr(M, T)),
                Ys(c, f, M, T, y)
              );
            case 1:
              return (
                (M = f.type),
                (T = f.pendingProps),
                (T = f.elementType === M ? T : cr(M, T)),
                sa(c, f, M, T, y)
              );
            case 3:
              e: {
                if ((Zl(f), c === null)) throw Error(a(387));
                (M = f.pendingProps),
                  (P = f.memoizedState),
                  (T = P.element),
                  qf(c, f),
                  xc(f, M, null, y);
                var Z = f.memoizedState;
                if (((M = Z.element), ke && P.isDehydrated))
                  if (
                    ((P = {
                      element: M,
                      isDehydrated: !1,
                      cache: Z.cache,
                      transitions: Z.transitions,
                    }),
                    (f.updateQueue.baseState = P),
                    (f.memoizedState = P),
                    f.flags & 256)
                  ) {
                    (T = Error(a(423))), (f = yd(c, f, M, y, T));
                    break e;
                  } else if (M !== T) {
                    (T = Error(a(424))), (f = yd(c, f, M, y, T));
                    break e;
                  } else
                    for (
                      ke &&
                        ((Bi = Go(f.stateNode.containerInfo)),
                        ($i = f),
                        (jn = !0),
                        (Wr = null),
                        (za = !1)),
                        y = up(f, null, M, y),
                        f.child = y;
                      y;

                    )
                      (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
                else {
                  if ((Ha(), M === T)) {
                    f = hr(c, f, y);
                    break e;
                  }
                  ii(c, f, M, y);
                }
                f = f.child;
              }
              return f;
            case 5:
              return (
                cp(f),
                c === null && Mo(f),
                (M = f.type),
                (T = f.pendingProps),
                (P = c !== null ? c.memoizedProps : null),
                (Z = T.children),
                De(M, T) ? (Z = null) : P !== null && De(M, P) && (f.flags |= 32),
                er(c, f),
                ii(c, f, Z, y),
                f.child
              );
            case 6:
              return c === null && Mo(f), null;
            case 13:
              return _d(c, f, y);
            case 4:
              return (
                Cc(f, f.stateNode.containerInfo),
                (M = f.pendingProps),
                c === null ? (f.child = Gs(f, null, M, y)) : ii(c, f, M, y),
                f.child
              );
            case 11:
              return (
                (M = f.type),
                (T = f.pendingProps),
                (T = f.elementType === M ? T : cr(M, T)),
                Wn(c, f, M, T, y)
              );
            case 7:
              return ii(c, f, f.pendingProps, y), f.child;
            case 8:
              return ii(c, f, f.pendingProps.children, y), f.child;
            case 12:
              return ii(c, f, f.pendingProps.children, y), f.child;
            case 10:
              e: {
                if (
                  ((M = f.type._context),
                  (T = f.pendingProps),
                  (P = f.memoizedProps),
                  (Z = T.value),
                  Yo(f, M, Z),
                  P !== null)
                )
                  if (Qi(P.value, Z)) {
                    if (P.children === T.children && !Dt.current) {
                      f = hr(c, f, y);
                      break e;
                    }
                  } else
                    for (P = f.child, P !== null && (P.return = f); P !== null; ) {
                      var pe = P.dependencies;
                      if (pe !== null) {
                        Z = P.child;
                        for (var Ne = pe.firstContext; Ne !== null; ) {
                          if (Ne.context === M) {
                            if (P.tag === 1) {
                              (Ne = ks(-1, y & -y)), (Ne.tag = 2);
                              var st = P.updateQueue;
                              if (st !== null) {
                                st = st.shared;
                                var bt = st.pending;
                                bt === null
                                  ? (Ne.next = Ne)
                                  : ((Ne.next = bt.next), (bt.next = Ne)),
                                  (st.pending = Ne);
                              }
                            }
                            (P.lanes |= y),
                              (Ne = P.alternate),
                              Ne !== null && (Ne.lanes |= y),
                              Ko(P.return, y, f),
                              (pe.lanes |= y);
                            break;
                          }
                          Ne = Ne.next;
                        }
                      } else if (P.tag === 10) Z = P.type === f.type ? null : P.child;
                      else if (P.tag === 18) {
                        if (((Z = P.return), Z === null)) throw Error(a(341));
                        (Z.lanes |= y),
                          (pe = Z.alternate),
                          pe !== null && (pe.lanes |= y),
                          Ko(Z, y, f),
                          (Z = P.sibling);
                      } else Z = P.child;
                      if (Z !== null) Z.return = P;
                      else
                        for (Z = P; Z !== null; ) {
                          if (Z === f) {
                            Z = null;
                            break;
                          }
                          if (((P = Z.sibling), P !== null)) {
                            (P.return = Z.return), (Z = P);
                            break;
                          }
                          Z = Z.return;
                        }
                      P = Z;
                    }
                ii(c, f, T.children, y), (f = f.child);
              }
              return f;
            case 9:
              return (
                (T = f.type),
                (M = f.pendingProps.children),
                Ua(f, y),
                (T = fr(T)),
                (M = M(T)),
                (f.flags |= 1),
                ii(c, f, M, y),
                f.child
              );
            case 14:
              return (
                (M = f.type), (T = cr(M, f.pendingProps)), (T = cr(M.type, T)), kn(c, f, M, T, y)
              );
            case 15:
              return Js(c, f, f.type, f.pendingProps, y);
            case 17:
              return (
                (M = f.type),
                (T = f.pendingProps),
                (T = f.elementType === M ? T : cr(M, T)),
                c !== null && ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
                (f.tag = 1),
                cn(M) ? ((c = !0), on(f)) : (c = !1),
                Ua(f, y),
                rp(f, M, T),
                td(f, M, T, y),
                Hi(null, f, M, !0, c, y)
              );
            case 19:
              return aa(c, f, y);
            case 22:
              return Pi(c, f, y);
          }
          throw Error(a(156, f.tag));
        };
        function jc(c, f) {
          return Wo(c, f);
        }
        function Ap(c, f, y, M) {
          (this.tag = c),
            (this.key = y),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = f),
            (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
            (this.mode = M),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function Pr(c, f, y, M) {
          return new Ap(c, f, y, M);
        }
        function Zc(c) {
          return (c = c.prototype), !(!c || !c.isReactComponent);
        }
        function Av(c) {
          if (typeof c == 'function') return Zc(c) ? 1 : 0;
          if (c != null) {
            if (((c = c.$$typeof), c === C)) return 11;
            if (c === b) return 14;
          }
          return 2;
        }
        function to(c, f) {
          var y = c.alternate;
          return (
            y === null
              ? ((y = Pr(c.tag, f, c.key, c.mode)),
                (y.elementType = c.elementType),
                (y.type = c.type),
                (y.stateNode = c.stateNode),
                (y.alternate = c),
                (c.alternate = y))
              : ((y.pendingProps = f),
                (y.type = c.type),
                (y.flags = 0),
                (y.subtreeFlags = 0),
                (y.deletions = null)),
            (y.flags = c.flags & 14680064),
            (y.childLanes = c.childLanes),
            (y.lanes = c.lanes),
            (y.child = c.child),
            (y.memoizedProps = c.memoizedProps),
            (y.memoizedState = c.memoizedState),
            (y.updateQueue = c.updateQueue),
            (f = c.dependencies),
            (y.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
            (y.sibling = c.sibling),
            (y.index = c.index),
            (y.ref = c.ref),
            y
          );
        }
        function Qc(c, f, y, M, T, P) {
          var Z = 2;
          if (((M = c), typeof c == 'function')) Zc(c) && (Z = 1);
          else if (typeof c == 'string') Z = 5;
          else
            e: switch (c) {
              case m:
                return ya(y.children, T, P, f);
              case g:
                (Z = 8), (T |= 8);
                break;
              case v:
                return (c = Pr(12, y, f, T | 2)), (c.elementType = v), (c.lanes = P), c;
              case E:
                return (c = Pr(13, y, f, T)), (c.elementType = E), (c.lanes = P), c;
              case S:
                return (c = Pr(19, y, f, T)), (c.elementType = S), (c.lanes = P), c;
              case B:
                return du(y, T, P, f);
              default:
                if (typeof c == 'object' && c !== null)
                  switch (c.$$typeof) {
                    case x:
                      Z = 10;
                      break e;
                    case A:
                      Z = 9;
                      break e;
                    case C:
                      Z = 11;
                      break e;
                    case b:
                      Z = 14;
                      break e;
                    case I:
                      (Z = 16), (M = null);
                      break e;
                  }
                throw Error(a(130, c == null ? c : typeof c, ''));
            }
          return (f = Pr(Z, y, f, T)), (f.elementType = c), (f.type = M), (f.lanes = P), f;
        }
        function ya(c, f, y, M) {
          return (c = Pr(7, c, M, f)), (c.lanes = y), c;
        }
        function du(c, f, y, M) {
          return (c = Pr(22, c, M, f)), (c.elementType = B), (c.lanes = y), (c.stateNode = {}), c;
        }
        function qc(c, f, y) {
          return (c = Pr(6, c, null, f)), (c.lanes = y), c;
        }
        function $c(c, f, y) {
          return (
            (f = Pr(4, c.children !== null ? c.children : [], c.key, f)),
            (f.lanes = y),
            (f.stateNode = {
              containerInfo: c.containerInfo,
              pendingChildren: null,
              implementation: c.implementation,
            }),
            f
          );
        }
        function ef(c, f, y, M, T) {
          (this.tag = f),
            (this.containerInfo = c),
            (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
            (this.timeoutHandle = Bt),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = cc(0)),
            (this.expirationTimes = cc(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = cc(0)),
            (this.identifierPrefix = M),
            (this.onRecoverableError = T),
            ke && (this.mutableSourceEagerHydrationData = null);
        }
        function Sp(c, f, y, M, T, P, Z, pe, Ne) {
          return (
            (c = new ef(c, f, y, pe, Ne)),
            f === 1 ? ((f = 1), P === !0 && (f |= 8)) : (f = 0),
            (P = Pr(3, null, null, f)),
            (c.current = P),
            (P.stateNode = c),
            (P.memoizedState = { element: M, isDehydrated: y, cache: null, transitions: null }),
            Oa(P),
            c
          );
        }
        function Mp(c) {
          if (!c) return gt;
          c = c._reactInternals;
          e: {
            if (L(c) !== c || c.tag !== 1) throw Error(a(170));
            var f = c;
            do {
              switch (f.tag) {
                case 3:
                  f = f.stateNode.context;
                  break e;
                case 1:
                  if (cn(f.type)) {
                    f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              f = f.return;
            } while (f !== null);
            throw Error(a(171));
          }
          if (c.tag === 1) {
            var y = c.type;
            if (cn(y)) return Hn(c, y, f);
          }
          return f;
        }
        function Ep(c) {
          var f = c._reactInternals;
          if (f === void 0)
            throw typeof c.render == 'function'
              ? Error(a(188))
              : ((c = Object.keys(c).join(',')), Error(a(268, c)));
          return (c = oe(f)), c === null ? null : c.stateNode;
        }
        function Yr(c, f) {
          if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
            var y = c.retryLane;
            c.retryLane = y !== 0 && y < f ? y : f;
          }
        }
        function hu(c, f) {
          Yr(c, f), (c = c.alternate) && Yr(c, f);
        }
        function tf(c) {
          return (c = oe(c)), c === null ? null : c.stateNode;
        }
        function wp() {
          return null;
        }
        return (
          (t.attemptContinuousHydration = function (c) {
            if (c.tag === 13) {
              var f = Tn();
              Vi(c, 134217728, f), hu(c, 134217728);
            }
          }),
          (t.attemptHydrationAtCurrentPriority = function (c) {
            if (c.tag === 13) {
              var f = Tn(),
                y = fs(c);
              Vi(c, y, f), hu(c, y);
            }
          }),
          (t.attemptSynchronousHydration = function (c) {
            switch (c.tag) {
              case 3:
                var f = c.stateNode;
                if (f.current.memoizedState.isDehydrated) {
                  var y = ur(f.pendingLanes);
                  y !== 0 && (xs(f, y | 1), pr(f, vi()), !(fn & 6) && (ma(), zr()));
                }
                break;
              case 13:
                var M = Tn();
                rl(function () {
                  return Vi(c, 1, M);
                }),
                  hu(c, 1);
            }
          }),
          (t.batchedUpdates = function (c, f) {
            var y = fn;
            fn |= 1;
            try {
              return c(f);
            } finally {
              (fn = y), fn === 0 && (ma(), pc && zr());
            }
          }),
          (t.createComponentSelector = function (c) {
            return { $$typeof: nu, value: c };
          }),
          (t.createContainer = function (c, f, y, M, T, P, Z) {
            return Sp(c, f, !1, null, y, M, T, P, Z);
          }),
          (t.createHasPseudoClassSelector = function (c) {
            return { $$typeof: ca, value: c };
          }),
          (t.createHydrationContainer = function (c, f, y, M, T, P, Z, pe, Ne) {
            return (
              (c = Sp(y, M, !0, c, T, P, Z, pe, Ne)),
              (c.context = Mp(null)),
              (y = c.current),
              (M = Tn()),
              (T = fs(y)),
              (P = ks(M, T)),
              (P.callback = f ?? null),
              Ao(y, P),
              (c.current.lanes = T),
              Vo(c, T, M),
              pr(c, M),
              c
            );
          }),
          (t.createPortal = function (c, f, y) {
            var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
              $$typeof: h,
              key: M == null ? null : '' + M,
              children: c,
              containerInfo: f,
              implementation: y,
            };
          }),
          (t.createRoleSelector = function (c) {
            return { $$typeof: fa, value: c };
          }),
          (t.createTestNameSelector = function (c) {
            return { $$typeof: Zs, value: c };
          }),
          (t.createTextSelector = function (c) {
            return { $$typeof: el, value: c };
          }),
          (t.deferredUpdates = function (c) {
            var f = vn,
              y = Un.transition;
            try {
              return (Un.transition = null), (vn = 16), c();
            } finally {
              (vn = f), (Un.transition = y);
            }
          }),
          (t.discreteUpdates = function (c, f, y, M, T) {
            var P = vn,
              Z = Un.transition;
            try {
              return (Un.transition = null), (vn = 1), c(f, y, M, T);
            } finally {
              (vn = P), (Un.transition = Z), fn === 0 && ma();
            }
          }),
          (t.findAllNodes = Qs),
          (t.findBoundingRects = function (c, f) {
            if (!lt) throw Error(a(363));
            (f = Qs(c, f)), (c = []);
            for (var y = 0; y < f.length; y++) c.push(H(f[y]));
            for (f = c.length - 1; 0 < f; f--) {
              y = c[f];
              for (
                var M = y.x, T = M + y.width, P = y.y, Z = P + y.height, pe = f - 1;
                0 <= pe;
                pe--
              )
                if (f !== pe) {
                  var Ne = c[pe],
                    st = Ne.x,
                    bt = st + Ne.width,
                    rn = Ne.y,
                    Xt = rn + Ne.height;
                  if (M >= st && P >= rn && T <= bt && Z <= Xt) {
                    c.splice(f, 1);
                    break;
                  } else if (M !== st || y.width !== Ne.width || Xt < P || rn > Z) {
                    if (!(P !== rn || y.height !== Ne.height || bt < M || st > T)) {
                      st > M && ((Ne.width += st - M), (Ne.x = M)),
                        bt < T && (Ne.width = T - st),
                        c.splice(f, 1);
                      break;
                    }
                  } else {
                    rn > P && ((Ne.height += rn - P), (Ne.y = P)),
                      Xt < Z && (Ne.height = Z - rn),
                      c.splice(f, 1);
                    break;
                  }
                }
            }
            return c;
          }),
          (t.findHostInstance = Ep),
          (t.findHostInstanceWithNoPortals = function (c) {
            return (c = V(c)), (c = c !== null ? ce(c) : null), c === null ? null : c.stateNode;
          }),
          (t.findHostInstanceWithWarning = function (c) {
            return Ep(c);
          }),
          (t.flushControlled = function (c) {
            var f = fn;
            fn |= 1;
            var y = Un.transition,
              M = vn;
            try {
              (Un.transition = null), (vn = 1), c();
            } finally {
              (vn = M), (Un.transition = y), (fn = f), fn === 0 && (ma(), zr());
            }
          }),
          (t.flushPassiveEffects = Ts),
          (t.flushSync = rl),
          (t.focusWithin = function (c, f) {
            if (!lt) throw Error(a(363));
            for (c = iu(c), f = br(c, f), f = Array.from(f), c = 0; c < f.length; ) {
              var y = f[c++];
              if (!Le(y)) {
                if (y.tag === 5 && ze(y.stateNode)) return !0;
                for (y = y.child; y !== null; ) f.push(y), (y = y.sibling);
              }
            }
            return !1;
          }),
          (t.getCurrentUpdatePriority = function () {
            return vn;
          }),
          (t.getFindAllNodesFailureDescription = function (c, f) {
            if (!lt) throw Error(a(363));
            var y = 0,
              M = [];
            c = [iu(c), 0];
            for (var T = 0; T < c.length; ) {
              var P = c[T++],
                Z = c[T++],
                pe = f[Z];
              if (
                (P.tag !== 5 || !Le(P)) &&
                (ru(P, pe) && (M.push(bo(pe)), Z++, Z > y && (y = Z)), Z < f.length)
              )
                for (P = P.child; P !== null; ) c.push(P, Z), (P = P.sibling);
            }
            if (y < f.length) {
              for (c = []; y < f.length; y++) c.push(bo(f[y]));
              return (
                `findAllNodes was able to match part of the selector:
  ` +
                (M.join(' > ') +
                  `

No matching component was found for:
  `) +
                c.join(' > ')
              );
            }
            return null;
          }),
          (t.getPublicRootInstance = function (c) {
            if (((c = c.current), !c.child)) return null;
            switch (c.child.tag) {
              case 5:
                return de(c.child.stateNode);
              default:
                return c.child.stateNode;
            }
          }),
          (t.injectIntoDevTools = function (c) {
            if (
              ((c = {
                bundleType: c.bundleType,
                version: c.version,
                rendererPackageName: c.rendererPackageName,
                rendererConfig: c.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: u.ReactCurrentDispatcher,
                findHostInstanceByFiber: tf,
                findFiberByHostInstance: c.findFiberByHostInstance || wp,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: '18.0.0-fc46dba67-20220329',
              }),
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u')
            )
              c = !1;
            else {
              var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (f.isDisabled || !f.supportsFiber) c = !0;
              else {
                try {
                  (Fl = f.inject(c)), (As = f);
                } catch {}
                c = !!f.checkDCE;
              }
            }
            return c;
          }),
          (t.isAlreadyRendering = function () {
            return !1;
          }),
          (t.observeVisibleRects = function (c, f, y, M) {
            if (!lt) throw Error(a(363));
            c = Qs(c, f);
            var T = Ct(c, y, M).disconnect;
            return {
              disconnect: function () {
                T();
              },
            };
          }),
          (t.registerMutableSourceForHydration = function (c, f) {
            var y = f._getVersion;
            (y = y(f._source)),
              c.mutableSourceEagerHydrationData == null
                ? (c.mutableSourceEagerHydrationData = [f, y])
                : c.mutableSourceEagerHydrationData.push(f, y);
          }),
          (t.runWithPriority = function (c, f) {
            var y = vn;
            try {
              return (vn = c), f();
            } finally {
              vn = y;
            }
          }),
          (t.shouldError = function () {
            return null;
          }),
          (t.shouldSuspend = function () {
            return !1;
          }),
          (t.updateContainer = function (c, f, y, M) {
            var T = f.current,
              P = Tn(),
              Z = fs(T);
            return (
              (y = Mp(y)),
              f.context === null ? (f.context = y) : (f.pendingContext = y),
              (f = ks(P, Z)),
              (f.payload = { element: c }),
              (M = M === void 0 ? null : M),
              M !== null && (f.callback = M),
              Ao(T, f),
              (c = Vi(T, Z, P)),
              c !== null && yc(c, T, Z),
              Z
            );
          }),
          t
        );
      })),
    H0
  );
}
var nS;
function jP() {
  return nS || ((nS = 1), (O0.exports = KP())), O0.exports;
}
var ZP = jP();
const QP = R1(ZP);
var iS = EE();
const __ = {},
  wE = (r) => void Object.assign(__, r);
function qP(r, e) {
  function t(m, { args: g = [], attach: v, ...x }, A) {
    let C = `${m[0].toUpperCase()}${m.slice(1)}`,
      E;
    if (m === 'primitive') {
      if (x.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const S = x.object;
      E = Tf(S, { type: m, root: A, attach: v, primitive: !0 });
    } else {
      const S = __[C];
      if (!S)
        throw new Error(
          `R3F: ${C} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`,
        );
      if (!Array.isArray(g)) throw new Error('R3F: The args prop must be an array!');
      E = Tf(new S(...g), { type: m, root: A, attach: v, memoizedProps: { args: g } });
    }
    return (
      E.__r3f.attach === void 0 &&
        (E.isBufferGeometry
          ? (E.__r3f.attach = 'geometry')
          : E.isMaterial && (E.__r3f.attach = 'material')),
      C !== 'inject' && W0(E, x),
      E
    );
  }
  function n(m, g) {
    let v = !1;
    if (g) {
      var x, A;
      (x = g.__r3f) != null && x.attach
        ? V0(m, g, g.__r3f.attach)
        : g.isObject3D && m.isObject3D && (m.add(g), (v = !0)),
        v || (A = m.__r3f) == null || A.objects.push(g),
        g.__r3f || Tf(g, {}),
        (g.__r3f.parent = m),
        Sy(g),
        Rf(g);
    }
  }
  function i(m, g, v) {
    let x = !1;
    if (g) {
      var A, C;
      if ((A = g.__r3f) != null && A.attach) V0(m, g, g.__r3f.attach);
      else if (g.isObject3D && m.isObject3D) {
        (g.parent = m),
          g.dispatchEvent({ type: 'added' }),
          m.dispatchEvent({ type: 'childadded', child: g });
        const E = m.children.filter((b) => b !== g),
          S = E.indexOf(v);
        (m.children = [...E.slice(0, S), g, ...E.slice(S)]), (x = !0);
      }
      x || (C = m.__r3f) == null || C.objects.push(g),
        g.__r3f || Tf(g, {}),
        (g.__r3f.parent = m),
        Sy(g),
        Rf(g);
    }
  }
  function o(m, g, v = !1) {
    m && [...m].forEach((x) => a(g, x, v));
  }
  function a(m, g, v) {
    if (g) {
      var x, A, C;
      if (
        (g.__r3f && (g.__r3f.parent = null),
        (x = m.__r3f) != null &&
          x.objects &&
          (m.__r3f.objects = m.__r3f.objects.filter((B) => B !== g)),
        (A = g.__r3f) != null && A.attach)
      )
        lS(m, g, g.__r3f.attach);
      else if (g.isObject3D && m.isObject3D) {
        var E;
        m.remove(g), (E = g.__r3f) != null && E.root && s2(Km(g), g);
      }
      const b = (C = g.__r3f) == null ? void 0 : C.primitive,
        I = !b && (v === void 0 ? g.dispose !== null : v);
      if (!b) {
        var S;
        o((S = g.__r3f) == null ? void 0 : S.objects, g, I), o(g.children, g, I);
      }
      if ((delete g.__r3f, I && g.dispose && g.type !== 'Scene')) {
        const B = () => {
          try {
            g.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > 'u'
          ? iS.unstable_scheduleCallback(iS.unstable_IdlePriority, B)
          : B();
      }
      Rf(m);
    }
  }
  function u(m, g, v, x) {
    var A;
    const C = (A = m.__r3f) == null ? void 0 : A.parent;
    if (!C) return;
    const E = t(g, v, m.__r3f.root);
    if (m.children) {
      for (const S of m.children) S.__r3f && n(E, S);
      m.children = m.children.filter((S) => !S.__r3f);
    }
    m.__r3f.objects.forEach((S) => n(E, S)),
      (m.__r3f.objects = []),
      m.__r3f.autoRemovedBeforeAppend || a(C, m),
      E.parent && (E.__r3f.autoRemovedBeforeAppend = !0),
      n(C, E),
      E.raycast && E.__r3f.eventCount && Km(E).getState().internal.interaction.push(E),
      [x, x.alternate].forEach((S) => {
        S !== null &&
          ((S.stateNode = E),
          S.ref && (typeof S.ref == 'function' ? S.ref(E) : (S.ref.current = E)));
      });
  }
  const d = () => {};
  return {
    reconciler: QP({
      createInstance: t,
      removeChild: a,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (m, g) => {
        if (!g) return;
        const v = m.getState().scene;
        v.__r3f && ((v.__r3f.root = m), n(v, g));
      },
      removeChildFromContainer: (m, g) => {
        g && a(m.getState().scene, g);
      },
      insertInContainerBefore: (m, g, v) => {
        if (!g || !v) return;
        const x = m.getState().scene;
        x.__r3f && i(x, g, v);
      },
      getRootHostContext: () => null,
      getChildHostContext: (m) => m,
      finalizeInitialChildren(m) {
        var g;
        return !!((g = m == null ? void 0 : m.__r3f) != null ? g : {}).handlers;
      },
      prepareUpdate(m, g, v, x) {
        var A;
        if (
          ((A = m == null ? void 0 : m.__r3f) != null ? A : {}).primitive &&
          x.object &&
          x.object !== m
        )
          return [!0];
        {
          const { args: E = [], children: S, ...b } = x,
            { args: I = [], children: B, ...z } = v;
          if (!Array.isArray(E)) throw new Error('R3F: the args prop must be an array!');
          if (E.some((G, k) => G !== I[k])) return [!0];
          const N = PE(m, b, z, !0);
          return N.changes.length ? [!1, N] : null;
        }
      },
      commitUpdate(m, [g, v], x, A, C, E) {
        g ? u(m, x, C, E) : W0(m, v);
      },
      commitMount(m, g, v, x) {
        var A;
        const C = (A = m.__r3f) != null ? A : {};
        m.raycast && C.handlers && C.eventCount && Km(m).getState().internal.interaction.push(m);
      },
      getPublicInstance: (m) => m,
      prepareForCommit: () => null,
      preparePortalMount: (m) => Tf(m.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(m) {
        var g;
        const { attach: v, parent: x } = (g = m.__r3f) != null ? g : {};
        v && x && lS(x, m, v), m.isObject3D && (m.visible = !1), Rf(m);
      },
      unhideInstance(m, g) {
        var v;
        const { attach: x, parent: A } = (v = m.__r3f) != null ? v : {};
        x && A && V0(A, m, x),
          ((m.isObject3D && g.visible == null) || g.visible) && (m.visible = !0),
          Rf(m);
      },
      createTextInstance: d,
      hideTextInstance: d,
      unhideTextInstance: d,
      getCurrentEventPriority: () => e(),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < 'u' && Qn.fun(performance.now)
          ? performance.now
          : Qn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Qn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Qn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: W0,
  };
}
var rS, sS;
const G0 = (r) => 'colorSpace' in r || 'outputColorSpace' in r,
  CE = () => {
    var r;
    return (r = __.ColorManagement) != null ? r : null;
  },
  TE = (r) => r && r.isOrthographicCamera,
  $P = (r) => r && r.hasOwnProperty('current'),
  Qh =
    typeof window < 'u' &&
    (((rS = window.document) != null && rS.createElement) ||
      ((sS = window.navigator) == null ? void 0 : sS.product) === 'ReactNative')
      ? je.useLayoutEffect
      : je.useEffect;
function RE(r) {
  const e = je.useRef(r);
  return Qh(() => void (e.current = r), [r]), e;
}
function e2({ set: r }) {
  return Qh(() => (r(new Promise(() => null)), () => r(!1)), [r]), null;
}
class bE extends je.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
bE.getDerivedStateFromError = () => ({ error: !0 });
const IE = '__default',
  oS = new Map(),
  t2 = (r) => r && !!r.memoized && !!r.changes;
function BE(r) {
  var e;
  const t = typeof window < 'u' ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r;
}
const nh = (r) => {
  var e;
  return (e = r.__r3f) == null ? void 0 : e.root.getState();
};
function Km(r) {
  let e = r.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Qn = {
  obj: (r) => r === Object(r) && !Qn.arr(r) && typeof r != 'function',
  fun: (r) => typeof r == 'function',
  str: (r) => typeof r == 'string',
  num: (r) => typeof r == 'number',
  boo: (r) => typeof r == 'boolean',
  und: (r) => r === void 0,
  arr: (r) => Array.isArray(r),
  equ(r, e, { arrays: t = 'shallow', objects: n = 'reference', strict: i = !0 } = {}) {
    if (typeof r != typeof e || !!r != !!e) return !1;
    if (Qn.str(r) || Qn.num(r) || Qn.boo(r)) return r === e;
    const o = Qn.obj(r);
    if (o && n === 'reference') return r === e;
    const a = Qn.arr(r);
    if (a && t === 'reference') return r === e;
    if ((a || o) && r === e) return !0;
    let u;
    for (u in r) if (!(u in e)) return !1;
    if (o && t === 'shallow' && n === 'shallow') {
      for (u in i ? e : r) if (!Qn.equ(r[u], e[u], { strict: i, objects: 'reference' })) return !1;
    } else for (u in i ? e : r) if (r[u] !== e[u]) return !1;
    if (Qn.und(u)) {
      if (
        (a && r.length === 0 && e.length === 0) ||
        (o && Object.keys(r).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (r !== e) return !1;
    }
    return !0;
  },
};
function n2(r) {
  const e = { nodes: {}, materials: {} };
  return (
    r &&
      r.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function i2(r) {
  r.dispose && r.type !== 'Scene' && r.dispose();
  for (const e in r) e.dispose == null || e.dispose(), delete r[e];
}
function Tf(r, e) {
  const t = r;
  return (
    (t.__r3f = {
      type: '',
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    r
  );
}
function Ay(r, e) {
  let t = r;
  if (e.includes('-')) {
    const n = e.split('-'),
      i = n.pop();
    return (t = n.reduce((o, a) => o[a], r)), { target: t, key: i };
  } else return { target: t, key: e };
}
const aS = /-\d+$/;
function V0(r, e, t) {
  if (Qn.str(t)) {
    if (aS.test(t)) {
      const o = t.replace(aS, ''),
        { target: a, key: u } = Ay(r, o);
      Array.isArray(a[u]) || (a[u] = []);
    }
    const { target: n, key: i } = Ay(r, t);
    (e.__r3f.previousAttach = n[i]), (n[i] = e);
  } else e.__r3f.previousAttach = t(r, e);
}
function lS(r, e, t) {
  var n, i;
  if (Qn.str(t)) {
    const { target: o, key: a } = Ay(r, t),
      u = e.__r3f.previousAttach;
    u === void 0 ? delete o[a] : (o[a] = u);
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(r, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function PE(
  r,
  { children: e, key: t, ref: n, ...i },
  { children: o, key: a, ref: u, ...d } = {},
  h = !1,
) {
  const m = r.__r3f,
    g = Object.entries(i),
    v = [];
  if (h) {
    const A = Object.keys(d);
    for (let C = 0; C < A.length; C++) i.hasOwnProperty(A[C]) || g.unshift([A[C], IE + 'remove']);
  }
  g.forEach(([A, C]) => {
    var E;
    if (((E = r.__r3f) != null && E.primitive && A === 'object') || Qn.equ(C, d[A])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(A)) return v.push([A, C, !0, []]);
    let S = [];
    A.includes('-') && (S = A.split('-')), v.push([A, C, !1, S]);
    for (const b in i) {
      const I = i[b];
      b.startsWith(`${A}-`) && v.push([b, I, !1, b.split('-')]);
    }
  });
  const x = { ...i };
  return (
    m != null &&
      m.memoizedProps &&
      m != null &&
      m.memoizedProps.args &&
      (x.args = m.memoizedProps.args),
    m != null &&
      m.memoizedProps &&
      m != null &&
      m.memoizedProps.attach &&
      (x.attach = m.memoizedProps.attach),
    { memoized: x, changes: v }
  );
}
function W0(r, e) {
  var t;
  const n = r.__r3f,
    i = n == null ? void 0 : n.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: a, changes: u } = t2(e) ? e : PE(r, e),
    d = n == null ? void 0 : n.eventCount;
  r.__r3f && (r.__r3f.memoizedProps = a);
  for (let v = 0; v < u.length; v++) {
    let [x, A, C, E] = u[v];
    if (G0(r)) {
      const B = 'srgb',
        z = 'srgb-linear';
      x === 'encoding'
        ? ((x = 'colorSpace'), (A = A === 3001 ? B : z))
        : x === 'outputEncoding' && ((x = 'outputColorSpace'), (A = A === 3001 ? B : z));
    }
    let S = r,
      b = S[x];
    if (E.length && ((b = E.reduce((I, B) => I[B], r)), !(b && b.set))) {
      const [I, ...B] = E.reverse();
      (S = B.reverse().reduce((z, N) => z[N], r)), (x = I);
    }
    if (A === IE + 'remove')
      if (S.constructor) {
        let I = oS.get(S.constructor);
        I || ((I = new S.constructor()), oS.set(S.constructor, I)), (A = I[x]);
      } else A = 0;
    if (C && n)
      A ? (n.handlers[x] = A) : delete n.handlers[x],
        (n.eventCount = Object.keys(n.handlers).length);
    else if (b && b.set && (b.copy || b instanceof ju)) {
      if (Array.isArray(A)) b.fromArray ? b.fromArray(A) : b.set(...A);
      else if (b.copy && A && A.constructor && b.constructor === A.constructor) b.copy(A);
      else if (A !== void 0) {
        var h;
        const I = (h = b) == null ? void 0 : h.isColor;
        !I && b.setScalar
          ? b.setScalar(A)
          : b instanceof ju && A instanceof ju
          ? (b.mask = A.mask)
          : b.set(A),
          !CE() && o && !o.linear && I && b.convertSRGBToLinear();
      }
    } else {
      var m;
      if (
        ((S[x] = A),
        (m = S[x]) != null && m.isTexture && S[x].format === Si && S[x].type === ns && o)
      ) {
        const I = S[x];
        G0(I) && G0(o.gl)
          ? (I.colorSpace = o.gl.outputColorSpace)
          : (I.encoding = o.gl.outputEncoding);
      }
    }
    Rf(r);
  }
  if (n && n.parent && r.raycast && d !== n.eventCount) {
    const v = Km(r).getState().internal,
      x = v.interaction.indexOf(r);
    x > -1 && v.interaction.splice(x, 1), n.eventCount && v.interaction.push(r);
  }
  return (
    !(u.length === 1 && u[0][0] === 'onUpdate') &&
      u.length &&
      (t = r.__r3f) != null &&
      t.parent &&
      Sy(r),
    r
  );
}
function Rf(r) {
  var e, t;
  const n =
    (e = r.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function Sy(r) {
  r.onUpdate == null || r.onUpdate(r);
}
function DE(r, e) {
  r.manual ||
    (TE(r)
      ? ((r.left = e.width / -2),
        (r.right = e.width / 2),
        (r.top = e.height / 2),
        (r.bottom = e.height / -2))
      : (r.aspect = e.width / e.height),
    r.updateProjectionMatrix(),
    r.updateMatrixWorld());
}
function Om(r) {
  return (r.eventObject || r.object).uuid + '/' + r.index + r.instanceId;
}
function r2() {
  var r;
  const e = (typeof self < 'u' && self) || (typeof window < 'u' && window);
  if (!e) return uh.DefaultEventPriority;
  switch ((r = e.event) == null ? void 0 : r.type) {
    case 'click':
    case 'contextmenu':
    case 'dblclick':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
      return uh.DiscreteEventPriority;
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerenter':
    case 'pointerleave':
    case 'wheel':
      return uh.ContinuousEventPriority;
    default:
      return uh.DefaultEventPriority;
  }
}
function LE(r, e, t, n) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (r.delete(n), i.target.releasePointerCapture(n)));
}
function s2(r, e) {
  const { internal: t } = r.getState();
  (t.interaction = t.interaction.filter((n) => n !== e)),
    (t.initialHits = t.initialHits.filter((n) => n !== e)),
    t.hovered.forEach((n, i) => {
      (n.eventObject === e || n.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((n, i) => {
      LE(t.capturedMap, e, n, i);
    });
}
function o2(r) {
  function e(d) {
    const { internal: h } = r.getState(),
      m = d.offsetX - h.initialClick[0],
      g = d.offsetY - h.initialClick[1];
    return Math.round(Math.sqrt(m * m + g * g));
  }
  function t(d) {
    return d.filter((h) =>
      ['Move', 'Over', 'Enter', 'Out', 'Leave'].some((m) => {
        var g;
        return (g = h.__r3f) == null ? void 0 : g.handlers['onPointer' + m];
      }),
    );
  }
  function n(d, h) {
    const m = r.getState(),
      g = new Set(),
      v = [],
      x = h ? h(m.internal.interaction) : m.internal.interaction;
    for (let S = 0; S < x.length; S++) {
      const b = nh(x[S]);
      b && (b.raycaster.camera = void 0);
    }
    m.previousRoot || m.events.compute == null || m.events.compute(d, m);
    function A(S) {
      const b = nh(S);
      if (!b || !b.events.enabled || b.raycaster.camera === null) return [];
      if (b.raycaster.camera === void 0) {
        var I;
        b.events.compute == null ||
          b.events.compute(d, b, (I = b.previousRoot) == null ? void 0 : I.getState()),
          b.raycaster.camera === void 0 && (b.raycaster.camera = null);
      }
      return b.raycaster.camera ? b.raycaster.intersectObject(S, !0) : [];
    }
    let C = x
      .flatMap(A)
      .sort((S, b) => {
        const I = nh(S.object),
          B = nh(b.object);
        return !I || !B
          ? S.distance - b.distance
          : B.events.priority - I.events.priority || S.distance - b.distance;
      })
      .filter((S) => {
        const b = Om(S);
        return g.has(b) ? !1 : (g.add(b), !0);
      });
    m.events.filter && (C = m.events.filter(C, m));
    for (const S of C) {
      let b = S.object;
      for (; b; ) {
        var E;
        (E = b.__r3f) != null && E.eventCount && v.push({ ...S, eventObject: b }), (b = b.parent);
      }
    }
    if ('pointerId' in d && m.internal.capturedMap.has(d.pointerId))
      for (let S of m.internal.capturedMap.get(d.pointerId).values())
        g.has(Om(S.intersection)) || v.push(S.intersection);
    return v;
  }
  function i(d, h, m, g) {
    const v = r.getState();
    if (d.length) {
      const x = { stopped: !1 };
      for (const A of d) {
        const C = nh(A.object) || v,
          { raycaster: E, pointer: S, camera: b, internal: I } = C,
          B = new J(S.x, S.y, 0).unproject(b),
          z = (D) => {
            var V, oe;
            return (V = (oe = I.capturedMap.get(D)) == null ? void 0 : oe.has(A.eventObject)) !=
              null
              ? V
              : !1;
          },
          N = (D) => {
            const V = { intersection: A, target: h.target };
            I.capturedMap.has(D)
              ? I.capturedMap.get(D).set(A.eventObject, V)
              : I.capturedMap.set(D, new Map([[A.eventObject, V]])),
              h.target.setPointerCapture(D);
          },
          G = (D) => {
            const V = I.capturedMap.get(D);
            V && LE(I.capturedMap, A.eventObject, V, D);
          };
        let k = {};
        for (let D in h) {
          let V = h[D];
          typeof V != 'function' && (k[D] = V);
        }
        let L = {
          ...A,
          ...k,
          pointer: S,
          intersections: d,
          stopped: x.stopped,
          delta: m,
          unprojectedPoint: B,
          ray: E.ray,
          camera: b,
          stopPropagation() {
            const D = 'pointerId' in h && I.capturedMap.get(h.pointerId);
            if (
              (!D || D.has(A.eventObject)) &&
              ((L.stopped = x.stopped = !0),
              I.hovered.size &&
                Array.from(I.hovered.values()).find((V) => V.eventObject === A.eventObject))
            ) {
              const V = d.slice(0, d.indexOf(A));
              o([...V, A]);
            }
          },
          target: { hasPointerCapture: z, setPointerCapture: N, releasePointerCapture: G },
          currentTarget: { hasPointerCapture: z, setPointerCapture: N, releasePointerCapture: G },
          nativeEvent: h,
        };
        if ((g(L), x.stopped === !0)) break;
      }
    }
    return d;
  }
  function o(d) {
    const { internal: h } = r.getState();
    for (const m of h.hovered.values())
      if (
        !d.length ||
        !d.find(
          (g) => g.object === m.object && g.index === m.index && g.instanceId === m.instanceId,
        )
      ) {
        const v = m.eventObject.__r3f,
          x = v == null ? void 0 : v.handlers;
        if ((h.hovered.delete(Om(m)), v != null && v.eventCount)) {
          const A = { ...m, intersections: d };
          x.onPointerOut == null || x.onPointerOut(A),
            x.onPointerLeave == null || x.onPointerLeave(A);
        }
      }
  }
  function a(d, h) {
    for (let m = 0; m < h.length; m++) {
      const g = h[m].__r3f;
      g == null || g.handlers.onPointerMissed == null || g.handlers.onPointerMissed(d);
    }
  }
  function u(d) {
    switch (d) {
      case 'onPointerLeave':
      case 'onPointerCancel':
        return () => o([]);
      case 'onLostPointerCapture':
        return (h) => {
          const { internal: m } = r.getState();
          'pointerId' in h &&
            m.capturedMap.has(h.pointerId) &&
            requestAnimationFrame(() => {
              m.capturedMap.has(h.pointerId) && (m.capturedMap.delete(h.pointerId), o([]));
            });
        };
    }
    return function (m) {
      const { onPointerMissed: g, internal: v } = r.getState();
      v.lastEvent.current = m;
      const x = d === 'onPointerMove',
        A = d === 'onClick' || d === 'onContextMenu' || d === 'onDoubleClick',
        E = n(m, x ? t : void 0),
        S = A ? e(m) : 0;
      d === 'onPointerDown' &&
        ((v.initialClick = [m.offsetX, m.offsetY]), (v.initialHits = E.map((I) => I.eventObject))),
        A && !E.length && S <= 2 && (a(m, v.interaction), g && g(m)),
        x && o(E);
      function b(I) {
        const B = I.eventObject,
          z = B.__r3f,
          N = z == null ? void 0 : z.handlers;
        if (z != null && z.eventCount)
          if (x) {
            if (N.onPointerOver || N.onPointerEnter || N.onPointerOut || N.onPointerLeave) {
              const G = Om(I),
                k = v.hovered.get(G);
              k
                ? k.stopped && I.stopPropagation()
                : (v.hovered.set(G, I),
                  N.onPointerOver == null || N.onPointerOver(I),
                  N.onPointerEnter == null || N.onPointerEnter(I));
            }
            N.onPointerMove == null || N.onPointerMove(I);
          } else {
            const G = N[d];
            G
              ? (!A || v.initialHits.includes(B)) &&
                (a(
                  m,
                  v.interaction.filter((k) => !v.initialHits.includes(k)),
                ),
                G(I))
              : A &&
                v.initialHits.includes(B) &&
                a(
                  m,
                  v.interaction.filter((k) => !v.initialHits.includes(k)),
                );
          }
      }
      i(E, m, S, b);
    };
  }
  return { handlePointer: u };
}
const a2 = [
    'set',
    'get',
    'setSize',
    'setFrameloop',
    'setDpr',
    'events',
    'invalidate',
    'advance',
    'size',
    'viewport',
  ],
  FE = (r) => !!(r != null && r.render),
  x_ = je.createContext(null),
  l2 = (r, e) => {
    const t = AE((u, d) => {
        const h = new J(),
          m = new J(),
          g = new J();
        function v(S = d().camera, b = m, I = d().size) {
          const { width: B, height: z, top: N, left: G } = I,
            k = B / z;
          b.isVector3 ? g.copy(b) : g.set(...b);
          const L = S.getWorldPosition(h).distanceTo(g);
          if (TE(S))
            return {
              width: B / S.zoom,
              height: z / S.zoom,
              top: N,
              left: G,
              factor: 1,
              distance: L,
              aspect: k,
            };
          {
            const D = (S.fov * Math.PI) / 180,
              V = 2 * Math.tan(D / 2) * L,
              oe = V * (B / z);
            return {
              width: oe,
              height: V,
              top: N,
              left: G,
              factor: B / oe,
              distance: L,
              aspect: k,
            };
          }
        }
        let x;
        const A = (S) => u((b) => ({ performance: { ...b.performance, current: S } })),
          C = new Ge();
        return {
          set: u,
          get: d,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (S = 1) => r(d(), S),
          advance: (S, b) => e(S, b, d()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new f_(),
          pointer: C,
          mouse: C,
          frameloop: 'always',
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const S = d();
              x && clearTimeout(x),
                S.performance.current !== S.performance.min && A(S.performance.min),
                (x = setTimeout(() => A(d().performance.max), S.performance.debounce));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: v,
          },
          setEvents: (S) => u((b) => ({ ...b, events: { ...b.events, ...S } })),
          setSize: (S, b, I, B, z) => {
            const N = d().camera,
              G = { width: S, height: b, top: B || 0, left: z || 0, updateStyle: I };
            u((k) => ({ size: G, viewport: { ...k.viewport, ...v(N, m, G) } }));
          },
          setDpr: (S) =>
            u((b) => {
              const I = BE(S);
              return {
                viewport: { ...b.viewport, dpr: I, initialDpr: b.viewport.initialDpr || I },
              };
            }),
          setFrameloop: (S = 'always') => {
            const b = d().clock;
            b.stop(),
              (b.elapsedTime = 0),
              S !== 'never' && (b.start(), (b.elapsedTime = 0)),
              u(() => ({ frameloop: S }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: je.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (S, b, I) => {
              const B = d().internal;
              return (
                (B.priority = B.priority + (b > 0 ? 1 : 0)),
                B.subscribers.push({ ref: S, priority: b, store: I }),
                (B.subscribers = B.subscribers.sort((z, N) => z.priority - N.priority)),
                () => {
                  const z = d().internal;
                  z != null &&
                    z.subscribers &&
                    ((z.priority = z.priority - (b > 0 ? 1 : 0)),
                    (z.subscribers = z.subscribers.filter((N) => N.ref !== S)));
                }
              );
            },
          },
        };
      }),
      n = t.getState();
    let i = n.size,
      o = n.viewport.dpr,
      a = n.camera;
    return (
      t.subscribe(() => {
        const { camera: u, size: d, viewport: h, gl: m, set: g } = t.getState();
        if (d.width !== i.width || d.height !== i.height || h.dpr !== o) {
          var v;
          (i = d), (o = h.dpr), DE(u, d), m.setPixelRatio(h.dpr);
          const x =
            (v = d.updateStyle) != null
              ? v
              : typeof HTMLCanvasElement < 'u' && m.domElement instanceof HTMLCanvasElement;
          m.setSize(d.width, d.height, x);
        }
        u !== a &&
          ((a = u),
          g((x) => ({ viewport: { ...x.viewport, ...x.viewport.getCurrentViewport(u) } })));
      }),
      t.subscribe((u) => r(u)),
      t
    );
  };
let km,
  u2 = new Set(),
  c2 = new Set(),
  f2 = new Set();
function X0(r, e) {
  if (r.size) for (const { callback: t } of r.values()) t(e);
}
function ih(r, e) {
  switch (r) {
    case 'before':
      return X0(u2, e);
    case 'after':
      return X0(c2, e);
    case 'tail':
      return X0(f2, e);
  }
}
let J0, Y0;
function K0(r, e, t) {
  let n = e.clock.getDelta();
  for (
    e.frameloop === 'never' &&
      typeof r == 'number' &&
      ((n = r - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = r)),
      J0 = e.internal.subscribers,
      km = 0;
    km < J0.length;
    km++
  )
    (Y0 = J0[km]), Y0.ref.current(Y0.store.getState(), n, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === 'always' ? 1 : e.internal.frames
  );
}
function d2(r) {
  let e = !1,
    t = !1,
    n,
    i,
    o;
  function a(h) {
    (i = requestAnimationFrame(a)), (e = !0), (n = 0), ih('before', h), (t = !0);
    for (const g of r.values()) {
      var m;
      (o = g.store.getState()),
        o.internal.active &&
          (o.frameloop === 'always' || o.internal.frames > 0) &&
          !((m = o.gl.xr) != null && m.isPresenting) &&
          (n += K0(h, o));
    }
    if (((t = !1), ih('after', h), n === 0))
      return ih('tail', h), (e = !1), cancelAnimationFrame(i);
  }
  function u(h, m = 1) {
    var g;
    if (!h) return r.forEach((v) => u(v.store.getState(), m));
    ((g = h.gl.xr) != null && g.isPresenting) ||
      !h.internal.active ||
      h.frameloop === 'never' ||
      (m > 1
        ? (h.internal.frames = Math.min(60, h.internal.frames + m))
        : t
        ? (h.internal.frames = 2)
        : (h.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(a)));
  }
  function d(h, m = !0, g, v) {
    if ((m && ih('before', h), g)) K0(h, g, v);
    else for (const x of r.values()) K0(h, x.store.getState());
    m && ih('after', h);
  }
  return { loop: a, invalidate: u, advance: d };
}
function A_() {
  const r = je.useContext(x_);
  if (!r) throw new Error('R3F: Hooks can only be used within the Canvas component!');
  return r;
}
function $r(r = (t) => t, e) {
  return A_()(r, e);
}
function NE(r, e = 0) {
  const t = A_(),
    n = t.getState().internal.subscribe,
    i = RE(r);
  return Qh(() => n(i, e, t), [e, n, t]), null;
}
const uS = new WeakMap();
function UE(r, e) {
  return function (t, ...n) {
    let i = uS.get(t);
    return (
      i || ((i = new t()), uS.set(t, i)),
      r && r(i),
      Promise.all(
        n.map(
          (o) =>
            new Promise((a, u) =>
              i.load(
                o,
                (d) => {
                  d.scene && Object.assign(d, n2(d.scene)), a(d);
                },
                e,
                (d) => u(new Error(`Could not load ${o}: ${d == null ? void 0 : d.message}`)),
              ),
            ),
        ),
      )
    );
  };
}
function Fs(r, e, t, n) {
  const i = Array.isArray(e) ? e : [e],
    o = WP(UE(t, n), [r, ...i], { equal: Qn.equ });
  return Array.isArray(e) ? o : o[0];
}
Fs.preload = function (r, e, t) {
  const n = Array.isArray(e) ? e : [e];
  return XP(UE(t), [r, ...n]);
};
Fs.clear = function (r, e) {
  const t = Array.isArray(e) ? e : [e];
  return JP([r, ...t]);
};
const Wf = new Map(),
  { invalidate: cS, advance: fS } = d2(Wf),
  { reconciler: Bh, applyProps: Sl } = qP(Wf, r2),
  wf = { objects: 'shallow', strict: !1 },
  h2 = (r, e) => {
    const t = typeof r == 'function' ? r(e) : r;
    return FE(t)
      ? t
      : new y_({ powerPreference: 'high-performance', canvas: e, antialias: !0, alpha: !0, ...r });
  };
function p2(r, e) {
  const t = typeof HTMLCanvasElement < 'u' && r instanceof HTMLCanvasElement;
  if (e) {
    const { width: n, height: i, top: o, left: a, updateStyle: u = t } = e;
    return { width: n, height: i, top: o, left: a, updateStyle: u };
  } else if (typeof HTMLCanvasElement < 'u' && r instanceof HTMLCanvasElement && r.parentElement) {
    const { width: n, height: i, top: o, left: a } = r.parentElement.getBoundingClientRect();
    return { width: n, height: i, top: o, left: a, updateStyle: t };
  } else if (typeof OffscreenCanvas < 'u' && r instanceof OffscreenCanvas)
    return { width: r.width, height: r.height, top: 0, left: 0, updateStyle: t };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function m2(r) {
  const e = Wf.get(r),
    t = e == null ? void 0 : e.fiber,
    n = e == null ? void 0 : e.store;
  e && console.warn('R3F.createRoot should only be called once!');
  const i = typeof reportError == 'function' ? reportError : console.error,
    o = n || l2(cS, fS),
    a = t || Bh.createContainer(o, uh.ConcurrentRoot, null, !1, null, '', i, null);
  e || Wf.set(r, { fiber: a, store: o });
  let u,
    d = !1,
    h;
  return {
    configure(m = {}) {
      let {
          gl: g,
          size: v,
          scene: x,
          events: A,
          onCreated: C,
          shadows: E = !1,
          linear: S = !1,
          flat: b = !1,
          legacy: I = !1,
          orthographic: B = !1,
          frameloop: z = 'always',
          dpr: N = [1, 2],
          performance: G,
          raycaster: k,
          camera: L,
          onPointerMissed: D,
        } = m,
        V = o.getState(),
        oe = V.gl;
      V.gl || V.set({ gl: (oe = h2(g, r)) });
      let ie = V.raycaster;
      ie || V.set({ raycaster: (ie = new m_()) });
      const { params: ce, ...xe } = k || {};
      if (
        (Qn.equ(xe, ie, wf) || Sl(ie, { ...xe }),
        Qn.equ(ce, ie.params, wf) || Sl(ie, { params: { ...ie.params, ...ce } }),
        !V.camera || (V.camera === h && !Qn.equ(h, L, wf)))
      ) {
        h = L;
        const te = L instanceof kh,
          Y = te ? L : B ? new No(0, 0, 0, 0, 0.1, 1e3) : new gi(75, 0, 0.1, 1e3);
        te ||
          ((Y.position.z = 5),
          L &&
            (Sl(Y, L),
            ('aspect' in L || 'left' in L || 'right' in L || 'bottom' in L || 'top' in L) &&
              ((Y.manual = !0), Y.updateProjectionMatrix())),
          !V.camera && !(L != null && L.rotation) && Y.lookAt(0, 0, 0)),
          V.set({ camera: Y }),
          (ie.camera = Y);
      }
      if (!V.scene) {
        let te;
        x != null && x.isScene ? (te = x) : ((te = new Hh()), x && Sl(te, x)),
          V.set({ scene: Tf(te) });
      }
      if (!V.xr) {
        var de;
        const te = (He, ge) => {
            const De = o.getState();
            De.frameloop !== 'never' && fS(He, !0, De, ge);
          },
          Y = () => {
            const He = o.getState();
            (He.gl.xr.enabled = He.gl.xr.isPresenting),
              He.gl.xr.setAnimationLoop(He.gl.xr.isPresenting ? te : null),
              He.gl.xr.isPresenting || cS(He);
          },
          ue = {
            connect() {
              const He = o.getState().gl;
              He.xr.addEventListener('sessionstart', Y), He.xr.addEventListener('sessionend', Y);
            },
            disconnect() {
              const He = o.getState().gl;
              He.xr.removeEventListener('sessionstart', Y),
                He.xr.removeEventListener('sessionend', Y);
            },
          };
        typeof ((de = oe.xr) == null ? void 0 : de.addEventListener) == 'function' && ue.connect(),
          V.set({ xr: ue });
      }
      if (oe.shadowMap) {
        const te = oe.shadowMap.enabled,
          Y = oe.shadowMap.type;
        if (((oe.shadowMap.enabled = !!E), Qn.boo(E))) oe.shadowMap.type = ch;
        else if (Qn.str(E)) {
          var Ce;
          const ue = { basic: IS, percentage: Ug, soft: ch, variance: co };
          oe.shadowMap.type = (Ce = ue[E]) != null ? Ce : ch;
        } else Qn.obj(E) && Object.assign(oe.shadowMap, E);
        (te !== oe.shadowMap.enabled || Y !== oe.shadowMap.type) && (oe.shadowMap.needsUpdate = !0);
      }
      const X = CE();
      X && ('enabled' in X ? (X.enabled = !I) : 'legacyMode' in X && (X.legacyMode = I)),
        d || Sl(oe, { outputEncoding: S ? 3e3 : 3001, toneMapping: b ? Lo : Ty }),
        V.legacy !== I && V.set(() => ({ legacy: I })),
        V.linear !== S && V.set(() => ({ linear: S })),
        V.flat !== b && V.set(() => ({ flat: b })),
        g && !Qn.fun(g) && !FE(g) && !Qn.equ(g, oe, wf) && Sl(oe, g),
        A && !V.events.handlers && V.set({ events: A(o) });
      const fe = p2(r, v);
      return (
        Qn.equ(fe, V.size, wf) || V.setSize(fe.width, fe.height, fe.updateStyle, fe.top, fe.left),
        N && V.viewport.dpr !== BE(N) && V.setDpr(N),
        V.frameloop !== z && V.setFrameloop(z),
        V.onPointerMissed || V.set({ onPointerMissed: D }),
        G &&
          !Qn.equ(G, V.performance, wf) &&
          V.set((te) => ({ performance: { ...te.performance, ...G } })),
        (u = C),
        (d = !0),
        this
      );
    },
    render(m) {
      return (
        d || this.configure(),
        Bh.updateContainer(
          Vt.jsx(g2, { store: o, children: m, onCreated: u, rootElement: r }),
          a,
          null,
          () => {},
        ),
        o
      );
    },
    unmount() {
      OE(r);
    },
  };
}
function g2({ store: r, children: e, onCreated: t, rootElement: n }) {
  return (
    Qh(() => {
      const i = r.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        t && t(i),
        r.getState().events.connected || i.events.connect == null || i.events.connect(n);
    }, []),
    Vt.jsx(x_.Provider, { value: r, children: e })
  );
}
function OE(r, e) {
  const t = Wf.get(r),
    n = t == null ? void 0 : t.fiber;
  if (n) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      Bh.updateContainer(null, n, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, a, u, d;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (a = o.renderLists) == null ||
                  a.dispose == null ||
                  a.dispose(),
                (u = i.gl) == null || u.forceContextLoss == null || u.forceContextLoss(),
                (d = i.gl) != null && d.xr && i.xr.disconnect(),
                i2(i),
                Wf.delete(r);
            } catch {}
          }, 500);
      });
  }
}
function v2(r, e, t) {
  return Vt.jsx(y2, { children: r, container: e, state: t }, e.uuid);
}
function y2({ state: r = {}, children: e, container: t }) {
  const { events: n, size: i, ...o } = r,
    a = A_(),
    [u] = je.useState(() => new m_()),
    [d] = je.useState(() => new Ge()),
    h = je.useCallback(
      (g, v) => {
        const x = { ...g };
        Object.keys(g).forEach((C) => {
          (a2.includes(C) || (g[C] !== v[C] && v[C])) && delete x[C];
        });
        let A;
        if (v && i) {
          const C = v.camera;
          (A = g.viewport.getCurrentViewport(C, new J(), i)), C !== g.camera && DE(C, i);
        }
        return {
          ...x,
          scene: t,
          raycaster: u,
          pointer: d,
          mouse: d,
          previousRoot: a,
          events: { ...g.events, ...(v == null ? void 0 : v.events), ...n },
          size: { ...g.size, ...i },
          viewport: { ...g.viewport, ...A },
          ...o,
        };
      },
      [r],
    ),
    [m] = je.useState(() => {
      const g = a.getState();
      return AE((x, A) => ({
        ...g,
        scene: t,
        raycaster: u,
        pointer: d,
        mouse: d,
        previousRoot: a,
        events: { ...g.events, ...n },
        size: { ...g.size, ...i },
        ...o,
        set: x,
        get: A,
        setEvents: (C) => x((E) => ({ ...E, events: { ...E.events, ...C } })),
      }));
    });
  return (
    je.useEffect(() => {
      const g = a.subscribe((v) => m.setState((x) => h(v, x)));
      return () => {
        g();
      };
    }, [h]),
    je.useEffect(() => {
      m.setState((g) => h(a.getState(), g));
    }, [h]),
    je.useEffect(
      () => () => {
        m.destroy();
      },
      [],
    ),
    Vt.jsx(Vt.Fragment, {
      children: Bh.createPortal(Vt.jsx(x_.Provider, { value: m, children: e }), m, null),
    })
  );
}
Bh.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: '@react-three/fiber',
  version: je.version,
});
const j0 = {
  onClick: ['click', !1],
  onContextMenu: ['contextmenu', !1],
  onDoubleClick: ['dblclick', !1],
  onWheel: ['wheel', !0],
  onPointerDown: ['pointerdown', !0],
  onPointerUp: ['pointerup', !0],
  onPointerLeave: ['pointerleave', !0],
  onPointerMove: ['pointermove', !0],
  onPointerCancel: ['pointercancel', !0],
  onLostPointerCapture: ['lostpointercapture', !0],
};
function _2(r) {
  const { handlePointer: e } = o2(r);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set((t.offsetX / n.size.width) * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1),
        n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(j0).reduce((t, n) => ({ ...t, [n]: e(n) }), {}),
    update: () => {
      var t;
      const { events: n, internal: i } = r.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        n.handlers &&
        n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const { set: i, events: o } = r.getState();
      o.disconnect == null || o.disconnect(),
        i((a) => ({ events: { ...a.events, connected: t } })),
        Object.entries((n = o.handlers) != null ? n : []).forEach(([a, u]) => {
          const [d, h] = j0[a];
          t.addEventListener(d, u, { passive: h });
        });
    },
    disconnect: () => {
      const { set: t, events: n } = r.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([o, a]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [u] = j0[o];
            n.connected.removeEventListener(u, a);
          }
        }),
          t((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
function dS(r, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), (t = window.setTimeout(() => r(...n), e));
  };
}
function x2(
  { debounce: r, scroll: e, polyfill: t, offsetSize: n } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  },
) {
  const i = t || (typeof window > 'u' ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      'This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills',
    );
  const [o, a] = je.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    u = je.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    d = r ? (typeof r == 'number' ? r : r.scroll) : null,
    h = r ? (typeof r == 'number' ? r : r.resize) : null,
    m = je.useRef(!1);
  je.useEffect(() => ((m.current = !0), () => void (m.current = !1)));
  const [g, v, x] = je.useMemo(() => {
    const S = () => {
      if (!u.current.element) return;
      const {
          left: b,
          top: I,
          width: B,
          height: z,
          bottom: N,
          right: G,
          x: k,
          y: L,
        } = u.current.element.getBoundingClientRect(),
        D = { left: b, top: I, width: B, height: z, bottom: N, right: G, x: k, y: L };
      u.current.element instanceof HTMLElement &&
        n &&
        ((D.height = u.current.element.offsetHeight), (D.width = u.current.element.offsetWidth)),
        Object.freeze(D),
        m.current && !E2(u.current.lastBounds, D) && a((u.current.lastBounds = D));
    };
    return [S, h ? dS(S, h) : S, d ? dS(S, d) : S];
  }, [a, n, d, h]);
  function A() {
    u.current.scrollContainers &&
      (u.current.scrollContainers.forEach((S) => S.removeEventListener('scroll', x, !0)),
      (u.current.scrollContainers = null)),
      u.current.resizeObserver &&
        (u.current.resizeObserver.disconnect(), (u.current.resizeObserver = null)),
      u.current.orientationHandler &&
        ('orientation' in screen && 'removeEventListener' in screen.orientation
          ? screen.orientation.removeEventListener('change', u.current.orientationHandler)
          : 'onorientationchange' in window &&
            window.removeEventListener('orientationchange', u.current.orientationHandler));
  }
  function C() {
    u.current.element &&
      ((u.current.resizeObserver = new i(x)),
      u.current.resizeObserver.observe(u.current.element),
      e &&
        u.current.scrollContainers &&
        u.current.scrollContainers.forEach((S) =>
          S.addEventListener('scroll', x, { capture: !0, passive: !0 }),
        ),
      (u.current.orientationHandler = () => {
        x();
      }),
      'orientation' in screen && 'addEventListener' in screen.orientation
        ? screen.orientation.addEventListener('change', u.current.orientationHandler)
        : 'onorientationchange' in window &&
          window.addEventListener('orientationchange', u.current.orientationHandler));
  }
  const E = (S) => {
    !S ||
      S === u.current.element ||
      (A(), (u.current.element = S), (u.current.scrollContainers = kE(S)), C());
  };
  return (
    S2(x, !!e),
    A2(v),
    je.useEffect(() => {
      A(), C();
    }, [e, x, v]),
    je.useEffect(() => A, []),
    [E, o, g]
  );
}
function A2(r) {
  je.useEffect(() => {
    const e = r;
    return window.addEventListener('resize', e), () => void window.removeEventListener('resize', e);
  }, [r]);
}
function S2(r, e) {
  je.useEffect(() => {
    if (e) {
      const t = r;
      return (
        window.addEventListener('scroll', t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener('scroll', t, !0)
      );
    }
  }, [r, e]);
}
function kE(r) {
  const e = [];
  if (!r || r === document.body) return e;
  const { overflow: t, overflowX: n, overflowY: i } = window.getComputedStyle(r);
  return (
    [t, n, i].some((o) => o === 'auto' || o === 'scroll') && e.push(r),
    [...e, ...kE(r.parentElement)]
  );
}
const M2 = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'],
  E2 = (r, e) => M2.every((t) => r[t] === e[t]);
var w2 = Object.defineProperty,
  C2 = Object.defineProperties,
  T2 = Object.getOwnPropertyDescriptors,
  hS = Object.getOwnPropertySymbols,
  R2 = Object.prototype.hasOwnProperty,
  b2 = Object.prototype.propertyIsEnumerable,
  pS = (r, e, t) =>
    e in r ? w2(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (r[e] = t),
  mS = (r, e) => {
    for (var t in e || (e = {})) R2.call(e, t) && pS(r, t, e[t]);
    if (hS) for (var t of hS(e)) b2.call(e, t) && pS(r, t, e[t]);
    return r;
  },
  I2 = (r, e) => C2(r, T2(e)),
  gS,
  vS;
typeof window < 'u' &&
(((gS = window.document) != null && gS.createElement) ||
  ((vS = window.navigator) == null ? void 0 : vS.product) === 'ReactNative')
  ? je.useLayoutEffect
  : je.useEffect;
function zE(r, e, t) {
  if (!r) return;
  if (t(r) === !0) return r;
  let n = r.child;
  for (; n; ) {
    const i = zE(n, e, t);
    if (i) return i;
    n = n.sibling;
  }
}
function HE(r) {
  try {
    return Object.defineProperties(r, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return r;
  }
}
const yS = console.error;
console.error = function () {
  const r = [...arguments].join('');
  if (r != null && r.startsWith('Warning:') && r.includes('useContext')) {
    console.error = yS;
    return;
  }
  return yS.apply(this, arguments);
};
const S_ = HE(je.createContext(null));
class GE extends je.Component {
  render() {
    return je.createElement(S_.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function B2() {
  const r = je.useContext(S_);
  if (r === null) throw new Error('its-fine: useFiber must be called within a <FiberProvider />!');
  const e = je.useId();
  return je.useMemo(() => {
    for (const n of [r, r == null ? void 0 : r.alternate]) {
      if (!n) continue;
      const i = zE(n, !1, (o) => {
        let a = o.memoizedState;
        for (; a; ) {
          if (a.memoizedState === e) return !0;
          a = a.next;
        }
      });
      if (i) return i;
    }
  }, [r, e]);
}
function P2() {
  const r = B2(),
    [e] = je.useState(() => new Map());
  e.clear();
  let t = r;
  for (; t; ) {
    if (t.type && typeof t.type == 'object') {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== S_ && !e.has(i) && e.set(i, je.useContext(HE(i)));
    }
    t = t.return;
  }
  return e;
}
function D2() {
  const r = P2();
  return je.useMemo(
    () =>
      Array.from(r.keys()).reduce(
        (e, t) => (n) =>
          je.createElement(
            e,
            null,
            je.createElement(t.Provider, I2(mS({}, n), { value: r.get(t) })),
          ),
        (e) => je.createElement(GE, mS({}, e)),
      ),
    [r],
  );
}
const L2 = je.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: n,
      style: i,
      gl: o,
      events: a = _2,
      eventSource: u,
      eventPrefix: d,
      shadows: h,
      linear: m,
      flat: g,
      legacy: v,
      orthographic: x,
      frameloop: A,
      dpr: C,
      performance: E,
      raycaster: S,
      camera: b,
      scene: I,
      onPointerMissed: B,
      onCreated: z,
      ...N
    },
    G,
  ) {
    je.useMemo(() => wE(OP), []);
    const k = D2(),
      [L, D] = x2({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...n }),
      V = je.useRef(null),
      oe = je.useRef(null);
    je.useImperativeHandle(G, () => V.current);
    const ie = RE(B),
      [ce, xe] = je.useState(!1),
      [de, Ce] = je.useState(!1);
    if (ce) throw ce;
    if (de) throw de;
    const X = je.useRef(null);
    Qh(() => {
      const te = V.current;
      D.width > 0 &&
        D.height > 0 &&
        te &&
        (X.current || (X.current = m2(te)),
        X.current.configure({
          gl: o,
          events: a,
          shadows: h,
          linear: m,
          flat: g,
          legacy: v,
          orthographic: x,
          frameloop: A,
          dpr: C,
          performance: E,
          raycaster: S,
          camera: b,
          scene: I,
          size: D,
          onPointerMissed: (...Y) => (ie.current == null ? void 0 : ie.current(...Y)),
          onCreated: (Y) => {
            Y.events.connect == null || Y.events.connect(u ? ($P(u) ? u.current : u) : oe.current),
              d &&
                Y.setEvents({
                  compute: (ue, He) => {
                    const ge = ue[d + 'X'],
                      De = ue[d + 'Y'];
                    He.pointer.set((ge / He.size.width) * 2 - 1, -(De / He.size.height) * 2 + 1),
                      He.raycaster.setFromCamera(He.pointer, He.camera);
                  },
                }),
              z == null || z(Y);
          },
        }),
        X.current.render(
          Vt.jsx(k, {
            children: Vt.jsx(bE, {
              set: Ce,
              children: Vt.jsx(je.Suspense, { fallback: Vt.jsx(e2, { set: xe }), children: e }),
            }),
          }),
        ));
    }),
      je.useEffect(() => {
        const te = V.current;
        if (te) return () => OE(te);
      }, []);
    const fe = u ? 'none' : 'auto';
    return Vt.jsx('div', {
      ref: oe,
      style: {
        position: 'relative',
        width: '100%',
        height: '100%',
        overflow: 'hidden',
        pointerEvents: fe,
        ...i,
      },
      ...N,
      children: Vt.jsx('div', {
        ref: L,
        style: { width: '100%', height: '100%' },
        children: Vt.jsx('canvas', { ref: V, style: { display: 'block' }, children: t }),
      }),
    });
  }),
  F2 = je.forwardRef(function (e, t) {
    return Vt.jsx(GE, { children: Vt.jsx(L2, { ...e, ref: t }) });
  });
function Lg() {
  return (
    (Lg = Object.assign
      ? Object.assign.bind()
      : function (r) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t) ({}).hasOwnProperty.call(t, n) && (r[n] = t[n]);
          }
          return r;
        }),
    Lg.apply(null, arguments)
  );
}
const M_ = parseInt(Dh.replace(/\D+/g, ''));
function _S(r, e) {
  if (e === aM)
    return (
      console.warn(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.',
      ),
      r
    );
  if (e === Ig || e === Ny) {
    let t = r.getIndex();
    if (t === null) {
      const a = [],
        u = r.getAttribute('position');
      if (u !== void 0) {
        for (let d = 0; d < u.count; d++) a.push(d);
        r.setIndex(a), (t = r.getIndex());
      } else
        return (
          console.error(
            'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
          ),
          r
        );
    }
    const n = t.count - 2,
      i = [];
    if (t)
      if (e === Ig)
        for (let a = 1; a <= n; a++) i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
      else
        for (let a = 0; a < n; a++)
          a % 2 === 0
            ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2)))
            : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n &&
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
      );
    const o = r.clone();
    return o.setIndex(i), o.clearGroups(), o;
  } else
    return (
      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', e), r
    );
}
var Ps = Uint8Array,
  El = Uint16Array,
  My = Uint32Array,
  VE = new Ps([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
  ]),
  WE = new Ps([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13,
    13, 0, 0,
  ]),
  N2 = new Ps([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
  XE = function (r, e) {
    for (var t = new El(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
    for (var i = new My(t[30]), n = 1; n < 30; ++n)
      for (var o = t[n]; o < t[n + 1]; ++o) i[o] = ((o - t[n]) << 5) | n;
    return [t, i];
  },
  JE = XE(VE, 2),
  YE = JE[0],
  U2 = JE[1];
(YE[28] = 258), (U2[258] = 28);
var O2 = XE(WE, 0),
  k2 = O2[0],
  Ey = new El(32768);
for (var ti = 0; ti < 32768; ++ti) {
  var xl = ((ti & 43690) >>> 1) | ((ti & 21845) << 1);
  (xl = ((xl & 52428) >>> 2) | ((xl & 13107) << 2)),
    (xl = ((xl & 61680) >>> 4) | ((xl & 3855) << 4)),
    (Ey[ti] = (((xl & 65280) >>> 8) | ((xl & 255) << 8)) >>> 1);
}
var _h = function (r, e, t) {
    for (var n = r.length, i = 0, o = new El(e); i < n; ++i) ++o[r[i] - 1];
    var a = new El(e);
    for (i = 0; i < e; ++i) a[i] = (a[i - 1] + o[i - 1]) << 1;
    var u;
    if (t) {
      u = new El(1 << e);
      var d = 15 - e;
      for (i = 0; i < n; ++i)
        if (r[i])
          for (
            var h = (i << 4) | r[i], m = e - r[i], g = a[r[i] - 1]++ << m, v = g | ((1 << m) - 1);
            g <= v;
            ++g
          )
            u[Ey[g] >>> d] = h;
    } else
      for (u = new El(n), i = 0; i < n; ++i) r[i] && (u[i] = Ey[a[r[i] - 1]++] >>> (15 - r[i]));
    return u;
  },
  qh = new Ps(288);
for (var ti = 0; ti < 144; ++ti) qh[ti] = 8;
for (var ti = 144; ti < 256; ++ti) qh[ti] = 9;
for (var ti = 256; ti < 280; ++ti) qh[ti] = 7;
for (var ti = 280; ti < 288; ++ti) qh[ti] = 8;
var KE = new Ps(32);
for (var ti = 0; ti < 32; ++ti) KE[ti] = 5;
var z2 = _h(qh, 9, 1),
  H2 = _h(KE, 5, 1),
  Z0 = function (r) {
    for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
    return e;
  },
  uo = function (r, e, t) {
    var n = (e / 8) | 0;
    return ((r[n] | (r[n + 1] << 8)) >> (e & 7)) & t;
  },
  Q0 = function (r, e) {
    var t = (e / 8) | 0;
    return (r[t] | (r[t + 1] << 8) | (r[t + 2] << 16)) >> (e & 7);
  },
  G2 = function (r) {
    return ((r / 8) | 0) + (r & 7 && 1);
  },
  V2 = function (r, e, t) {
    (t == null || t > r.length) && (t = r.length);
    var n = new (r instanceof El ? El : r instanceof My ? My : Ps)(t - e);
    return n.set(r.subarray(e, t)), n;
  },
  W2 = function (r, e, t) {
    var n = r.length;
    if (!n || (t && !t.l && n < 5)) return e || new Ps(0);
    var i = !e || t,
      o = !t || t.i;
    t || (t = {}), e || (e = new Ps(n * 3));
    var a = function (Ie) {
        var Ue = e.length;
        if (Ie > Ue) {
          var et = new Ps(Math.max(Ue * 2, Ie));
          et.set(e), (e = et);
        }
      },
      u = t.f || 0,
      d = t.p || 0,
      h = t.b || 0,
      m = t.l,
      g = t.d,
      v = t.m,
      x = t.n,
      A = n * 8;
    do {
      if (!m) {
        t.f = u = uo(r, d, 1);
        var C = uo(r, d + 1, 3);
        if (((d += 3), C))
          if (C == 1) (m = z2), (g = H2), (v = 9), (x = 5);
          else if (C == 2) {
            var I = uo(r, d, 31) + 257,
              B = uo(r, d + 10, 15) + 4,
              z = I + uo(r, d + 5, 31) + 1;
            d += 14;
            for (var N = new Ps(z), G = new Ps(19), k = 0; k < B; ++k)
              G[N2[k]] = uo(r, d + k * 3, 7);
            d += B * 3;
            for (var L = Z0(G), D = (1 << L) - 1, V = _h(G, L, 1), k = 0; k < z; ) {
              var oe = V[uo(r, d, D)];
              d += oe & 15;
              var E = oe >>> 4;
              if (E < 16) N[k++] = E;
              else {
                var ie = 0,
                  ce = 0;
                for (
                  E == 16
                    ? ((ce = 3 + uo(r, d, 3)), (d += 2), (ie = N[k - 1]))
                    : E == 17
                    ? ((ce = 3 + uo(r, d, 7)), (d += 3))
                    : E == 18 && ((ce = 11 + uo(r, d, 127)), (d += 7));
                  ce--;

                )
                  N[k++] = ie;
              }
            }
            var xe = N.subarray(0, I),
              de = N.subarray(I);
            (v = Z0(xe)), (x = Z0(de)), (m = _h(xe, v, 1)), (g = _h(de, x, 1));
          } else throw 'invalid block type';
        else {
          var E = G2(d) + 4,
            S = r[E - 4] | (r[E - 3] << 8),
            b = E + S;
          if (b > n) {
            if (o) throw 'unexpected EOF';
            break;
          }
          i && a(h + S), e.set(r.subarray(E, b), h), (t.b = h += S), (t.p = d = b * 8);
          continue;
        }
        if (d > A) {
          if (o) throw 'unexpected EOF';
          break;
        }
      }
      i && a(h + 131072);
      for (var Ce = (1 << v) - 1, X = (1 << x) - 1, fe = d; ; fe = d) {
        var ie = m[Q0(r, d) & Ce],
          te = ie >>> 4;
        if (((d += ie & 15), d > A)) {
          if (o) throw 'unexpected EOF';
          break;
        }
        if (!ie) throw 'invalid length/literal';
        if (te < 256) e[h++] = te;
        else if (te == 256) {
          (fe = d), (m = null);
          break;
        } else {
          var Y = te - 254;
          if (te > 264) {
            var k = te - 257,
              ue = VE[k];
            (Y = uo(r, d, (1 << ue) - 1) + YE[k]), (d += ue);
          }
          var He = g[Q0(r, d) & X],
            ge = He >>> 4;
          if (!He) throw 'invalid distance';
          d += He & 15;
          var de = k2[ge];
          if (ge > 3) {
            var ue = WE[ge];
            (de += Q0(r, d) & ((1 << ue) - 1)), (d += ue);
          }
          if (d > A) {
            if (o) throw 'unexpected EOF';
            break;
          }
          i && a(h + 131072);
          for (var De = h + Y; h < De; h += 4)
            (e[h] = e[h - de]),
              (e[h + 1] = e[h + 1 - de]),
              (e[h + 2] = e[h + 2 - de]),
              (e[h + 3] = e[h + 3 - de]);
          h = De;
        }
      }
      (t.l = m), (t.p = fe), (t.b = h), m && ((u = 1), (t.m = v), (t.d = g), (t.n = x));
    } while (!u);
    return h == e.length ? e : V2(e, 0, h);
  },
  X2 = new Ps(0),
  J2 = function (r) {
    if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || ((r[0] << 8) | r[1]) % 31) throw 'invalid zlib data';
    if (r[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
  };
function zm(r, e) {
  return W2((J2(r), r.subarray(2, -4)), e);
}
var Y2 = typeof TextDecoder < 'u' && new TextDecoder(),
  K2 = 0;
try {
  Y2.decode(X2, { stream: !0 }), (K2 = 1);
} catch {}
const j2 = (r) => r && r.isCubeTexture;
class Z2 extends oi {
  constructor(e, t) {
    var n, i;
    const o = j2(e),
      u =
        ((i = o ? ((n = e.image[0]) == null ? void 0 : n.width) : e.image.width) != null
          ? i
          : 1024) / 4,
      d = Math.floor(Math.log2(u)),
      h = Math.pow(2, d),
      m = 3 * Math.max(h, 16 * 7),
      g = 4 * h,
      v = [
        o ? '#define ENVMAP_TYPE_CUBE' : '',
        `#define CUBEUV_TEXEL_WIDTH ${1 / m}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / g}`,
        `#define CUBEUV_MAX_MIP ${d}.0`,
      ],
      x = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      A =
        v.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${M_ >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>
        }
        `,
      C = {
        map: { value: e },
        height: { value: (t == null ? void 0 : t.height) || 15 },
        radius: { value: (t == null ? void 0 : t.radius) || 100 },
      },
      E = new Jh(1, 16),
      S = new is({ uniforms: C, fragmentShader: A, vertexShader: x, side: gs });
    super(E, S);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
var Q2 = Object.defineProperty,
  q2 = (r, e, t) =>
    e in r ? Q2(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (r[e] = t),
  $2 = (r, e, t) => (q2(r, e + '', t), t);
class eD {
  constructor() {
    $2(this, '_listeners');
  }
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, a = i.length; o < a; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
var tD = Object.defineProperty,
  nD = (r, e, t) =>
    e in r ? tD(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (r[e] = t),
  Zt = (r, e, t) => (nD(r, typeof e != 'symbol' ? e + '' : e, t), t);
const Hm = new sc(),
  xS = new Ra(),
  iD = Math.cos(70 * (Math.PI / 180)),
  AS = (r, e) => ((r % e) + e) % e;
let rD = class extends eD {
  constructor(e, t) {
    super(),
      Zt(this, 'object'),
      Zt(this, 'domElement'),
      Zt(this, 'enabled', !0),
      Zt(this, 'target', new J()),
      Zt(this, 'minDistance', 0),
      Zt(this, 'maxDistance', 1 / 0),
      Zt(this, 'minZoom', 0),
      Zt(this, 'maxZoom', 1 / 0),
      Zt(this, 'minPolarAngle', 0),
      Zt(this, 'maxPolarAngle', Math.PI),
      Zt(this, 'minAzimuthAngle', -1 / 0),
      Zt(this, 'maxAzimuthAngle', 1 / 0),
      Zt(this, 'enableDamping', !1),
      Zt(this, 'dampingFactor', 0.05),
      Zt(this, 'enableZoom', !0),
      Zt(this, 'zoomSpeed', 1),
      Zt(this, 'enableRotate', !0),
      Zt(this, 'rotateSpeed', 1),
      Zt(this, 'enablePan', !0),
      Zt(this, 'panSpeed', 1),
      Zt(this, 'screenSpacePanning', !0),
      Zt(this, 'keyPanSpeed', 7),
      Zt(this, 'zoomToCursor', !1),
      Zt(this, 'autoRotate', !1),
      Zt(this, 'autoRotateSpeed', 2),
      Zt(this, 'reverseOrbit', !1),
      Zt(this, 'reverseHorizontalOrbit', !1),
      Zt(this, 'reverseVerticalOrbit', !1),
      Zt(this, 'keys', {
        LEFT: 'ArrowLeft',
        UP: 'ArrowUp',
        RIGHT: 'ArrowRight',
        BOTTOM: 'ArrowDown',
      }),
      Zt(this, 'mouseButtons', { LEFT: Du.ROTATE, MIDDLE: Du.DOLLY, RIGHT: Du.PAN }),
      Zt(this, 'touches', { ONE: Lu.ROTATE, TWO: Lu.DOLLY_PAN }),
      Zt(this, 'target0'),
      Zt(this, 'position0'),
      Zt(this, 'zoom0'),
      Zt(this, '_domElementKeyEvents', null),
      Zt(this, 'getPolarAngle'),
      Zt(this, 'getAzimuthalAngle'),
      Zt(this, 'setPolarAngle'),
      Zt(this, 'setAzimuthalAngle'),
      Zt(this, 'getDistance'),
      Zt(this, 'getZoomScale'),
      Zt(this, 'listenToKeyEvents'),
      Zt(this, 'stopListenToKeyEvents'),
      Zt(this, 'saveState'),
      Zt(this, 'reset'),
      Zt(this, 'update'),
      Zt(this, 'connect'),
      Zt(this, 'dispose'),
      Zt(this, 'dollyIn'),
      Zt(this, 'dollyOut'),
      Zt(this, 'getScale'),
      Zt(this, 'setScale'),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => m.phi),
      (this.getAzimuthalAngle = () => m.theta),
      (this.setPolarAngle = (re) => {
        let Re = AS(re, 2 * Math.PI),
          tt = m.phi;
        tt < 0 && (tt += 2 * Math.PI), Re < 0 && (Re += 2 * Math.PI);
        let ne = Math.abs(Re - tt);
        2 * Math.PI - ne < ne && (Re < tt ? (Re += 2 * Math.PI) : (tt += 2 * Math.PI)),
          (g.phi = Re - tt),
          n.update();
      }),
      (this.setAzimuthalAngle = (re) => {
        let Re = AS(re, 2 * Math.PI),
          tt = m.theta;
        tt < 0 && (tt += 2 * Math.PI), Re < 0 && (Re += 2 * Math.PI);
        let ne = Math.abs(Re - tt);
        2 * Math.PI - ne < ne && (Re < tt ? (Re += 2 * Math.PI) : (tt += 2 * Math.PI)),
          (g.theta = Re - tt),
          n.update();
      }),
      (this.getDistance = () => n.object.position.distanceTo(n.target)),
      (this.listenToKeyEvents = (re) => {
        re.addEventListener('keydown', at), (this._domElementKeyEvents = re);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener('keydown', at),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        n.target0.copy(n.target), n.position0.copy(n.object.position), (n.zoom0 = n.object.zoom);
      }),
      (this.reset = () => {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(i),
          n.update(),
          (d = u.NONE);
      }),
      (this.update = (() => {
        const re = new J(),
          Re = new J(0, 1, 0),
          tt = new ji().setFromUnitVectors(e.up, Re),
          ne = tt.clone().invert(),
          ye = new J(),
          we = new ji(),
          Oe = 2 * Math.PI;
        return function () {
          const dt = n.object.position;
          tt.setFromUnitVectors(e.up, Re),
            ne.copy(tt).invert(),
            re.copy(dt).sub(n.target),
            re.applyQuaternion(tt),
            m.setFromVector3(re),
            n.autoRotate && d === u.NONE && ce(oe()),
            n.enableDamping
              ? ((m.theta += g.theta * n.dampingFactor), (m.phi += g.phi * n.dampingFactor))
              : ((m.theta += g.theta), (m.phi += g.phi));
          let Gt = n.minAzimuthAngle,
            _n = n.maxAzimuthAngle;
          isFinite(Gt) &&
            isFinite(_n) &&
            (Gt < -Math.PI ? (Gt += Oe) : Gt > Math.PI && (Gt -= Oe),
            _n < -Math.PI ? (_n += Oe) : _n > Math.PI && (_n -= Oe),
            Gt <= _n
              ? (m.theta = Math.max(Gt, Math.min(_n, m.theta)))
              : (m.theta =
                  m.theta > (Gt + _n) / 2 ? Math.max(Gt, m.theta) : Math.min(_n, m.theta))),
            (m.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, m.phi))),
            m.makeSafe(),
            n.enableDamping === !0 ? n.target.addScaledVector(x, n.dampingFactor) : n.target.add(x),
            (n.zoomToCursor && L) || n.object.isOrthographicCamera
              ? (m.radius = He(m.radius))
              : (m.radius = He(m.radius * v)),
            re.setFromSpherical(m),
            re.applyQuaternion(ne),
            dt.copy(n.target).add(re),
            n.object.matrixAutoUpdate || n.object.updateMatrix(),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((g.theta *= 1 - n.dampingFactor),
                (g.phi *= 1 - n.dampingFactor),
                x.multiplyScalar(1 - n.dampingFactor))
              : (g.set(0, 0, 0), x.set(0, 0, 0));
          let Nn = !1;
          if (n.zoomToCursor && L) {
            let an = null;
            if (n.object instanceof gi && n.object.isPerspectiveCamera) {
              const qn = re.length();
              an = He(qn * v);
              const ni = qn - an;
              n.object.position.addScaledVector(G, ni), n.object.updateMatrixWorld();
            } else if (n.object.isOrthographicCamera) {
              const qn = new J(k.x, k.y, 0);
              qn.unproject(n.object),
                (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / v))),
                n.object.updateProjectionMatrix(),
                (Nn = !0);
              const ni = new J(k.x, k.y, 0);
              ni.unproject(n.object),
                n.object.position.sub(ni).add(qn),
                n.object.updateMatrixWorld(),
                (an = re.length());
            } else
              console.warn(
                'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.',
              ),
                (n.zoomToCursor = !1);
            an !== null &&
              (n.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(an)
                    .add(n.object.position)
                : (Hm.origin.copy(n.object.position),
                  Hm.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(Hm.direction)) < iD
                    ? e.lookAt(n.target)
                    : (xS.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      Hm.intersectPlane(xS, n.target))));
          } else
            n.object instanceof No &&
              n.object.isOrthographicCamera &&
              ((Nn = v !== 1),
              Nn &&
                ((n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / v))),
                n.object.updateProjectionMatrix()));
          return (
            (v = 1),
            (L = !1),
            Nn ||
            ye.distanceToSquared(n.object.position) > h ||
            8 * (1 - we.dot(n.object.quaternion)) > h
              ? (n.dispatchEvent(i),
                ye.copy(n.object.position),
                we.copy(n.object.quaternion),
                (Nn = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (re) => {
        (n.domElement = re),
          (n.domElement.style.touchAction = 'none'),
          n.domElement.addEventListener('contextmenu', Ze),
          n.domElement.addEventListener('pointerdown', H),
          n.domElement.addEventListener('pointercancel', Le),
          n.domElement.addEventListener('wheel', Ct);
      }),
      (this.dispose = () => {
        var re, Re, tt, ne, ye, we;
        n.domElement && (n.domElement.style.touchAction = 'auto'),
          (re = n.domElement) == null || re.removeEventListener('contextmenu', Ze),
          (Re = n.domElement) == null || Re.removeEventListener('pointerdown', H),
          (tt = n.domElement) == null || tt.removeEventListener('pointercancel', Le),
          (ne = n.domElement) == null || ne.removeEventListener('wheel', Ct),
          (ye = n.domElement) == null || ye.ownerDocument.removeEventListener('pointermove', ve),
          (we = n.domElement) == null || we.ownerDocument.removeEventListener('pointerup', Le),
          n._domElementKeyEvents !== null &&
            n._domElementKeyEvents.removeEventListener('keydown', at);
      });
    const n = this,
      i = { type: 'change' },
      o = { type: 'start' },
      a = { type: 'end' },
      u = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let d = u.NONE;
    const h = 1e-6,
      m = new vy(),
      g = new vy();
    let v = 1;
    const x = new J(),
      A = new Ge(),
      C = new Ge(),
      E = new Ge(),
      S = new Ge(),
      b = new Ge(),
      I = new Ge(),
      B = new Ge(),
      z = new Ge(),
      N = new Ge(),
      G = new J(),
      k = new Ge();
    let L = !1;
    const D = [],
      V = {};
    function oe() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function ie() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function ce(re) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? (g.theta += re) : (g.theta -= re);
    }
    function xe(re) {
      n.reverseOrbit || n.reverseVerticalOrbit ? (g.phi += re) : (g.phi -= re);
    }
    const de = (() => {
        const re = new J();
        return function (tt, ne) {
          re.setFromMatrixColumn(ne, 0), re.multiplyScalar(-tt), x.add(re);
        };
      })(),
      Ce = (() => {
        const re = new J();
        return function (tt, ne) {
          n.screenSpacePanning === !0
            ? re.setFromMatrixColumn(ne, 1)
            : (re.setFromMatrixColumn(ne, 0), re.crossVectors(n.object.up, re)),
            re.multiplyScalar(tt),
            x.add(re);
        };
      })(),
      X = (() => {
        const re = new J();
        return function (tt, ne) {
          const ye = n.domElement;
          if (ye && n.object instanceof gi && n.object.isPerspectiveCamera) {
            const we = n.object.position;
            re.copy(we).sub(n.target);
            let Oe = re.length();
            (Oe *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              de((2 * tt * Oe) / ye.clientHeight, n.object.matrix),
              Ce((2 * ne * Oe) / ye.clientHeight, n.object.matrix);
          } else
            ye && n.object instanceof No && n.object.isOrthographicCamera
              ? (de(
                  (tt * (n.object.right - n.object.left)) / n.object.zoom / ye.clientWidth,
                  n.object.matrix,
                ),
                Ce(
                  (ne * (n.object.top - n.object.bottom)) / n.object.zoom / ye.clientHeight,
                  n.object.matrix,
                ))
              : (console.warn(
                  'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.',
                ),
                (n.enablePan = !1));
        };
      })();
    function fe(re) {
      (n.object instanceof gi && n.object.isPerspectiveCamera) ||
      (n.object instanceof No && n.object.isOrthographicCamera)
        ? (v = re)
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
          ),
          (n.enableZoom = !1));
    }
    function te(re) {
      fe(v / re);
    }
    function Y(re) {
      fe(v * re);
    }
    function ue(re) {
      if (!n.zoomToCursor || !n.domElement) return;
      L = !0;
      const Re = n.domElement.getBoundingClientRect(),
        tt = re.clientX - Re.left,
        ne = re.clientY - Re.top,
        ye = Re.width,
        we = Re.height;
      (k.x = (tt / ye) * 2 - 1),
        (k.y = -(ne / we) * 2 + 1),
        G.set(k.x, k.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function He(re) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, re));
    }
    function ge(re) {
      A.set(re.clientX, re.clientY);
    }
    function De(re) {
      ue(re), B.set(re.clientX, re.clientY);
    }
    function Ie(re) {
      S.set(re.clientX, re.clientY);
    }
    function Ue(re) {
      C.set(re.clientX, re.clientY), E.subVectors(C, A).multiplyScalar(n.rotateSpeed);
      const Re = n.domElement;
      Re && (ce((2 * Math.PI * E.x) / Re.clientHeight), xe((2 * Math.PI * E.y) / Re.clientHeight)),
        A.copy(C),
        n.update();
    }
    function et(re) {
      z.set(re.clientX, re.clientY),
        N.subVectors(z, B),
        N.y > 0 ? te(ie()) : N.y < 0 && Y(ie()),
        B.copy(z),
        n.update();
    }
    function Bt(re) {
      b.set(re.clientX, re.clientY),
        I.subVectors(b, S).multiplyScalar(n.panSpeed),
        X(I.x, I.y),
        S.copy(b),
        n.update();
    }
    function ht(re) {
      ue(re), re.deltaY < 0 ? Y(ie()) : re.deltaY > 0 && te(ie()), n.update();
    }
    function Jt(re) {
      let Re = !1;
      switch (re.code) {
        case n.keys.UP:
          X(0, n.keyPanSpeed), (Re = !0);
          break;
        case n.keys.BOTTOM:
          X(0, -n.keyPanSpeed), (Re = !0);
          break;
        case n.keys.LEFT:
          X(n.keyPanSpeed, 0), (Re = !0);
          break;
        case n.keys.RIGHT:
          X(-n.keyPanSpeed, 0), (Re = !0);
          break;
      }
      Re && (re.preventDefault(), n.update());
    }
    function Ye() {
      if (D.length == 1) A.set(D[0].pageX, D[0].pageY);
      else {
        const re = 0.5 * (D[0].pageX + D[1].pageX),
          Re = 0.5 * (D[0].pageY + D[1].pageY);
        A.set(re, Re);
      }
    }
    function ke() {
      if (D.length == 1) S.set(D[0].pageX, D[0].pageY);
      else {
        const re = 0.5 * (D[0].pageX + D[1].pageX),
          Re = 0.5 * (D[0].pageY + D[1].pageY);
        S.set(re, Re);
      }
    }
    function j() {
      const re = D[0].pageX - D[1].pageX,
        Re = D[0].pageY - D[1].pageY,
        tt = Math.sqrt(re * re + Re * Re);
      B.set(0, tt);
    }
    function It() {
      n.enableZoom && j(), n.enablePan && ke();
    }
    function qe() {
      n.enableZoom && j(), n.enableRotate && Ye();
    }
    function yt(re) {
      if (D.length == 1) C.set(re.pageX, re.pageY);
      else {
        const tt = St(re),
          ne = 0.5 * (re.pageX + tt.x),
          ye = 0.5 * (re.pageY + tt.y);
        C.set(ne, ye);
      }
      E.subVectors(C, A).multiplyScalar(n.rotateSpeed);
      const Re = n.domElement;
      Re && (ce((2 * Math.PI * E.x) / Re.clientHeight), xe((2 * Math.PI * E.y) / Re.clientHeight)),
        A.copy(C);
    }
    function rt(re) {
      if (D.length == 1) b.set(re.pageX, re.pageY);
      else {
        const Re = St(re),
          tt = 0.5 * (re.pageX + Re.x),
          ne = 0.5 * (re.pageY + Re.y);
        b.set(tt, ne);
      }
      I.subVectors(b, S).multiplyScalar(n.panSpeed), X(I.x, I.y), S.copy(b);
    }
    function Ht(re) {
      const Re = St(re),
        tt = re.pageX - Re.x,
        ne = re.pageY - Re.y,
        ye = Math.sqrt(tt * tt + ne * ne);
      z.set(0, ye), N.set(0, Math.pow(z.y / B.y, n.zoomSpeed)), te(N.y), B.copy(z);
    }
    function lt(re) {
      n.enableZoom && Ht(re), n.enablePan && rt(re);
    }
    function K(re) {
      n.enableZoom && Ht(re), n.enableRotate && yt(re);
    }
    function H(re) {
      var Re, tt;
      n.enabled !== !1 &&
        (D.length === 0 &&
          ((Re = n.domElement) == null || Re.ownerDocument.addEventListener('pointermove', ve),
          (tt = n.domElement) == null || tt.ownerDocument.addEventListener('pointerup', Le)),
        wt(re),
        re.pointerType === 'touch' ? pt(re) : We(re));
    }
    function ve(re) {
      n.enabled !== !1 && (re.pointerType === 'touch' ? $t(re) : ze(re));
    }
    function Le(re) {
      var Re, tt, ne;
      Ft(re),
        D.length === 0 &&
          ((Re = n.domElement) == null || Re.releasePointerCapture(re.pointerId),
          (tt = n.domElement) == null || tt.ownerDocument.removeEventListener('pointermove', ve),
          (ne = n.domElement) == null || ne.ownerDocument.removeEventListener('pointerup', Le)),
        n.dispatchEvent(a),
        (d = u.NONE);
    }
    function We(re) {
      let Re;
      switch (re.button) {
        case 0:
          Re = n.mouseButtons.LEFT;
          break;
        case 1:
          Re = n.mouseButtons.MIDDLE;
          break;
        case 2:
          Re = n.mouseButtons.RIGHT;
          break;
        default:
          Re = -1;
      }
      switch (Re) {
        case Du.DOLLY:
          if (n.enableZoom === !1) return;
          De(re), (d = u.DOLLY);
          break;
        case Du.ROTATE:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (n.enablePan === !1) return;
            Ie(re), (d = u.PAN);
          } else {
            if (n.enableRotate === !1) return;
            ge(re), (d = u.ROTATE);
          }
          break;
        case Du.PAN:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (n.enableRotate === !1) return;
            ge(re), (d = u.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            Ie(re), (d = u.PAN);
          }
          break;
        default:
          d = u.NONE;
      }
      d !== u.NONE && n.dispatchEvent(o);
    }
    function ze(re) {
      if (n.enabled !== !1)
        switch (d) {
          case u.ROTATE:
            if (n.enableRotate === !1) return;
            Ue(re);
            break;
          case u.DOLLY:
            if (n.enableZoom === !1) return;
            et(re);
            break;
          case u.PAN:
            if (n.enablePan === !1) return;
            Bt(re);
            break;
        }
    }
    function Ct(re) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        (d !== u.NONE && d !== u.ROTATE) ||
        (re.preventDefault(), n.dispatchEvent(o), ht(re), n.dispatchEvent(a));
    }
    function at(re) {
      n.enabled === !1 || n.enablePan === !1 || Jt(re);
    }
    function pt(re) {
      switch ((Rt(re), D.length)) {
        case 1:
          switch (n.touches.ONE) {
            case Lu.ROTATE:
              if (n.enableRotate === !1) return;
              Ye(), (d = u.TOUCH_ROTATE);
              break;
            case Lu.PAN:
              if (n.enablePan === !1) return;
              ke(), (d = u.TOUCH_PAN);
              break;
            default:
              d = u.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Lu.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              It(), (d = u.TOUCH_DOLLY_PAN);
              break;
            case Lu.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              qe(), (d = u.TOUCH_DOLLY_ROTATE);
              break;
            default:
              d = u.NONE;
          }
          break;
        default:
          d = u.NONE;
      }
      d !== u.NONE && n.dispatchEvent(o);
    }
    function $t(re) {
      switch ((Rt(re), d)) {
        case u.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          yt(re), n.update();
          break;
        case u.TOUCH_PAN:
          if (n.enablePan === !1) return;
          rt(re), n.update();
          break;
        case u.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          lt(re), n.update();
          break;
        case u.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          K(re), n.update();
          break;
        default:
          d = u.NONE;
      }
    }
    function Ze(re) {
      n.enabled !== !1 && re.preventDefault();
    }
    function wt(re) {
      D.push(re);
    }
    function Ft(re) {
      delete V[re.pointerId];
      for (let Re = 0; Re < D.length; Re++)
        if (D[Re].pointerId == re.pointerId) {
          D.splice(Re, 1);
          return;
        }
    }
    function Rt(re) {
      let Re = V[re.pointerId];
      Re === void 0 && ((Re = new Ge()), (V[re.pointerId] = Re)), Re.set(re.pageX, re.pageY);
    }
    function St(re) {
      const Re = re.pointerId === D[0].pointerId ? D[1] : D[0];
      return V[Re.pointerId];
    }
    (this.dollyIn = (re = ie()) => {
      Y(re), n.update();
    }),
      (this.dollyOut = (re = ie()) => {
        te(re), n.update();
      }),
      (this.getScale = () => v),
      (this.setScale = (re) => {
        fe(re), n.update();
      }),
      (this.getZoomScale = () => ie()),
      t !== void 0 && this.connect(t),
      this.update();
  }
};
function Fg(r) {
  if (typeof TextDecoder < 'u') return new TextDecoder().decode(r);
  let e = '';
  for (let t = 0, n = r.length; t < n; t++) e += String.fromCharCode(r[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const Xu = 'srgb',
  La = 'srgb-linear',
  SS = 3001,
  sD = 3e3;
class E_ extends lr {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new cD(t);
      }),
      this.register(function (t) {
        return new fD(t);
      }),
      this.register(function (t) {
        return new xD(t);
      }),
      this.register(function (t) {
        return new AD(t);
      }),
      this.register(function (t) {
        return new SD(t);
      }),
      this.register(function (t) {
        return new hD(t);
      }),
      this.register(function (t) {
        return new pD(t);
      }),
      this.register(function (t) {
        return new mD(t);
      }),
      this.register(function (t) {
        return new gD(t);
      }),
      this.register(function (t) {
        return new uD(t);
      }),
      this.register(function (t) {
        return new vD(t);
      }),
      this.register(function (t) {
        return new dD(t);
      }),
      this.register(function (t) {
        return new _D(t);
      }),
      this.register(function (t) {
        return new yD(t);
      }),
      this.register(function (t) {
        return new aD(t);
      }),
      this.register(function (t) {
        return new MD(t);
      }),
      this.register(function (t) {
        return new ED(t);
      });
  }
  load(e, t, n, i) {
    const o = this;
    let a;
    if (this.resourcePath !== '') a = this.resourcePath;
    else if (this.path !== '') {
      const h = wl.extractUrlBase(e);
      a = wl.resolveURL(h, this.path);
    } else a = wl.extractUrlBase(e);
    this.manager.itemStart(e);
    const u = function (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e), o.manager.itemEnd(e);
      },
      d = new ar(this.manager);
    d.setPath(this.path),
      d.setResponseType('arraybuffer'),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(this.withCredentials),
      d.load(
        e,
        function (h) {
          try {
            o.parse(
              h,
              a,
              function (m) {
                t(m), o.manager.itemEnd(e);
              },
              u,
            );
          } catch (m) {
            u(m);
          }
        },
        n,
        u,
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let o;
    const a = {},
      u = {};
    if (typeof e == 'string') o = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Fg(new Uint8Array(e.slice(0, 4))) === jE) {
        try {
          a[Sn.KHR_BINARY_GLTF] = new wD(e);
        } catch (m) {
          i && i(m);
          return;
        }
        o = JSON.parse(a[Sn.KHR_BINARY_GLTF].content);
      } else o = JSON.parse(Fg(new Uint8Array(e)));
    else o = e;
    if (o.asset === void 0 || o.asset.version[0] < 2) {
      i && i(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
      return;
    }
    const d = new OD(o, {
      path: t || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    d.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const m = this.pluginCallbacks[h](d);
      m.name || console.error('THREE.GLTFLoader: Invalid plugin found: missing name'),
        (u[m.name] = m),
        (a[m.name] = !0);
    }
    if (o.extensionsUsed)
      for (let h = 0; h < o.extensionsUsed.length; ++h) {
        const m = o.extensionsUsed[h],
          g = o.extensionsRequired || [];
        switch (m) {
          case Sn.KHR_MATERIALS_UNLIT:
            a[m] = new lD();
            break;
          case Sn.KHR_DRACO_MESH_COMPRESSION:
            a[m] = new CD(o, this.dracoLoader);
            break;
          case Sn.KHR_TEXTURE_TRANSFORM:
            a[m] = new TD();
            break;
          case Sn.KHR_MESH_QUANTIZATION:
            a[m] = new RD();
            break;
          default:
            g.indexOf(m) >= 0 &&
              u[m] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + m + '".');
        }
      }
    d.setExtensions(a), d.setPlugins(u), d.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, o) {
      n.parse(e, t, i, o);
    });
  }
}
function oD() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    },
  };
}
const Sn = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',
};
class aD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n];
      o.extensions &&
        o.extensions[this.name] &&
        o.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, o.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = 'light:' + e;
    let i = t.cache.get(n);
    if (i) return i;
    const o = t.json,
      d = (((o.extensions && o.extensions[this.name]) || {}).lights || [])[e];
    let h;
    const m = new At(16777215);
    d.color !== void 0 && m.setRGB(d.color[0], d.color[1], d.color[2], La);
    const g = d.range !== void 0 ? d.range : 0;
    switch (d.type) {
      case 'directional':
        (h = new u_(m)), h.target.position.set(0, 0, -1), h.add(h.target);
        break;
      case 'point':
        (h = new l_(m)), (h.distance = g);
        break;
      case 'spot':
        (h = new a_(m)),
          (h.distance = g),
          (d.spot = d.spot || {}),
          (d.spot.innerConeAngle = d.spot.innerConeAngle !== void 0 ? d.spot.innerConeAngle : 0),
          (d.spot.outerConeAngle =
            d.spot.outerConeAngle !== void 0 ? d.spot.outerConeAngle : Math.PI / 4),
          (h.angle = d.spot.outerConeAngle),
          (h.penumbra = 1 - d.spot.innerConeAngle / d.spot.outerConeAngle),
          h.target.position.set(0, 0, -1),
          h.add(h.target);
        break;
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + d.type);
    }
    return (
      h.position.set(0, 0, 0),
      (h.decay = 2),
      Ta(h, d),
      d.intensity !== void 0 && (h.intensity = d.intensity),
      (h.name = t.createUniqueName(d.name || 'light_' + e)),
      (i = Promise.resolve(h)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === 'light') return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      o = n.json.nodes[e],
      u = ((o.extensions && o.extensions[this.name]) || {}).light;
    return u === void 0
      ? null
      : this._loadLight(u).then(function (d) {
          return n._getNodeRef(t.cache, u, d);
        });
  }
}
class lD {
  constructor() {
    this.name = Sn.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ts;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new At(1, 1, 1)), (e.opacity = 1);
    const o = t.pbrMetallicRoughness;
    if (o) {
      if (Array.isArray(o.baseColorFactor)) {
        const a = o.baseColorFactor;
        e.color.setRGB(a[0], a[1], a[2], La), (e.opacity = a[3]);
      }
      o.baseColorTexture !== void 0 && i.push(n.assignTexture(e, 'map', o.baseColorTexture, Xu));
    }
    return Promise.all(i);
  }
}
class uD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = i.extensions[this.name].emissiveStrength;
    return o !== void 0 && (t.emissiveIntensity = o), Promise.resolve();
  }
}
class cD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        o.push(n.assignTexture(t, 'clearcoatMap', a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        o.push(n.assignTexture(t, 'clearcoatRoughnessMap', a.clearcoatRoughnessTexture)),
      a.clearcoatNormalTexture !== void 0 &&
        (o.push(n.assignTexture(t, 'clearcoatNormalMap', a.clearcoatNormalTexture)),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const u = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ge(u, u);
    }
    return Promise.all(o);
  }
}
class fD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_DISPERSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = i.extensions[this.name];
    return (t.dispersion = o.dispersion !== void 0 ? o.dispersion : 0), Promise.resolve();
  }
}
class dD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        o.push(n.assignTexture(t, 'iridescenceMap', a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        o.push(n.assignTexture(t, 'iridescenceThicknessMap', a.iridescenceThicknessTexture)),
      Promise.all(o)
    );
  }
}
class hD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [];
    (t.sheenColor = new At(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = i.extensions[this.name];
    if (a.sheenColorFactor !== void 0) {
      const u = a.sheenColorFactor;
      t.sheenColor.setRGB(u[0], u[1], u[2], La);
    }
    return (
      a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        o.push(n.assignTexture(t, 'sheenColorMap', a.sheenColorTexture, Xu)),
      a.sheenRoughnessTexture !== void 0 &&
        o.push(n.assignTexture(t, 'sheenRoughnessMap', a.sheenRoughnessTexture)),
      Promise.all(o)
    );
  }
}
class pD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        o.push(n.assignTexture(t, 'transmissionMap', a.transmissionTexture)),
      Promise.all(o)
    );
  }
}
class mD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        o.push(n.assignTexture(t, 'thicknessMap', a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const u = a.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new At().setRGB(u[0], u[1], u[2], La)), Promise.all(o);
  }
}
class gD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = i.extensions[this.name];
    return (t.ior = o.ior !== void 0 ? o.ior : 1.5), Promise.resolve();
  }
}
class vD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        o.push(n.assignTexture(t, 'specularIntensityMap', a.specularTexture));
    const u = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new At().setRGB(u[0], u[1], u[2], La)),
      a.specularColorTexture !== void 0 &&
        o.push(n.assignTexture(t, 'specularColorMap', a.specularColorTexture, Xu)),
      Promise.all(o)
    );
  }
}
class yD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.EXT_MATERIALS_BUMP);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    return (
      (t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1),
      a.bumpTexture !== void 0 && o.push(n.assignTexture(t, 'bumpMap', a.bumpTexture)),
      Promise.all(o)
    );
  }
}
class _D {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ns;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const o = [],
      a = i.extensions[this.name];
    return (
      a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength),
      a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation),
      a.anisotropyTexture !== void 0 &&
        o.push(n.assignTexture(t, 'anisotropyMap', a.anisotropyTexture)),
      Promise.all(o)
    );
  }
}
class xD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const o = i.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
        );
      return null;
    }
    return t.loadTextureImage(e, o.source, a);
  }
}
class AD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.EXT_TEXTURE_WEBP), (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      o = i.textures[e];
    if (!o.extensions || !o.extensions[t]) return null;
    const a = o.extensions[t],
      u = i.images[a.source];
    let d = n.textureLoader;
    if (u.uri) {
      const h = n.options.manager.getHandler(u.uri);
      h !== null && (d = h);
    }
    return this.detectSupport().then(function (h) {
      if (h) return n.loadTextureImage(e, a.source, d);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class SD {
  constructor(e) {
    (this.parser = e), (this.name = Sn.EXT_TEXTURE_AVIF), (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      o = i.textures[e];
    if (!o.extensions || !o.extensions[t]) return null;
    const a = o.extensions[t],
      u = i.images[a.source];
    let d = n.textureLoader;
    if (u.uri) {
      const h = n.options.manager.getHandler(u.uri);
      h !== null && (d = h);
    }
    return this.detectSupport().then(function (h) {
      if (h) return n.loadTextureImage(e, a.source, d);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.');
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class MD {
  constructor(e) {
    (this.name = Sn.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        o = this.parser.getDependency('buffer', i.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
          );
        return null;
      }
      return o.then(function (u) {
        const d = i.byteOffset || 0,
          h = i.byteLength || 0,
          m = i.count,
          g = i.byteStride,
          v = new Uint8Array(u, d, h);
        return a.decodeGltfBufferAsync
          ? a.decodeGltfBufferAsync(m, g, v, i.mode, i.filter).then(function (x) {
              return x.buffer;
            })
          : a.ready.then(function () {
              const x = new ArrayBuffer(m * g);
              return a.decodeGltfBuffer(new Uint8Array(x), m, g, v, i.mode, i.filter), x;
            });
      });
    } else return null;
  }
}
class ED {
  constructor(e) {
    (this.name = Sn.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
    const i = t.meshes[n.mesh];
    for (const h of i.primitives)
      if (
        h.mode !== Bs.TRIANGLES &&
        h.mode !== Bs.TRIANGLE_STRIP &&
        h.mode !== Bs.TRIANGLE_FAN &&
        h.mode !== void 0
      )
        return null;
    const a = n.extensions[this.name].attributes,
      u = [],
      d = {};
    for (const h in a)
      u.push(this.parser.getDependency('accessor', a[h]).then((m) => ((d[h] = m), d[h])));
    return u.length < 1
      ? null
      : (u.push(this.parser.createNodeMesh(e)),
        Promise.all(u).then((h) => {
          const m = h.pop(),
            g = m.isGroup ? m.children : [m],
            v = h[0].count,
            x = [];
          for (const A of g) {
            const C = new Qt(),
              E = new J(),
              S = new ji(),
              b = new J(1, 1, 1),
              I = new Wy(A.geometry, A.material, v);
            for (let B = 0; B < v; B++)
              d.TRANSLATION && E.fromBufferAttribute(d.TRANSLATION, B),
                d.ROTATION && S.fromBufferAttribute(d.ROTATION, B),
                d.SCALE && b.fromBufferAttribute(d.SCALE, B),
                I.setMatrixAt(B, C.compose(E, S, b));
            for (const B in d)
              if (B === '_COLOR_0') {
                const z = d[B];
                I.instanceColor = new ec(z.array, z.itemSize, z.normalized);
              } else
                B !== 'TRANSLATION' &&
                  B !== 'ROTATION' &&
                  B !== 'SCALE' &&
                  A.geometry.setAttribute(B, d[B]);
            wn.prototype.copy.call(I, A), this.parser.assignFinalMaterial(I), x.push(I);
          }
          return m.isGroup ? (m.clear(), m.add(...x), m) : x[0];
        }));
  }
}
const jE = 'glTF',
  rh = 12,
  MS = { JSON: 1313821514, BIN: 5130562 };
class wD {
  constructor(e) {
    (this.name = Sn.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, rh);
    if (
      ((this.header = {
        magic: Fg(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== jE)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
    const n = this.header.length - rh,
      i = new DataView(e, rh);
    let o = 0;
    for (; o < n; ) {
      const a = i.getUint32(o, !0);
      o += 4;
      const u = i.getUint32(o, !0);
      if (((o += 4), u === MS.JSON)) {
        const d = new Uint8Array(e, rh + o, a);
        this.content = Fg(d);
      } else if (u === MS.BIN) {
        const d = rh + o;
        this.body = e.slice(d, d + a);
      }
      o += a;
    }
    if (this.content === null) throw new Error('THREE.GLTFLoader: JSON content not found.');
  }
}
class CD {
  constructor(e, t) {
    if (!t) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    (this.name = Sn.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      o = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      u = {},
      d = {},
      h = {};
    for (const m in a) {
      const g = wy[m] || m.toLowerCase();
      u[g] = a[m];
    }
    for (const m in e.attributes) {
      const g = wy[m] || m.toLowerCase();
      if (a[m] !== void 0) {
        const v = n.accessors[e.attributes[m]],
          x = Lf[v.componentType];
        (h[g] = x.name), (d[g] = v.normalized === !0);
      }
    }
    return t.getDependency('bufferView', o).then(function (m) {
      return new Promise(function (g, v) {
        i.decodeDracoFile(
          m,
          function (x) {
            for (const A in x.attributes) {
              const C = x.attributes[A],
                E = d[A];
              E !== void 0 && (C.normalized = E);
            }
            g(x);
          },
          u,
          h,
          La,
          v,
        );
      });
    });
  }
}
class TD {
  constructor() {
    this.name = Sn.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class RD {
  constructor() {
    this.name = Sn.KHR_MESH_QUANTIZATION;
  }
}
class ZE extends Yf {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      o = e * i * 3 + i;
    for (let a = 0; a !== i; a++) t[a] = n[o + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const o = this.resultBuffer,
      a = this.sampleValues,
      u = this.valueSize,
      d = u * 2,
      h = u * 3,
      m = i - t,
      g = (n - t) / m,
      v = g * g,
      x = v * g,
      A = e * h,
      C = A - h,
      E = -2 * x + 3 * v,
      S = x - v,
      b = 1 - E,
      I = S - v + g;
    for (let B = 0; B !== u; B++) {
      const z = a[C + B + u],
        N = a[C + B + d] * m,
        G = a[A + B + u],
        k = a[A + B] * m;
      o[B] = b * z + I * N + E * G + S * k;
    }
    return o;
  }
}
const bD = new ji();
class ID extends ZE {
  interpolate_(e, t, n, i) {
    const o = super.interpolate_(e, t, n, i);
    return bD.fromArray(o).normalize().toArray(o), o;
  }
}
const Bs = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Lf = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  ES = { 9728: Ki, 9729: Fn, 9984: Og, 9985: Pf, 9986: Ou, 9987: Ds },
  wS = { 33071: Ai, 33648: Uf, 10497: Rl },
  q0 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  wy = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    ...(M_ >= 152
      ? { TEXCOORD_0: 'uv', TEXCOORD_1: 'uv1', TEXCOORD_2: 'uv2', TEXCOORD_3: 'uv3' }
      : { TEXCOORD_0: 'uv', TEXCOORD_1: 'uv2' }),
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex',
  },
  Al = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences',
  },
  BD = { CUBICSPLINE: void 0, LINEAR: zf, STEP: kf },
  $0 = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' };
function PD(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new jh({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Uo,
      })),
    r.DefaultMaterial
  );
}
function Pu(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function Ta(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == 'object'
      ? Object.assign(r.userData, e.extras)
      : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras));
}
function DD(r, e, t) {
  let n = !1,
    i = !1,
    o = !1;
  for (let h = 0, m = e.length; h < m; h++) {
    const g = e[h];
    if (
      (g.POSITION !== void 0 && (n = !0),
      g.NORMAL !== void 0 && (i = !0),
      g.COLOR_0 !== void 0 && (o = !0),
      n && i && o)
    )
      break;
  }
  if (!n && !i && !o) return Promise.resolve(r);
  const a = [],
    u = [],
    d = [];
  for (let h = 0, m = e.length; h < m; h++) {
    const g = e[h];
    if (n) {
      const v =
        g.POSITION !== void 0 ? t.getDependency('accessor', g.POSITION) : r.attributes.position;
      a.push(v);
    }
    if (i) {
      const v = g.NORMAL !== void 0 ? t.getDependency('accessor', g.NORMAL) : r.attributes.normal;
      u.push(v);
    }
    if (o) {
      const v = g.COLOR_0 !== void 0 ? t.getDependency('accessor', g.COLOR_0) : r.attributes.color;
      d.push(v);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(u), Promise.all(d)]).then(function (h) {
    const m = h[0],
      g = h[1],
      v = h[2];
    return (
      n && (r.morphAttributes.position = m),
      i && (r.morphAttributes.normal = g),
      o && (r.morphAttributes.color = v),
      (r.morphTargetsRelative = !0),
      r
    );
  });
}
function LD(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++) r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++) r.morphTargetDictionary[t[n]] = n;
    } else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
  }
}
function FD(r) {
  let e;
  const t = r.extensions && r.extensions[Sn.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = 'draco:' + t.bufferView + ':' + t.indices + ':' + ey(t.attributes))
      : (e = r.indices + ':' + ey(r.attributes) + ':' + r.mode),
    r.targets !== void 0)
  )
    for (let n = 0, i = r.targets.length; n < i; n++) e += ':' + ey(r.targets[n]);
  return e;
}
function ey(r) {
  let e = '';
  const t = Object.keys(r).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ':' + r[t[n]] + ';';
  return e;
}
function Cy(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
  }
}
function ND(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? 'image/jpeg'
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? 'image/webp'
    : 'image/png';
}
const UD = new Qt();
class OD {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new oD()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      o = -1;
    typeof navigator < 'u' &&
      typeof navigator.userAgent < 'u' &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf('Firefox') > -1),
      (o = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > 'u' || n || (i && o < 98)
        ? (this.textureLoader = new Zh(this.options.manager))
        : (this.textureLoader = new uE(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new ar(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      this.options.crossOrigin === 'use-credentials' && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      o = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        }),
      )
        .then(function () {
          return Promise.all([
            n.getDependencies('scene'),
            n.getDependencies('animation'),
            n.getDependencies('camera'),
          ]);
        })
        .then(function (a) {
          const u = {
            scene: a[0][i.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          return (
            Pu(o, u, i),
            Ta(u, i),
            Promise.all(
              n._invokeAll(function (d) {
                return d.afterRoot && d.afterRoot(u);
              }),
            ).then(function () {
              for (const d of u.scenes) d.updateMatrixWorld();
              e(u);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, o = t.length; i < o; i++) {
      const a = t[i].joints;
      for (let u = 0, d = a.length; u < d; u++) e[a[u]].isBone = !0;
    }
    for (let i = 0, o = e.length; i < o; i++) {
      const a = e[i];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      o = (a, u) => {
        const d = this.associations.get(a);
        d != null && this.associations.set(u, d);
        for (const [h, m] of a.children.entries()) o(m, u.children[h]);
      };
    return o(n, i), (i.name += '_instance_' + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const o = e(t[i]);
      o && n.push(o);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ':' + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case 'scene':
          i = this.loadScene(t);
          break;
        case 'node':
          i = this._invokeOne(function (o) {
            return o.loadNode && o.loadNode(t);
          });
          break;
        case 'mesh':
          i = this._invokeOne(function (o) {
            return o.loadMesh && o.loadMesh(t);
          });
          break;
        case 'accessor':
          i = this.loadAccessor(t);
          break;
        case 'bufferView':
          i = this._invokeOne(function (o) {
            return o.loadBufferView && o.loadBufferView(t);
          });
          break;
        case 'buffer':
          i = this.loadBuffer(t);
          break;
        case 'material':
          i = this._invokeOne(function (o) {
            return o.loadMaterial && o.loadMaterial(t);
          });
          break;
        case 'texture':
          i = this._invokeOne(function (o) {
            return o.loadTexture && o.loadTexture(t);
          });
          break;
        case 'skin':
          i = this.loadSkin(t);
          break;
        case 'animation':
          i = this._invokeOne(function (o) {
            return o.loadAnimation && o.loadAnimation(t);
          });
          break;
        case 'camera':
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (o) {
              return o != this && o.getDependency && o.getDependency(e, t);
            })),
            !i)
          )
            throw new Error('Unknown type: ' + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === 'mesh' ? 'es' : 's')] || [];
      (t = Promise.all(
        i.map(function (o, a) {
          return n.getDependency(e, a);
        }),
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== 'arraybuffer')
      throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.');
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Sn.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (o, a) {
      n.load(wl.resolveURL(t.uri, i.path), o, void 0, function () {
        a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency('buffer', t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        o = t.byteOffset || 0;
      return n.slice(o, o + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = q0[i.type],
        u = Lf[i.componentType],
        d = i.normalized === !0,
        h = new u(i.count * a);
      return Promise.resolve(new Pn(h, a, d));
    }
    const o = [];
    return (
      i.bufferView !== void 0
        ? o.push(this.getDependency('bufferView', i.bufferView))
        : o.push(null),
      i.sparse !== void 0 &&
        (o.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
        o.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
      Promise.all(o).then(function (a) {
        const u = a[0],
          d = q0[i.type],
          h = Lf[i.componentType],
          m = h.BYTES_PER_ELEMENT,
          g = m * d,
          v = i.byteOffset || 0,
          x = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
          A = i.normalized === !0;
        let C, E;
        if (x && x !== g) {
          const S = Math.floor(v / x),
            b =
              'InterleavedBuffer:' + i.bufferView + ':' + i.componentType + ':' + S + ':' + i.count;
          let I = t.cache.get(b);
          I ||
            ((C = new h(u, S * x, (i.count * x) / m)), (I = new Gh(C, x / m)), t.cache.add(b, I)),
            (E = new bl(I, d, (v % x) / m, A));
        } else u === null ? (C = new h(i.count * d)) : (C = new h(u, v, i.count * d)), (E = new Pn(C, d, A));
        if (i.sparse !== void 0) {
          const S = q0.SCALAR,
            b = Lf[i.sparse.indices.componentType],
            I = i.sparse.indices.byteOffset || 0,
            B = i.sparse.values.byteOffset || 0,
            z = new b(a[1], I, i.sparse.count * S),
            N = new h(a[2], B, i.sparse.count * d);
          u !== null && (E = new Pn(E.array.slice(), E.itemSize, E.normalized));
          for (let G = 0, k = z.length; G < k; G++) {
            const L = z[G];
            if (
              (E.setX(L, N[G * d]),
              d >= 2 && E.setY(L, N[G * d + 1]),
              d >= 3 && E.setZ(L, N[G * d + 2]),
              d >= 4 && E.setW(L, N[G * d + 3]),
              d >= 5)
            )
              throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
          }
        }
        return E;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      o = t.textures[e].source,
      a = t.images[o];
    let u = this.textureLoader;
    if (a.uri) {
      const d = n.manager.getHandler(a.uri);
      d !== null && (u = d);
    }
    return this.loadTextureImage(e, o, u);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      o = this.json,
      a = o.textures[e],
      u = o.images[t],
      d = (u.uri || u.bufferView) + ':' + a.sampler;
    if (this.textureCache[d]) return this.textureCache[d];
    const h = this.loadImageSource(t, n)
      .then(function (m) {
        (m.flipY = !1),
          (m.name = a.name || u.name || ''),
          m.name === '' &&
            typeof u.uri == 'string' &&
            u.uri.startsWith('data:image/') === !1 &&
            (m.name = u.uri);
        const v = (o.samplers || {})[a.sampler] || {};
        return (
          (m.magFilter = ES[v.magFilter] || Fn),
          (m.minFilter = ES[v.minFilter] || Ds),
          (m.wrapS = wS[v.wrapS] || Rl),
          (m.wrapT = wS[v.wrapT] || Rl),
          i.associations.set(m, { textures: e }),
          m
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[d] = h), h;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      o = this.options;
    if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((g) => g.clone());
    const a = i.images[e],
      u = self.URL || self.webkitURL;
    let d = a.uri || '',
      h = !1;
    if (a.bufferView !== void 0)
      d = n.getDependency('bufferView', a.bufferView).then(function (g) {
        h = !0;
        const v = new Blob([g], { type: a.mimeType });
        return (d = u.createObjectURL(v)), d;
      });
    else if (a.uri === void 0)
      throw new Error('THREE.GLTFLoader: Image ' + e + ' is missing URI and bufferView');
    const m = Promise.resolve(d)
      .then(function (g) {
        return new Promise(function (v, x) {
          let A = v;
          t.isImageBitmapLoader === !0 &&
            (A = function (C) {
              const E = new Ln(C);
              (E.needsUpdate = !0), v(E);
            }),
            t.load(wl.resolveURL(g, o.path), A, void 0, x);
        });
      })
      .then(function (g) {
        return (
          h === !0 && u.revokeObjectURL(d),
          Ta(g, a),
          (g.userData.mimeType = a.mimeType || ND(a.uri)),
          g
        );
      })
      .catch(function (g) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", d), g);
      });
    return (this.sourceCache[e] = m), m;
  }
  assignTexture(e, t, n, i) {
    const o = this;
    return this.getDependency('texture', n.index).then(function (a) {
      if (!a) return null;
      if (
        (n.texCoord !== void 0 && n.texCoord > 0 && ((a = a.clone()), (a.channel = n.texCoord)),
        o.extensions[Sn.KHR_TEXTURE_TRANSFORM])
      ) {
        const u = n.extensions !== void 0 ? n.extensions[Sn.KHR_TEXTURE_TRANSFORM] : void 0;
        if (u) {
          const d = o.associations.get(a);
          (a = o.extensions[Sn.KHR_TEXTURE_TRANSFORM].extendTexture(a, u)),
            o.associations.set(a, d);
        }
      }
      return (
        i !== void 0 &&
          (typeof i == 'number' && (i = i === SS ? Xu : La),
          'colorSpace' in a ? (a.colorSpace = i) : (a.encoding = i === Xu ? SS : sD)),
        (e[t] = a),
        a
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      o = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const u = 'PointsMaterial:' + n.uuid;
      let d = this.cache.get(u);
      d ||
        ((d = new Qg()),
        Oi.prototype.copy.call(d, n),
        d.color.copy(n.color),
        (d.map = n.map),
        (d.sizeAttenuation = !1),
        this.cache.add(u, d)),
        (n = d);
    } else if (e.isLine) {
      const u = 'LineBasicMaterial:' + n.uuid;
      let d = this.cache.get(u);
      d ||
        ((d = new Sr()),
        Oi.prototype.copy.call(d, n),
        d.color.copy(n.color),
        (d.map = n.map),
        this.cache.add(u, d)),
        (n = d);
    }
    if (i || o || a) {
      let u = 'ClonedMaterial:' + n.uuid + ':';
      i && (u += 'derivative-tangents:'), o && (u += 'vertex-colors:'), a && (u += 'flat-shading:');
      let d = this.cache.get(u);
      d ||
        ((d = n.clone()),
        o && (d.vertexColors = !0),
        a && (d.flatShading = !0),
        i &&
          (d.normalScale && (d.normalScale.y *= -1),
          d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)),
        this.cache.add(u, d),
        this.associations.set(d, this.associations.get(n))),
        (n = d);
    }
    e.material = n;
  }
  getMaterialType() {
    return jh;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      o = n.materials[e];
    let a;
    const u = {},
      d = o.extensions || {},
      h = [];
    if (d[Sn.KHR_MATERIALS_UNLIT]) {
      const g = i[Sn.KHR_MATERIALS_UNLIT];
      (a = g.getMaterialType()), h.push(g.extendParams(u, o, t));
    } else {
      const g = o.pbrMetallicRoughness || {};
      if (((u.color = new At(1, 1, 1)), (u.opacity = 1), Array.isArray(g.baseColorFactor))) {
        const v = g.baseColorFactor;
        u.color.setRGB(v[0], v[1], v[2], La), (u.opacity = v[3]);
      }
      g.baseColorTexture !== void 0 && h.push(t.assignTexture(u, 'map', g.baseColorTexture, Xu)),
        (u.metalness = g.metallicFactor !== void 0 ? g.metallicFactor : 1),
        (u.roughness = g.roughnessFactor !== void 0 ? g.roughnessFactor : 1),
        g.metallicRoughnessTexture !== void 0 &&
          (h.push(t.assignTexture(u, 'metalnessMap', g.metallicRoughnessTexture)),
          h.push(t.assignTexture(u, 'roughnessMap', g.metallicRoughnessTexture))),
        (a = this._invokeOne(function (v) {
          return v.getMaterialType && v.getMaterialType(e);
        })),
        h.push(
          Promise.all(
            this._invokeAll(function (v) {
              return v.extendMaterialParams && v.extendMaterialParams(e, u);
            }),
          ),
        );
    }
    o.doubleSided === !0 && (u.side = gs);
    const m = o.alphaMode || $0.OPAQUE;
    if (
      (m === $0.BLEND
        ? ((u.transparent = !0), (u.depthWrite = !1))
        : ((u.transparent = !1),
          m === $0.MASK && (u.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5)),
      o.normalTexture !== void 0 &&
        a !== ts &&
        (h.push(t.assignTexture(u, 'normalMap', o.normalTexture)),
        (u.normalScale = new Ge(1, 1)),
        o.normalTexture.scale !== void 0))
    ) {
      const g = o.normalTexture.scale;
      u.normalScale.set(g, g);
    }
    if (
      (o.occlusionTexture !== void 0 &&
        a !== ts &&
        (h.push(t.assignTexture(u, 'aoMap', o.occlusionTexture)),
        o.occlusionTexture.strength !== void 0 && (u.aoMapIntensity = o.occlusionTexture.strength)),
      o.emissiveFactor !== void 0 && a !== ts)
    ) {
      const g = o.emissiveFactor;
      u.emissive = new At().setRGB(g[0], g[1], g[2], La);
    }
    return (
      o.emissiveTexture !== void 0 &&
        a !== ts &&
        h.push(t.assignTexture(u, 'emissiveMap', o.emissiveTexture, Xu)),
      Promise.all(h).then(function () {
        const g = new a(u);
        return (
          o.name && (g.name = o.name),
          Ta(g, o),
          t.associations.set(g, { materials: e }),
          o.extensions && Pu(i, g, o),
          g
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Rn.sanitizeNodeName(e || '');
    return t in this.nodeNamesUsed
      ? t + '_' + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function o(u) {
      return n[Sn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(u, t).then(function (d) {
        return CS(d, u, t);
      });
    }
    const a = [];
    for (let u = 0, d = e.length; u < d; u++) {
      const h = e[u],
        m = FD(h),
        g = i[m];
      if (g) a.push(g.promise);
      else {
        let v;
        h.extensions && h.extensions[Sn.KHR_DRACO_MESH_COMPRESSION]
          ? (v = o(h))
          : (v = CS(new hn(), h, t)),
          (i[m] = { primitive: h, promise: v }),
          a.push(v);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      o = n.meshes[e],
      a = o.primitives,
      u = [];
    for (let d = 0, h = a.length; d < h; d++) {
      const m =
        a[d].material === void 0 ? PD(this.cache) : this.getDependency('material', a[d].material);
      u.push(m);
    }
    return (
      u.push(t.loadGeometries(a)),
      Promise.all(u).then(function (d) {
        const h = d.slice(0, d.length - 1),
          m = d[d.length - 1],
          g = [];
        for (let x = 0, A = m.length; x < A; x++) {
          const C = m[x],
            E = a[x];
          let S;
          const b = h[x];
          if (
            E.mode === Bs.TRIANGLES ||
            E.mode === Bs.TRIANGLE_STRIP ||
            E.mode === Bs.TRIANGLE_FAN ||
            E.mode === void 0
          )
            (S = o.isSkinnedMesh === !0 ? new Vy(C, b) : new oi(C, b)),
              S.isSkinnedMesh === !0 && S.normalizeSkinWeights(),
              E.mode === Bs.TRIANGLE_STRIP
                ? (S.geometry = _S(S.geometry, Ny))
                : E.mode === Bs.TRIANGLE_FAN && (S.geometry = _S(S.geometry, Ig));
          else if (E.mode === Bs.LINES) S = new mo(C, b);
          else if (E.mode === Bs.LINE_STRIP) S = new Fa(C, b);
          else if (E.mode === Bs.LINE_LOOP) S = new Xy(C, b);
          else if (E.mode === Bs.POINTS) S = new Jy(C, b);
          else throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + E.mode);
          Object.keys(S.geometry.morphAttributes).length > 0 && LD(S, o),
            (S.name = t.createUniqueName(o.name || 'mesh_' + e)),
            Ta(S, o),
            E.extensions && Pu(i, S, E),
            t.assignFinalMaterial(S),
            g.push(S);
        }
        for (let x = 0, A = g.length; x < A; x++)
          t.associations.set(g[x], { meshes: e, primitives: x });
        if (g.length === 1) return o.extensions && Pu(i, g[0], o), g[0];
        const v = new Ba();
        o.extensions && Pu(i, v, o), t.associations.set(v, { meshes: e });
        for (let x = 0, A = g.length; x < A; x++) v.add(g[x]);
        return v;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.');
      return;
    }
    return (
      n.type === 'perspective'
        ? (t = new gi(yM.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6))
        : n.type === 'orthographic' &&
          (t = new No(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      Ta(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, o = t.joints.length; i < o; i++) n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency('accessor', t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const o = i.pop(),
          a = i,
          u = [],
          d = [];
        for (let h = 0, m = a.length; h < m; h++) {
          const g = a[h];
          if (g) {
            u.push(g);
            const v = new Qt();
            o !== null && v.fromArray(o.array, h * 16), d.push(v);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[h]);
        }
        return new Vh(u, d);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      n = this,
      i = t.animations[e],
      o = i.name ? i.name : 'animation_' + e,
      a = [],
      u = [],
      d = [],
      h = [],
      m = [];
    for (let g = 0, v = i.channels.length; g < v; g++) {
      const x = i.channels[g],
        A = i.samplers[x.sampler],
        C = x.target,
        E = C.node,
        S = i.parameters !== void 0 ? i.parameters[A.input] : A.input,
        b = i.parameters !== void 0 ? i.parameters[A.output] : A.output;
      C.node !== void 0 &&
        (a.push(this.getDependency('node', E)),
        u.push(this.getDependency('accessor', S)),
        d.push(this.getDependency('accessor', b)),
        h.push(A),
        m.push(C));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(u),
      Promise.all(d),
      Promise.all(h),
      Promise.all(m),
    ]).then(function (g) {
      const v = g[0],
        x = g[1],
        A = g[2],
        C = g[3],
        E = g[4],
        S = [];
      for (let b = 0, I = v.length; b < I; b++) {
        const B = v[b],
          z = x[b],
          N = A[b],
          G = C[b],
          k = E[b];
        if (B === void 0) continue;
        B.updateMatrix && B.updateMatrix();
        const L = n._createAnimationTracks(B, z, N, G, k);
        if (L) for (let D = 0; D < L.length; D++) S.push(L[D]);
      }
      return new Vf(o, void 0, S);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency('mesh', i.mesh).then(function (o) {
          const a = n._getNodeRef(n.meshCache, i.mesh, o);
          return (
            i.weights !== void 0 &&
              a.traverse(function (u) {
                if (u.isMesh)
                  for (let d = 0, h = i.weights.length; d < h; d++)
                    u.morphTargetInfluences[d] = i.weights[d];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      o = n._loadNodeShallow(e),
      a = [],
      u = i.children || [];
    for (let h = 0, m = u.length; h < m; h++) a.push(n.getDependency('node', u[h]));
    const d = i.skin === void 0 ? Promise.resolve(null) : n.getDependency('skin', i.skin);
    return Promise.all([o, Promise.all(a), d]).then(function (h) {
      const m = h[0],
        g = h[1],
        v = h[2];
      v !== null &&
        m.traverse(function (x) {
          x.isSkinnedMesh && x.bind(v, UD);
        });
      for (let x = 0, A = g.length; x < A; x++) m.add(g[x]);
      return m;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const o = t.nodes[e],
      a = o.name ? i.createUniqueName(o.name) : '',
      u = [],
      d = i._invokeOne(function (h) {
        return h.createNodeMesh && h.createNodeMesh(e);
      });
    return (
      d && u.push(d),
      o.camera !== void 0 &&
        u.push(
          i.getDependency('camera', o.camera).then(function (h) {
            return i._getNodeRef(i.cameraCache, o.camera, h);
          }),
        ),
      i
        ._invokeAll(function (h) {
          return h.createNodeAttachment && h.createNodeAttachment(e);
        })
        .forEach(function (h) {
          u.push(h);
        }),
      (this.nodeCache[e] = Promise.all(u).then(function (h) {
        let m;
        if (
          (o.isBone === !0
            ? (m = new Zg())
            : h.length > 1
            ? (m = new Ba())
            : h.length === 1
            ? (m = h[0])
            : (m = new wn()),
          m !== h[0])
        )
          for (let g = 0, v = h.length; g < v; g++) m.add(h[g]);
        if (
          (o.name && ((m.userData.name = o.name), (m.name = a)),
          Ta(m, o),
          o.extensions && Pu(n, m, o),
          o.matrix !== void 0)
        ) {
          const g = new Qt();
          g.fromArray(o.matrix), m.applyMatrix4(g);
        } else o.translation !== void 0 && m.position.fromArray(o.translation), o.rotation !== void 0 && m.quaternion.fromArray(o.rotation), o.scale !== void 0 && m.scale.fromArray(o.scale);
        return (
          i.associations.has(m) || i.associations.set(m, {}), (i.associations.get(m).nodes = e), m
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      o = new Ba();
    n.name && (o.name = i.createUniqueName(n.name)), Ta(o, n), n.extensions && Pu(t, o, n);
    const a = n.nodes || [],
      u = [];
    for (let d = 0, h = a.length; d < h; d++) u.push(i.getDependency('node', a[d]));
    return Promise.all(u).then(function (d) {
      for (let m = 0, g = d.length; m < g; m++) o.add(d[m]);
      const h = (m) => {
        const g = new Map();
        for (const [v, x] of i.associations) (v instanceof Oi || v instanceof Ln) && g.set(v, x);
        return (
          m.traverse((v) => {
            const x = i.associations.get(v);
            x != null && g.set(v, x);
          }),
          g
        );
      };
      return (i.associations = h(o)), o;
    });
  }
  _createAnimationTracks(e, t, n, i, o) {
    const a = [],
      u = e.name ? e.name : e.uuid,
      d = [];
    Al[o.path] === Al.weights
      ? e.traverse(function (v) {
          v.morphTargetInfluences && d.push(v.name ? v.name : v.uuid);
        })
      : d.push(u);
    let h;
    switch (Al[o.path]) {
      case Al.weights:
        h = nc;
        break;
      case Al.rotation:
        h = ic;
        break;
      case Al.position:
      case Al.scale:
        h = rc;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            h = nc;
            break;
          case 2:
          case 3:
          default:
            h = rc;
            break;
        }
        break;
    }
    const m = i.interpolation !== void 0 ? BD[i.interpolation] : zf,
      g = this._getArrayFromAccessor(n);
    for (let v = 0, x = d.length; v < x; v++) {
      const A = new h(d[v] + '.' + Al[o.path], t.array, g, m);
      i.interpolation === 'CUBICSPLINE' && this._createCubicSplineTrackInterpolant(A), a.push(A);
    }
    return a;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = Cy(t.constructor),
        i = new Float32Array(t.length);
      for (let o = 0, a = t.length; o < a; o++) i[o] = t[o] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (n) {
      const i = this instanceof ic ? ID : ZE;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function kD(r, e, t) {
  const n = e.attributes,
    i = new Ar();
  if (n.POSITION !== void 0) {
    const u = t.json.accessors[n.POSITION],
      d = u.min,
      h = u.max;
    if (d !== void 0 && h !== void 0) {
      if ((i.set(new J(d[0], d[1], d[2]), new J(h[0], h[1], h[2])), u.normalized)) {
        const m = Cy(Lf[u.componentType]);
        i.min.multiplyScalar(m), i.max.multiplyScalar(m);
      }
    } else {
      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
      return;
    }
  } else return;
  const o = e.targets;
  if (o !== void 0) {
    const u = new J(),
      d = new J();
    for (let h = 0, m = o.length; h < m; h++) {
      const g = o[h];
      if (g.POSITION !== void 0) {
        const v = t.json.accessors[g.POSITION],
          x = v.min,
          A = v.max;
        if (x !== void 0 && A !== void 0) {
          if (
            (d.setX(Math.max(Math.abs(x[0]), Math.abs(A[0]))),
            d.setY(Math.max(Math.abs(x[1]), Math.abs(A[1]))),
            d.setZ(Math.max(Math.abs(x[2]), Math.abs(A[2]))),
            v.normalized)
          ) {
            const C = Cy(Lf[v.componentType]);
            d.multiplyScalar(C);
          }
          u.max(d);
        } else console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
      }
    }
    i.expandByVector(u);
  }
  r.boundingBox = i;
  const a = new or();
  i.getCenter(a.center), (a.radius = i.min.distanceTo(i.max) / 2), (r.boundingSphere = a);
}
function CS(r, e, t) {
  const n = e.attributes,
    i = [];
  function o(a, u) {
    return t.getDependency('accessor', a).then(function (d) {
      r.setAttribute(u, d);
    });
  }
  for (const a in n) {
    const u = wy[a] || a.toLowerCase();
    u in r.attributes || i.push(o(n[a], u));
  }
  if (e.indices !== void 0 && !r.index) {
    const a = t.getDependency('accessor', e.indices).then(function (u) {
      r.setIndex(u);
    });
    i.push(a);
  }
  return (
    Ta(r, e),
    kD(r, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? DD(r, e.targets, t) : r;
    })
  );
}
class zD extends s_ {
  constructor(e) {
    super(e), (this.type = Yi);
  }
  parse(e) {
    const a = function (k, L) {
        switch (k) {
          case 1:
            throw new Error('THREE.RGBELoader: Read Error: ' + (L || ''));
          case 2:
            throw new Error('THREE.RGBELoader: Write Error: ' + (L || ''));
          case 3:
            throw new Error('THREE.RGBELoader: Bad File Format: ' + (L || ''));
          default:
          case 4:
            throw new Error('THREE.RGBELoader: Memory Error: ' + (L || ''));
        }
      },
      m = `
`,
      g = function (k, L, D) {
        L = L || 1024;
        let oe = k.pos,
          ie = -1,
          ce = 0,
          xe = '',
          de = String.fromCharCode.apply(null, new Uint16Array(k.subarray(oe, oe + 128)));
        for (; 0 > (ie = de.indexOf(m)) && ce < L && oe < k.byteLength; )
          (xe += de),
            (ce += de.length),
            (oe += 128),
            (de += String.fromCharCode.apply(null, new Uint16Array(k.subarray(oe, oe + 128))));
        return -1 < ie ? ((k.pos += ce + ie + 1), xe + de.slice(0, ie)) : !1;
      },
      v = function (k) {
        const L = /^#\?(\S+)/,
          D = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          V = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          oe = /^\s*FORMAT=(\S+)\s*$/,
          ie = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          ce = {
            valid: 0,
            string: '',
            comments: '',
            programtype: 'RGBE',
            format: '',
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let xe, de;
        for (
          (k.pos >= k.byteLength || !(xe = g(k))) && a(1, 'no header found'),
            (de = xe.match(L)) || a(3, 'bad initial token'),
            ce.valid |= 1,
            ce.programtype = de[1],
            ce.string +=
              xe +
              `
`;
          (xe = g(k)), xe !== !1;

        ) {
          if (
            ((ce.string +=
              xe +
              `
`),
            xe.charAt(0) === '#')
          ) {
            ce.comments +=
              xe +
              `
`;
            continue;
          }
          if (
            ((de = xe.match(D)) && (ce.gamma = parseFloat(de[1])),
            (de = xe.match(V)) && (ce.exposure = parseFloat(de[1])),
            (de = xe.match(oe)) && ((ce.valid |= 2), (ce.format = de[1])),
            (de = xe.match(ie)) &&
              ((ce.valid |= 4),
              (ce.height = parseInt(de[1], 10)),
              (ce.width = parseInt(de[2], 10))),
            ce.valid & 2 && ce.valid & 4)
          )
            break;
        }
        return (
          ce.valid & 2 || a(3, 'missing format specifier'),
          ce.valid & 4 || a(3, 'missing image size specifier'),
          ce
        );
      },
      x = function (k, L, D) {
        const V = L;
        if (V < 8 || V > 32767 || k[0] !== 2 || k[1] !== 2 || k[2] & 128) return new Uint8Array(k);
        V !== ((k[2] << 8) | k[3]) && a(3, 'wrong scanline width');
        const oe = new Uint8Array(4 * L * D);
        oe.length || a(4, 'unable to allocate buffer space');
        let ie = 0,
          ce = 0;
        const xe = 4 * V,
          de = new Uint8Array(4),
          Ce = new Uint8Array(xe);
        let X = D;
        for (; X > 0 && ce < k.byteLength; ) {
          ce + 4 > k.byteLength && a(1),
            (de[0] = k[ce++]),
            (de[1] = k[ce++]),
            (de[2] = k[ce++]),
            (de[3] = k[ce++]),
            (de[0] != 2 || de[1] != 2 || ((de[2] << 8) | de[3]) != V) &&
              a(3, 'bad rgbe scanline format');
          let fe = 0,
            te;
          for (; fe < xe && ce < k.byteLength; ) {
            te = k[ce++];
            const ue = te > 128;
            if ((ue && (te -= 128), (te === 0 || fe + te > xe) && a(3, 'bad scanline data'), ue)) {
              const He = k[ce++];
              for (let ge = 0; ge < te; ge++) Ce[fe++] = He;
            } else Ce.set(k.subarray(ce, ce + te), fe), (fe += te), (ce += te);
          }
          const Y = V;
          for (let ue = 0; ue < Y; ue++) {
            let He = 0;
            (oe[ie] = Ce[ue + He]),
              (He += V),
              (oe[ie + 1] = Ce[ue + He]),
              (He += V),
              (oe[ie + 2] = Ce[ue + He]),
              (He += V),
              (oe[ie + 3] = Ce[ue + He]),
              (ie += 4);
          }
          X--;
        }
        return oe;
      },
      A = function (k, L, D, V) {
        const oe = k[L + 3],
          ie = Math.pow(2, oe - 128) / 255;
        (D[V + 0] = k[L + 0] * ie),
          (D[V + 1] = k[L + 1] * ie),
          (D[V + 2] = k[L + 2] * ie),
          (D[V + 3] = 1);
      },
      C = function (k, L, D, V) {
        const oe = k[L + 3],
          ie = Math.pow(2, oe - 128) / 255;
        (D[V + 0] = Gu.toHalfFloat(Math.min(k[L + 0] * ie, 65504))),
          (D[V + 1] = Gu.toHalfFloat(Math.min(k[L + 1] * ie, 65504))),
          (D[V + 2] = Gu.toHalfFloat(Math.min(k[L + 2] * ie, 65504))),
          (D[V + 3] = Gu.toHalfFloat(1));
      },
      E = new Uint8Array(e);
    E.pos = 0;
    const S = v(E),
      b = S.width,
      I = S.height,
      B = x(E.subarray(E.pos), b, I);
    let z, N, G;
    switch (this.type) {
      case fi:
        G = B.length / 4;
        const k = new Float32Array(G * 4);
        for (let D = 0; D < G; D++) A(B, D * 4, k, D * 4);
        (z = k), (N = fi);
        break;
      case Yi:
        G = B.length / 4;
        const L = new Uint16Array(G * 4);
        for (let D = 0; D < G; D++) C(B, D * 4, L, D * 4);
        (z = L), (N = Yi);
        break;
      default:
        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type);
    }
    return {
      width: b,
      height: I,
      data: z,
      header: S.string,
      gamma: S.gamma,
      exposure: S.exposure,
      type: N,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function o(a, u) {
      switch (a.type) {
        case fi:
        case Yi:
          'colorSpace' in a ? (a.colorSpace = 'srgb-linear') : (a.encoding = 3e3),
            (a.minFilter = Fn),
            (a.magFilter = Fn),
            (a.generateMipmaps = !1),
            (a.flipY = !0);
          break;
      }
      t && t(a, u);
    }
    return super.load(e, o, n, i);
  }
}
const sh = M_ >= 152;
class HD extends s_ {
  constructor(e) {
    super(e), (this.type = Yi);
  }
  parse(e) {
    const L = Math.pow(2.7182818, 2.2);
    function D(F, W) {
      for (var se = 0, Ee = 0; Ee < 65536; ++Ee)
        (Ee == 0 || F[Ee >> 3] & (1 << (Ee & 7))) && (W[se++] = Ee);
      for (var Be = se - 1; se < 65536; ) W[se++] = 0;
      return Be;
    }
    function V(F) {
      for (var W = 0; W < 16384; W++) (F[W] = {}), (F[W].len = 0), (F[W].lit = 0), (F[W].p = null);
    }
    const oe = { l: 0, c: 0, lc: 0 };
    function ie(F, W, se, Ee, Be) {
      for (; se < F; ) (W = (W << 8) | St(Ee, Be)), (se += 8);
      (se -= F), (oe.l = (W >> se) & ((1 << F) - 1)), (oe.c = W), (oe.lc = se);
    }
    const ce = new Array(59);
    function xe(F) {
      for (var W = 0; W <= 58; ++W) ce[W] = 0;
      for (var W = 0; W < 65537; ++W) ce[F[W]] += 1;
      for (var se = 0, W = 58; W > 0; --W) {
        var Ee = (se + ce[W]) >> 1;
        (ce[W] = se), (se = Ee);
      }
      for (var W = 0; W < 65537; ++W) {
        var Be = F[W];
        Be > 0 && (F[W] = Be | (ce[Be]++ << 6));
      }
    }
    function de(F, W, se, Ee, Be, Pe, it) {
      for (var Qe = se, U = 0, Q = 0; Be <= Pe; Be++) {
        if (Qe.value - se.value > Ee) return !1;
        ie(6, U, Q, F, Qe);
        var ee = oe.l;
        if (((U = oe.c), (Q = oe.lc), (it[Be] = ee), ee == 63)) {
          if (Qe.value - se.value > Ee) throw 'Something wrong with hufUnpackEncTable';
          ie(8, U, Q, F, Qe);
          var q = oe.l + 6;
          if (((U = oe.c), (Q = oe.lc), Be + q > Pe + 1))
            throw 'Something wrong with hufUnpackEncTable';
          for (; q--; ) it[Be++] = 0;
          Be--;
        } else if (ee >= 59) {
          var q = ee - 59 + 2;
          if (Be + q > Pe + 1) throw 'Something wrong with hufUnpackEncTable';
          for (; q--; ) it[Be++] = 0;
          Be--;
        }
      }
      xe(it);
    }
    function Ce(F) {
      return F & 63;
    }
    function X(F) {
      return F >> 6;
    }
    function fe(F, W, se, Ee) {
      for (; W <= se; W++) {
        var Be = X(F[W]),
          Pe = Ce(F[W]);
        if (Be >> Pe) throw 'Invalid table entry';
        if (Pe > 14) {
          var it = Ee[Be >> (Pe - 14)];
          if (it.len) throw 'Invalid table entry';
          if ((it.lit++, it.p)) {
            var Qe = it.p;
            it.p = new Array(it.lit);
            for (var U = 0; U < it.lit - 1; ++U) it.p[U] = Qe[U];
          } else it.p = new Array(1);
          it.p[it.lit - 1] = W;
        } else if (Pe)
          for (var Q = 0, U = 1 << (14 - Pe); U > 0; U--) {
            var it = Ee[(Be << (14 - Pe)) + Q];
            if (it.len || it.p) throw 'Invalid table entry';
            (it.len = Pe), (it.lit = W), Q++;
          }
      }
      return !0;
    }
    const te = { c: 0, lc: 0 };
    function Y(F, W, se, Ee) {
      (F = (F << 8) | St(se, Ee)), (W += 8), (te.c = F), (te.lc = W);
    }
    const ue = { c: 0, lc: 0 };
    function He(F, W, se, Ee, Be, Pe, it, Qe, U, Q) {
      if (F == W) {
        Ee < 8 && (Y(se, Ee, Be, it), (se = te.c), (Ee = te.lc)), (Ee -= 8);
        var ee = se >> Ee,
          ee = new Uint8Array([ee])[0];
        if (U.value + ee > Q) return !1;
        for (var q = Qe[U.value - 1]; ee-- > 0; ) Qe[U.value++] = q;
      } else if (U.value < Q) Qe[U.value++] = F;
      else return !1;
      (ue.c = se), (ue.lc = Ee);
    }
    function ge(F) {
      return F & 65535;
    }
    function De(F) {
      var W = ge(F);
      return W > 32767 ? W - 65536 : W;
    }
    const Ie = { a: 0, b: 0 };
    function Ue(F, W) {
      var se = De(F),
        Ee = De(W),
        Be = Ee,
        Pe = se + (Be & 1) + (Be >> 1),
        it = Pe,
        Qe = Pe - Be;
      (Ie.a = it), (Ie.b = Qe);
    }
    function et(F, W) {
      var se = ge(F),
        Ee = ge(W),
        Be = (se - (Ee >> 1)) & 65535,
        Pe = (Ee + Be - 32768) & 65535;
      (Ie.a = Pe), (Ie.b = Be);
    }
    function Bt(F, W, se, Ee, Be, Pe, it) {
      for (var Qe = it < 16384, U = se > Be ? Be : se, Q = 1, ee; Q <= U; ) Q <<= 1;
      for (Q >>= 1, ee = Q, Q >>= 1; Q >= 1; ) {
        for (
          var q = 0,
            le = q + Pe * (Be - ee),
            Ae = Pe * Q,
            Fe = Pe * ee,
            Ve = Ee * Q,
            Je = Ee * ee,
            ft,
            ut,
            Xe,
            mt;
          q <= le;
          q += Fe
        ) {
          for (var gt = q, qt = q + Ee * (se - ee); gt <= qt; gt += Je) {
            var Dt = gt + Ve,
              Ut = gt + Ae,
              Mt = Ut + Ve;
            Qe
              ? (Ue(F[gt + W], F[Ut + W]),
                (ft = Ie.a),
                (Xe = Ie.b),
                Ue(F[Dt + W], F[Mt + W]),
                (ut = Ie.a),
                (mt = Ie.b),
                Ue(ft, ut),
                (F[gt + W] = Ie.a),
                (F[Dt + W] = Ie.b),
                Ue(Xe, mt),
                (F[Ut + W] = Ie.a),
                (F[Mt + W] = Ie.b))
              : (et(F[gt + W], F[Ut + W]),
                (ft = Ie.a),
                (Xe = Ie.b),
                et(F[Dt + W], F[Mt + W]),
                (ut = Ie.a),
                (mt = Ie.b),
                et(ft, ut),
                (F[gt + W] = Ie.a),
                (F[Dt + W] = Ie.b),
                et(Xe, mt),
                (F[Ut + W] = Ie.a),
                (F[Mt + W] = Ie.b));
          }
          if (se & Q) {
            var Ut = gt + Ae;
            Qe ? Ue(F[gt + W], F[Ut + W]) : et(F[gt + W], F[Ut + W]),
              (ft = Ie.a),
              (F[Ut + W] = Ie.b),
              (F[gt + W] = ft);
          }
        }
        if (Be & Q)
          for (var gt = q, qt = q + Ee * (se - ee); gt <= qt; gt += Je) {
            var Dt = gt + Ve;
            Qe ? Ue(F[gt + W], F[Dt + W]) : et(F[gt + W], F[Dt + W]),
              (ft = Ie.a),
              (F[Dt + W] = Ie.b),
              (F[gt + W] = ft);
          }
        (ee = Q), (Q >>= 1);
      }
      return q;
    }
    function ht(F, W, se, Ee, Be, Pe, it, Qe, U, Q) {
      for (var ee = 0, q = 0, le = Qe, Ae = Math.trunc(Be.value + (Pe + 7) / 8); Be.value < Ae; )
        for (Y(ee, q, se, Be), ee = te.c, q = te.lc; q >= 14; ) {
          var Fe = (ee >> (q - 14)) & 16383,
            Ve = W[Fe];
          if (Ve.len)
            (q -= Ve.len), He(Ve.lit, it, ee, q, se, Ee, Be, U, Q, le), (ee = ue.c), (q = ue.lc);
          else {
            if (!Ve.p) throw 'hufDecode issues';
            var Je;
            for (Je = 0; Je < Ve.lit; Je++) {
              for (var ft = Ce(F[Ve.p[Je]]); q < ft && Be.value < Ae; )
                Y(ee, q, se, Be), (ee = te.c), (q = te.lc);
              if (q >= ft && X(F[Ve.p[Je]]) == ((ee >> (q - ft)) & ((1 << ft) - 1))) {
                (q -= ft), He(Ve.p[Je], it, ee, q, se, Ee, Be, U, Q, le), (ee = ue.c), (q = ue.lc);
                break;
              }
            }
            if (Je == Ve.lit) throw 'hufDecode issues';
          }
        }
      var ut = (8 - Pe) & 7;
      for (ee >>= ut, q -= ut; q > 0; ) {
        var Ve = W[(ee << (14 - q)) & 16383];
        if (Ve.len)
          (q -= Ve.len), He(Ve.lit, it, ee, q, se, Ee, Be, U, Q, le), (ee = ue.c), (q = ue.lc);
        else throw 'hufDecode issues';
      }
      return !0;
    }
    function Jt(F, W, se, Ee, Be, Pe) {
      var it = { value: 0 },
        Qe = se.value,
        U = Rt(W, se),
        Q = Rt(W, se);
      se.value += 4;
      var ee = Rt(W, se);
      if (((se.value += 4), U < 0 || U >= 65537 || Q < 0 || Q >= 65537))
        throw 'Something wrong with HUF_ENCSIZE';
      var q = new Array(65537),
        le = new Array(16384);
      V(le);
      var Ae = Ee - (se.value - Qe);
      if ((de(F, W, se, Ae, U, Q, q), ee > 8 * (Ee - (se.value - Qe))))
        throw 'Something wrong with hufUncompress';
      fe(q, U, Q, le), ht(q, le, F, W, se, ee, Q, Pe, Be, it);
    }
    function Ye(F, W, se) {
      for (var Ee = 0; Ee < se; ++Ee) W[Ee] = F[W[Ee]];
    }
    function ke(F) {
      for (var W = 1; W < F.length; W++) {
        var se = F[W - 1] + F[W] - 128;
        F[W] = se;
      }
    }
    function j(F, W) {
      for (
        var se = 0, Ee = Math.floor((F.length + 1) / 2), Be = 0, Pe = F.length - 1;
        !(Be > Pe || ((W[Be++] = F[se++]), Be > Pe));

      )
        W[Be++] = F[Ee++];
    }
    function It(F) {
      for (var W = F.byteLength, se = new Array(), Ee = 0, Be = new DataView(F); W > 0; ) {
        var Pe = Be.getInt8(Ee++);
        if (Pe < 0) {
          var it = -Pe;
          W -= it + 1;
          for (var Qe = 0; Qe < it; Qe++) se.push(Be.getUint8(Ee++));
        } else {
          var it = Pe;
          W -= 2;
          for (var U = Be.getUint8(Ee++), Qe = 0; Qe < it + 1; Qe++) se.push(U);
        }
      }
      return se;
    }
    function qe(F, W, se, Ee, Be, Pe) {
      var Dt = new DataView(Pe.buffer),
        it = se[F.idx[0]].width,
        Qe = se[F.idx[0]].height,
        U = 3,
        Q = Math.floor(it / 8),
        ee = Math.ceil(it / 8),
        q = Math.ceil(Qe / 8),
        le = it - (ee - 1) * 8,
        Ae = Qe - (q - 1) * 8,
        Fe = { value: 0 },
        Ve = new Array(U),
        Je = new Array(U),
        ft = new Array(U),
        ut = new Array(U),
        Xe = new Array(U);
      for (let en = 0; en < U; ++en)
        (Xe[en] = W[F.idx[en]]),
          (Ve[en] = en < 1 ? 0 : Ve[en - 1] + ee * q),
          (Je[en] = new Float32Array(64)),
          (ft[en] = new Uint16Array(64)),
          (ut[en] = new Uint16Array(ee * 64));
      for (let en = 0; en < q; ++en) {
        var mt = 8;
        en == q - 1 && (mt = Ae);
        var gt = 8;
        for (let on = 0; on < ee; ++on) {
          on == ee - 1 && (gt = le);
          for (let pn = 0; pn < U; ++pn)
            ft[pn].fill(0),
              (ft[pn][0] = Be[Ve[pn]++]),
              yt(Fe, Ee, ft[pn]),
              rt(ft[pn], Je[pn]),
              Ht(Je[pn]);
          lt(Je);
          for (let pn = 0; pn < U; ++pn) K(Je[pn], ut[pn], on * 64);
        }
        let Hn = 0;
        for (let on = 0; on < U; ++on) {
          const pn = se[F.idx[on]].type;
          for (let Yt = 8 * en; Yt < 8 * en + mt; ++Yt) {
            Hn = Xe[on][Yt];
            for (let Kn = 0; Kn < Q; ++Kn) {
              const Cn = Kn * 64 + (Yt & 7) * 8;
              Dt.setUint16(Hn + 0 * 2 * pn, ut[on][Cn + 0], !0),
                Dt.setUint16(Hn + 1 * 2 * pn, ut[on][Cn + 1], !0),
                Dt.setUint16(Hn + 2 * 2 * pn, ut[on][Cn + 2], !0),
                Dt.setUint16(Hn + 3 * 2 * pn, ut[on][Cn + 3], !0),
                Dt.setUint16(Hn + 4 * 2 * pn, ut[on][Cn + 4], !0),
                Dt.setUint16(Hn + 5 * 2 * pn, ut[on][Cn + 5], !0),
                Dt.setUint16(Hn + 6 * 2 * pn, ut[on][Cn + 6], !0),
                Dt.setUint16(Hn + 7 * 2 * pn, ut[on][Cn + 7], !0),
                (Hn += 8 * 2 * pn);
            }
          }
          if (Q != ee)
            for (let Yt = 8 * en; Yt < 8 * en + mt; ++Yt) {
              const Kn = Xe[on][Yt] + 8 * Q * 2 * pn,
                Cn = Q * 64 + (Yt & 7) * 8;
              for (let Gn = 0; Gn < gt; ++Gn) Dt.setUint16(Kn + Gn * 2 * pn, ut[on][Cn + Gn], !0);
            }
        }
      }
      for (var qt = new Uint16Array(it), Dt = new DataView(Pe.buffer), Ut = 0; Ut < U; ++Ut) {
        se[F.idx[Ut]].decoded = !0;
        var Mt = se[F.idx[Ut]].type;
        if (se[Ut].type == 2)
          for (var cn = 0; cn < Qe; ++cn) {
            const en = Xe[Ut][cn];
            for (var Wt = 0; Wt < it; ++Wt) qt[Wt] = Dt.getUint16(en + Wt * 2 * Mt, !0);
            for (var Wt = 0; Wt < it; ++Wt) Dt.setFloat32(en + Wt * 2 * Mt, ye(qt[Wt]), !0);
          }
      }
    }
    function yt(F, W, se) {
      for (var Ee, Be = 1; Be < 64; )
        (Ee = W[F.value]),
          Ee == 65280 ? (Be = 64) : Ee >> 8 == 255 ? (Be += Ee & 255) : ((se[Be] = Ee), Be++),
          F.value++;
    }
    function rt(F, W) {
      (W[0] = ye(F[0])),
        (W[1] = ye(F[1])),
        (W[2] = ye(F[5])),
        (W[3] = ye(F[6])),
        (W[4] = ye(F[14])),
        (W[5] = ye(F[15])),
        (W[6] = ye(F[27])),
        (W[7] = ye(F[28])),
        (W[8] = ye(F[2])),
        (W[9] = ye(F[4])),
        (W[10] = ye(F[7])),
        (W[11] = ye(F[13])),
        (W[12] = ye(F[16])),
        (W[13] = ye(F[26])),
        (W[14] = ye(F[29])),
        (W[15] = ye(F[42])),
        (W[16] = ye(F[3])),
        (W[17] = ye(F[8])),
        (W[18] = ye(F[12])),
        (W[19] = ye(F[17])),
        (W[20] = ye(F[25])),
        (W[21] = ye(F[30])),
        (W[22] = ye(F[41])),
        (W[23] = ye(F[43])),
        (W[24] = ye(F[9])),
        (W[25] = ye(F[11])),
        (W[26] = ye(F[18])),
        (W[27] = ye(F[24])),
        (W[28] = ye(F[31])),
        (W[29] = ye(F[40])),
        (W[30] = ye(F[44])),
        (W[31] = ye(F[53])),
        (W[32] = ye(F[10])),
        (W[33] = ye(F[19])),
        (W[34] = ye(F[23])),
        (W[35] = ye(F[32])),
        (W[36] = ye(F[39])),
        (W[37] = ye(F[45])),
        (W[38] = ye(F[52])),
        (W[39] = ye(F[54])),
        (W[40] = ye(F[20])),
        (W[41] = ye(F[22])),
        (W[42] = ye(F[33])),
        (W[43] = ye(F[38])),
        (W[44] = ye(F[46])),
        (W[45] = ye(F[51])),
        (W[46] = ye(F[55])),
        (W[47] = ye(F[60])),
        (W[48] = ye(F[21])),
        (W[49] = ye(F[34])),
        (W[50] = ye(F[37])),
        (W[51] = ye(F[47])),
        (W[52] = ye(F[50])),
        (W[53] = ye(F[56])),
        (W[54] = ye(F[59])),
        (W[55] = ye(F[61])),
        (W[56] = ye(F[35])),
        (W[57] = ye(F[36])),
        (W[58] = ye(F[48])),
        (W[59] = ye(F[49])),
        (W[60] = ye(F[57])),
        (W[61] = ye(F[58])),
        (W[62] = ye(F[62])),
        (W[63] = ye(F[63]));
    }
    function Ht(F) {
      const W = 0.5 * Math.cos(0.7853975),
        se = 0.5 * Math.cos(3.14159 / 16),
        Ee = 0.5 * Math.cos(3.14159 / 8),
        Be = 0.5 * Math.cos((3 * 3.14159) / 16),
        Pe = 0.5 * Math.cos((5 * 3.14159) / 16),
        it = 0.5 * Math.cos((3 * 3.14159) / 8),
        Qe = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var U = new Array(4), Q = new Array(4), ee = new Array(4), q = new Array(4), le = 0;
        le < 8;
        ++le
      ) {
        var Ae = le * 8;
        (U[0] = Ee * F[Ae + 2]),
          (U[1] = it * F[Ae + 2]),
          (U[2] = Ee * F[Ae + 6]),
          (U[3] = it * F[Ae + 6]),
          (Q[0] = se * F[Ae + 1] + Be * F[Ae + 3] + Pe * F[Ae + 5] + Qe * F[Ae + 7]),
          (Q[1] = Be * F[Ae + 1] - Qe * F[Ae + 3] - se * F[Ae + 5] - Pe * F[Ae + 7]),
          (Q[2] = Pe * F[Ae + 1] - se * F[Ae + 3] + Qe * F[Ae + 5] + Be * F[Ae + 7]),
          (Q[3] = Qe * F[Ae + 1] - Pe * F[Ae + 3] + Be * F[Ae + 5] - se * F[Ae + 7]),
          (ee[0] = W * (F[Ae + 0] + F[Ae + 4])),
          (ee[3] = W * (F[Ae + 0] - F[Ae + 4])),
          (ee[1] = U[0] + U[3]),
          (ee[2] = U[1] - U[2]),
          (q[0] = ee[0] + ee[1]),
          (q[1] = ee[3] + ee[2]),
          (q[2] = ee[3] - ee[2]),
          (q[3] = ee[0] - ee[1]),
          (F[Ae + 0] = q[0] + Q[0]),
          (F[Ae + 1] = q[1] + Q[1]),
          (F[Ae + 2] = q[2] + Q[2]),
          (F[Ae + 3] = q[3] + Q[3]),
          (F[Ae + 4] = q[3] - Q[3]),
          (F[Ae + 5] = q[2] - Q[2]),
          (F[Ae + 6] = q[1] - Q[1]),
          (F[Ae + 7] = q[0] - Q[0]);
      }
      for (var Fe = 0; Fe < 8; ++Fe)
        (U[0] = Ee * F[16 + Fe]),
          (U[1] = it * F[16 + Fe]),
          (U[2] = Ee * F[48 + Fe]),
          (U[3] = it * F[48 + Fe]),
          (Q[0] = se * F[8 + Fe] + Be * F[24 + Fe] + Pe * F[40 + Fe] + Qe * F[56 + Fe]),
          (Q[1] = Be * F[8 + Fe] - Qe * F[24 + Fe] - se * F[40 + Fe] - Pe * F[56 + Fe]),
          (Q[2] = Pe * F[8 + Fe] - se * F[24 + Fe] + Qe * F[40 + Fe] + Be * F[56 + Fe]),
          (Q[3] = Qe * F[8 + Fe] - Pe * F[24 + Fe] + Be * F[40 + Fe] - se * F[56 + Fe]),
          (ee[0] = W * (F[Fe] + F[32 + Fe])),
          (ee[3] = W * (F[Fe] - F[32 + Fe])),
          (ee[1] = U[0] + U[3]),
          (ee[2] = U[1] - U[2]),
          (q[0] = ee[0] + ee[1]),
          (q[1] = ee[3] + ee[2]),
          (q[2] = ee[3] - ee[2]),
          (q[3] = ee[0] - ee[1]),
          (F[0 + Fe] = q[0] + Q[0]),
          (F[8 + Fe] = q[1] + Q[1]),
          (F[16 + Fe] = q[2] + Q[2]),
          (F[24 + Fe] = q[3] + Q[3]),
          (F[32 + Fe] = q[3] - Q[3]),
          (F[40 + Fe] = q[2] - Q[2]),
          (F[48 + Fe] = q[1] - Q[1]),
          (F[56 + Fe] = q[0] - Q[0]);
    }
    function lt(F) {
      for (var W = 0; W < 64; ++W) {
        var se = F[0][W],
          Ee = F[1][W],
          Be = F[2][W];
        (F[0][W] = se + 1.5747 * Be),
          (F[1][W] = se - 0.1873 * Ee - 0.4682 * Be),
          (F[2][W] = se + 1.8556 * Ee);
      }
    }
    function K(F, W, se) {
      for (var Ee = 0; Ee < 64; ++Ee) W[se + Ee] = Gu.toHalfFloat(H(F[Ee]));
    }
    function H(F) {
      return F <= 1
        ? Math.sign(F) * Math.pow(Math.abs(F), 2.2)
        : Math.sign(F) * Math.pow(L, Math.abs(F) - 1);
    }
    function ve(F) {
      return new DataView(F.array.buffer, F.offset.value, F.size);
    }
    function Le(F) {
      var W = F.viewer.buffer.slice(F.offset.value, F.offset.value + F.size),
        se = new Uint8Array(It(W)),
        Ee = new Uint8Array(se.length);
      return ke(se), j(se, Ee), new DataView(Ee.buffer);
    }
    function We(F) {
      var W = F.array.slice(F.offset.value, F.offset.value + F.size),
        se = zm(W),
        Ee = new Uint8Array(se.length);
      return ke(se), j(se, Ee), new DataView(Ee.buffer);
    }
    function ze(F) {
      for (
        var W = F.viewer,
          se = { value: F.offset.value },
          Ee = new Uint16Array(F.width * F.scanlineBlockSize * (F.channels * F.type)),
          Be = new Uint8Array(8192),
          Pe = 0,
          it = new Array(F.channels),
          Qe = 0;
        Qe < F.channels;
        Qe++
      )
        (it[Qe] = {}),
          (it[Qe].start = Pe),
          (it[Qe].end = it[Qe].start),
          (it[Qe].nx = F.width),
          (it[Qe].ny = F.lines),
          (it[Qe].size = F.type),
          (Pe += it[Qe].nx * it[Qe].ny * it[Qe].size);
      var U = we(W, se),
        Q = we(W, se);
      if (Q >= 8192) throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';
      if (U <= Q) for (var Qe = 0; Qe < Q - U + 1; Qe++) Be[Qe + U] = re(W, se);
      var ee = new Uint16Array(65536),
        q = D(Be, ee),
        le = Rt(W, se);
      Jt(F.array, W, se, le, Ee, Pe);
      for (var Qe = 0; Qe < F.channels; ++Qe)
        for (var Ae = it[Qe], Fe = 0; Fe < it[Qe].size; ++Fe)
          Bt(Ee, Ae.start + Fe, Ae.nx, Ae.size, Ae.ny, Ae.nx * Ae.size, q);
      Ye(ee, Ee, Pe);
      for (var Ve = 0, Je = new Uint8Array(Ee.buffer.byteLength), ft = 0; ft < F.lines; ft++)
        for (var ut = 0; ut < F.channels; ut++) {
          var Ae = it[ut],
            Xe = Ae.nx * Ae.size,
            mt = new Uint8Array(Ee.buffer, Ae.end * 2, Xe * 2);
          Je.set(mt, Ve), (Ve += Xe * 2), (Ae.end += Xe);
        }
      return new DataView(Je.buffer);
    }
    function Ct(F) {
      var W = F.array.slice(F.offset.value, F.offset.value + F.size),
        se = zm(W);
      const Ee = F.lines * F.channels * F.width,
        Be = F.type == 1 ? new Uint16Array(Ee) : new Uint32Array(Ee);
      let Pe = 0,
        it = 0;
      const Qe = new Array(4);
      for (let U = 0; U < F.lines; U++)
        for (let Q = 0; Q < F.channels; Q++) {
          let ee = 0;
          switch (F.type) {
            case 1:
              (Qe[0] = Pe), (Qe[1] = Qe[0] + F.width), (Pe = Qe[1] + F.width);
              for (let q = 0; q < F.width; ++q) {
                const le = (se[Qe[0]++] << 8) | se[Qe[1]++];
                (ee += le), (Be[it] = ee), it++;
              }
              break;
            case 2:
              (Qe[0] = Pe),
                (Qe[1] = Qe[0] + F.width),
                (Qe[2] = Qe[1] + F.width),
                (Pe = Qe[2] + F.width);
              for (let q = 0; q < F.width; ++q) {
                const le = (se[Qe[0]++] << 24) | (se[Qe[1]++] << 16) | (se[Qe[2]++] << 8);
                (ee += le), (Be[it] = ee), it++;
              }
              break;
          }
        }
      return new DataView(Be.buffer);
    }
    function at(F) {
      var W = F.viewer,
        se = { value: F.offset.value },
        Ee = new Uint8Array(F.width * F.lines * (F.channels * F.type * 2)),
        Be = {
          version: Re(W, se),
          unknownUncompressedSize: Re(W, se),
          unknownCompressedSize: Re(W, se),
          acCompressedSize: Re(W, se),
          dcCompressedSize: Re(W, se),
          rleCompressedSize: Re(W, se),
          rleUncompressedSize: Re(W, se),
          rleRawSize: Re(W, se),
          totalAcUncompressedCount: Re(W, se),
          totalDcUncompressedCount: Re(W, se),
          acCompression: Re(W, se),
        };
      if (Be.version < 2)
        throw 'EXRLoader.parse: ' + Ii.compression + ' version ' + Be.version + ' is unsupported';
      for (var Pe = new Array(), it = we(W, se) - 2; it > 0; ) {
        var Qe = pt(W.buffer, se),
          U = re(W, se),
          Q = (U >> 2) & 3,
          ee = (U >> 4) - 1,
          q = new Int8Array([ee])[0],
          le = re(W, se);
        Pe.push({ name: Qe, index: q, type: le, compression: Q }), (it -= Qe.length + 3);
      }
      for (var Ae = Ii.channels, Fe = new Array(F.channels), Ve = 0; Ve < F.channels; ++Ve) {
        var Je = (Fe[Ve] = {}),
          ft = Ae[Ve];
        (Je.name = ft.name),
          (Je.compression = 0),
          (Je.decoded = !1),
          (Je.type = ft.pixelType),
          (Je.pLinear = ft.pLinear),
          (Je.width = F.width),
          (Je.height = F.lines);
      }
      for (var ut = { idx: new Array(3) }, Xe = 0; Xe < F.channels; ++Xe)
        for (var Je = Fe[Xe], Ve = 0; Ve < Pe.length; ++Ve) {
          var mt = Pe[Ve];
          Je.name == mt.name &&
            ((Je.compression = mt.compression),
            mt.index >= 0 && (ut.idx[mt.index] = Xe),
            (Je.offset = Xe));
        }
      if (Be.acCompressedSize > 0)
        switch (Be.acCompression) {
          case 0:
            var Dt = new Uint16Array(Be.totalAcUncompressedCount);
            Jt(F.array, W, se, Be.acCompressedSize, Dt, Be.totalAcUncompressedCount);
            break;
          case 1:
            var gt = F.array.slice(se.value, se.value + Be.totalAcUncompressedCount),
              qt = zm(gt),
              Dt = new Uint16Array(qt.buffer);
            se.value += Be.totalAcUncompressedCount;
            break;
        }
      if (Be.dcCompressedSize > 0) {
        var Ut = { array: F.array, offset: se, size: Be.dcCompressedSize },
          Mt = new Uint16Array(We(Ut).buffer);
        se.value += Be.dcCompressedSize;
      }
      if (Be.rleRawSize > 0) {
        var gt = F.array.slice(se.value, se.value + Be.rleCompressedSize),
          qt = zm(gt),
          cn = It(qt.buffer);
        se.value += Be.rleCompressedSize;
      }
      for (var Wt = 0, en = new Array(Fe.length), Ve = 0; Ve < en.length; ++Ve)
        en[Ve] = new Array();
      for (var Hn = 0; Hn < F.lines; ++Hn)
        for (var on = 0; on < Fe.length; ++on) en[on].push(Wt), (Wt += Fe[on].width * F.type * 2);
      qe(ut, en, Fe, Dt, Mt, Ee);
      for (var Ve = 0; Ve < Fe.length; ++Ve) {
        var Je = Fe[Ve];
        if (!Je.decoded)
          switch (Je.compression) {
            case 2:
              for (var pn = 0, Yt = 0, Hn = 0; Hn < F.lines; ++Hn) {
                for (var Kn = en[Ve][pn], Cn = 0; Cn < Je.width; ++Cn) {
                  for (var Gn = 0; Gn < 2 * Je.type; ++Gn)
                    Ee[Kn++] = cn[Yt + Gn * Je.width * Je.height];
                  Yt++;
                }
                pn++;
              }
              break;
            case 1:
            default:
              throw 'EXRLoader.parse: unsupported channel compression';
          }
      }
      return new DataView(Ee.buffer);
    }
    function pt(F, W) {
      for (var se = new Uint8Array(F), Ee = 0; se[W.value + Ee] != 0; ) Ee += 1;
      var Be = new TextDecoder().decode(se.slice(W.value, W.value + Ee));
      return (W.value = W.value + Ee + 1), Be;
    }
    function $t(F, W, se) {
      var Ee = new TextDecoder().decode(new Uint8Array(F).slice(W.value, W.value + se));
      return (W.value = W.value + se), Ee;
    }
    function Ze(F, W) {
      var se = Ft(F, W),
        Ee = Rt(F, W);
      return [se, Ee];
    }
    function wt(F, W) {
      var se = Rt(F, W),
        Ee = Rt(F, W);
      return [se, Ee];
    }
    function Ft(F, W) {
      var se = F.getInt32(W.value, !0);
      return (W.value = W.value + 4), se;
    }
    function Rt(F, W) {
      var se = F.getUint32(W.value, !0);
      return (W.value = W.value + 4), se;
    }
    function St(F, W) {
      var se = F[W.value];
      return (W.value = W.value + 1), se;
    }
    function re(F, W) {
      var se = F.getUint8(W.value);
      return (W.value = W.value + 1), se;
    }
    const Re = function (F, W) {
      let se;
      return (
        'getBigInt64' in DataView.prototype
          ? (se = Number(F.getBigInt64(W.value, !0)))
          : (se = F.getUint32(W.value + 4, !0) + Number(F.getUint32(W.value, !0) << 32)),
        (W.value += 8),
        se
      );
    };
    function tt(F, W) {
      var se = F.getFloat32(W.value, !0);
      return (W.value += 4), se;
    }
    function ne(F, W) {
      return Gu.toHalfFloat(tt(F, W));
    }
    function ye(F) {
      var W = (F & 31744) >> 10,
        se = F & 1023;
      return (
        (F >> 15 ? -1 : 1) *
        (W
          ? W === 31
            ? se
              ? NaN
              : 1 / 0
            : Math.pow(2, W - 15) * (1 + se / 1024)
          : 6103515625e-14 * (se / 1024))
      );
    }
    function we(F, W) {
      var se = F.getUint16(W.value, !0);
      return (W.value += 2), se;
    }
    function Oe(F, W) {
      return ye(we(F, W));
    }
    function vt(F, W, se, Ee) {
      for (var Be = se.value, Pe = []; se.value < Be + Ee - 1; ) {
        var it = pt(W, se),
          Qe = Ft(F, se),
          U = re(F, se);
        se.value += 3;
        var Q = Ft(F, se),
          ee = Ft(F, se);
        Pe.push({ name: it, pixelType: Qe, pLinear: U, xSampling: Q, ySampling: ee });
      }
      return (se.value += 1), Pe;
    }
    function dt(F, W) {
      var se = tt(F, W),
        Ee = tt(F, W),
        Be = tt(F, W),
        Pe = tt(F, W),
        it = tt(F, W),
        Qe = tt(F, W),
        U = tt(F, W),
        Q = tt(F, W);
      return {
        redX: se,
        redY: Ee,
        greenX: Be,
        greenY: Pe,
        blueX: it,
        blueY: Qe,
        whiteX: U,
        whiteY: Q,
      };
    }
    function Gt(F, W) {
      var se = [
          'NO_COMPRESSION',
          'RLE_COMPRESSION',
          'ZIPS_COMPRESSION',
          'ZIP_COMPRESSION',
          'PIZ_COMPRESSION',
          'PXR24_COMPRESSION',
          'B44_COMPRESSION',
          'B44A_COMPRESSION',
          'DWAA_COMPRESSION',
          'DWAB_COMPRESSION',
        ],
        Ee = re(F, W);
      return se[Ee];
    }
    function _n(F, W) {
      var se = Rt(F, W),
        Ee = Rt(F, W),
        Be = Rt(F, W),
        Pe = Rt(F, W);
      return { xMin: se, yMin: Ee, xMax: Be, yMax: Pe };
    }
    function Nn(F, W) {
      var se = ['INCREASING_Y'],
        Ee = re(F, W);
      return se[Ee];
    }
    function an(F, W) {
      var se = tt(F, W),
        Ee = tt(F, W);
      return [se, Ee];
    }
    function qn(F, W) {
      var se = tt(F, W),
        Ee = tt(F, W),
        Be = tt(F, W);
      return [se, Ee, Be];
    }
    function ni(F, W, se, Ee, Be) {
      if (Ee === 'string' || Ee === 'stringvector' || Ee === 'iccProfile') return $t(W, se, Be);
      if (Ee === 'chlist') return vt(F, W, se, Be);
      if (Ee === 'chromaticities') return dt(F, se);
      if (Ee === 'compression') return Gt(F, se);
      if (Ee === 'box2i') return _n(F, se);
      if (Ee === 'lineOrder') return Nn(F, se);
      if (Ee === 'float') return tt(F, se);
      if (Ee === 'v2f') return an(F, se);
      if (Ee === 'v3f') return qn(F, se);
      if (Ee === 'int') return Ft(F, se);
      if (Ee === 'rational') return Ze(F, se);
      if (Ee === 'timecode') return wt(F, se);
      if (Ee === 'preview') return (se.value += Be), 'skipped';
      se.value += Be;
    }
    function yo(F, W, se) {
      const Ee = {};
      if (F.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      Ee.version = F.getUint8(4);
      const Be = F.getUint8(5);
      (Ee.spec = {
        singleTile: !!(Be & 2),
        longName: !!(Be & 4),
        deepFormat: !!(Be & 8),
        multiPart: !!(Be & 16),
      }),
        (se.value = 8);
      for (var Pe = !0; Pe; ) {
        var it = pt(W, se);
        if (it == 0) Pe = !1;
        else {
          var Qe = pt(W, se),
            U = Rt(F, se),
            Q = ni(F, W, se, Qe, U);
          Q === void 0
            ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Qe}'.`)
            : (Ee[it] = Q);
        }
      }
      if (Be & -5)
        throw (
          (console.error('EXRHeader:', Ee),
          'THREE.EXRLoader: provided file is currently unsupported.')
        );
      return Ee;
    }
    function _s(F, W, se, Ee, Be) {
      const Pe = {
        size: 0,
        viewer: W,
        array: se,
        offset: Ee,
        width: F.dataWindow.xMax - F.dataWindow.xMin + 1,
        height: F.dataWindow.yMax - F.dataWindow.yMin + 1,
        channels: F.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: F.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [sh ? 'colorSpace' : 'encoding']: null,
      };
      switch (F.compression) {
        case 'NO_COMPRESSION':
          (Pe.lines = 1), (Pe.uncompress = ve);
          break;
        case 'RLE_COMPRESSION':
          (Pe.lines = 1), (Pe.uncompress = Le);
          break;
        case 'ZIPS_COMPRESSION':
          (Pe.lines = 1), (Pe.uncompress = We);
          break;
        case 'ZIP_COMPRESSION':
          (Pe.lines = 16), (Pe.uncompress = We);
          break;
        case 'PIZ_COMPRESSION':
          (Pe.lines = 32), (Pe.uncompress = ze);
          break;
        case 'PXR24_COMPRESSION':
          (Pe.lines = 16), (Pe.uncompress = Ct);
          break;
        case 'DWAA_COMPRESSION':
          (Pe.lines = 32), (Pe.uncompress = at);
          break;
        case 'DWAB_COMPRESSION':
          (Pe.lines = 256), (Pe.uncompress = at);
          break;
        default:
          throw 'EXRLoader.parse: ' + F.compression + ' is unsupported';
      }
      if (((Pe.scanlineBlockSize = Pe.lines), Pe.type == 1))
        switch (Be) {
          case fi:
            (Pe.getter = Oe), (Pe.inputSize = 2);
            break;
          case Yi:
            (Pe.getter = we), (Pe.inputSize = 2);
            break;
        }
      else if (Pe.type == 2)
        switch (Be) {
          case fi:
            (Pe.getter = tt), (Pe.inputSize = 4);
            break;
          case Yi:
            (Pe.getter = ne), (Pe.inputSize = 4);
        }
      else
        throw 'EXRLoader.parse: unsupported pixelType ' + Pe.type + ' for ' + F.compression + '.';
      Pe.blockCount = (F.dataWindow.yMax + 1) / Pe.scanlineBlockSize;
      for (var it = 0; it < Pe.blockCount; it++) Re(W, Ee);
      Pe.outputChannels = Pe.channels == 3 ? 4 : Pe.channels;
      const Qe = Pe.width * Pe.height * Pe.outputChannels;
      switch (Be) {
        case fi:
          (Pe.byteArray = new Float32Array(Qe)),
            Pe.channels < Pe.outputChannels && Pe.byteArray.fill(1, 0, Qe);
          break;
        case Yi:
          (Pe.byteArray = new Uint16Array(Qe)),
            Pe.channels < Pe.outputChannels && Pe.byteArray.fill(15360, 0, Qe);
          break;
        default:
          console.error('THREE.EXRLoader: unsupported type: ', Be);
          break;
      }
      return (
        (Pe.bytesPerLine = Pe.width * Pe.inputSize * Pe.channels),
        Pe.outputChannels == 4 ? (Pe.format = Si) : (Pe.format = Nh),
        sh ? (Pe.colorSpace = 'srgb-linear') : (Pe.encoding = 3e3),
        Pe
      );
    }
    const Zi = new DataView(e),
      Mr = new Uint8Array(e),
      Er = { value: 0 },
      Ii = yo(Zi, e, Er),
      nn = _s(Ii, Zi, Mr, Er, this.type),
      Go = { value: 0 },
      _o = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let F = 0; F < nn.height / nn.scanlineBlockSize; F++) {
      const W = Rt(Zi, Er);
      (nn.size = Rt(Zi, Er)),
        (nn.lines = W + nn.scanlineBlockSize > nn.height ? nn.height - W : nn.scanlineBlockSize);
      const Ee = nn.size < nn.lines * nn.bytesPerLine ? nn.uncompress(nn) : ve(nn);
      Er.value += nn.size;
      for (let Be = 0; Be < nn.scanlineBlockSize; Be++) {
        const Pe = Be + F * nn.scanlineBlockSize;
        if (Pe >= nn.height) break;
        for (let it = 0; it < nn.channels; it++) {
          const Qe = _o[Ii.channels[it].name];
          for (let U = 0; U < nn.width; U++) {
            Go.value = (Be * (nn.channels * nn.width) + it * nn.width + U) * nn.inputSize;
            const Q =
              (nn.height - 1 - Pe) * (nn.width * nn.outputChannels) + U * nn.outputChannels + Qe;
            nn.byteArray[Q] = nn.getter(Ee, Go);
          }
        }
      }
    }
    return {
      header: Ii,
      width: nn.width,
      height: nn.height,
      data: nn.byteArray,
      format: nn.format,
      [sh ? 'colorSpace' : 'encoding']: nn[sh ? 'colorSpace' : 'encoding'],
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, n, i) {
    function o(a, u) {
      sh ? (a.colorSpace = u.colorSpace) : (a.encoding = u.encoding),
        (a.minFilter = Fn),
        (a.magFilter = Fn),
        (a.generateMipmaps = !1),
        (a.flipY = !1),
        t && t(a, u);
    }
    return super.load(e, o, n, i);
  }
}
const ty = new WeakMap();
class GD extends lr {
  constructor(e) {
    super(e),
      (this.decoderPath = ''),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ''),
      (this.defaultAttributeIDs = {
        position: 'POSITION',
        normal: 'NORMAL',
        color: 'COLOR',
        uv: 'TEX_COORD',
      }),
      (this.defaultAttributeTypes = {
        position: 'Float32Array',
        normal: 'Float32Array',
        color: 'Float32Array',
        uv: 'Float32Array',
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, n, i) {
    const o = new ar(this.manager);
    o.setPath(this.path),
      o.setResponseType('arraybuffer'),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        (a) => {
          const u = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(a, u).then(t).catch(i);
        },
        n,
        i,
      );
  }
  decodeDracoFile(e, t, n, i) {
    const o = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
    };
    this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    for (const d in t.attributeTypes) {
      const h = t.attributeTypes[d];
      h.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[d] = h.name);
    }
    const n = JSON.stringify(t);
    if (ty.has(e)) {
      const d = ty.get(e);
      if (d.key === n) return d.promise;
      if (e.byteLength === 0)
        throw new Error(
          'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
        );
    }
    let i;
    const o = this.workerNextTaskID++,
      a = e.byteLength,
      u = this._getWorker(o, a)
        .then(
          (d) => (
            (i = d),
            new Promise((h, m) => {
              (i._callbacks[o] = { resolve: h, reject: m }),
                i.postMessage({ type: 'decode', id: o, taskConfig: t, buffer: e }, [e]);
            })
          ),
        )
        .then((d) => this._createGeometry(d.geometry));
    return (
      u
        .catch(() => !0)
        .then(() => {
          i && o && this._releaseTask(i, o);
        }),
      ty.set(e, { key: n, promise: u }),
      u
    );
  }
  _createGeometry(e) {
    const t = new hn();
    e.index && t.setIndex(new Pn(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n],
        o = i.name,
        a = i.array,
        u = i.itemSize;
      t.setAttribute(o, new Pn(a, u));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new ar(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(t),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, o) => {
        n.load(e, i, void 0, o);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e = typeof WebAssembly != 'object' || this.decoderConfig.type === 'js',
      t = [];
    return (
      e
        ? t.push(this._loadLibrary('draco_decoder.js', 'text'))
        : (t.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
          t.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
      (this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const o = VD.toString(),
          a = [
            '/* draco decoder */',
            i,
            '',
            '/* worker */',
            o.substring(o.indexOf('{') + 1, o.lastIndexOf('}')),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: 'init', decoderConfig: this.decoderConfig }),
          (i.onmessage = function (o) {
            const a = o.data;
            switch (a.type) {
              case 'decode':
                i._callbacks[a.id].resolve(a);
                break;
              case 'error':
                i._callbacks[a.id].reject(a);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"');
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, o) {
          return i._taskLoad > o._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = t), (n._taskLoad += t), n;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]), delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      'Task load: ',
      this.workerPool.map((e) => e._taskLoad),
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function VD() {
  let r, e;
  onmessage = function (a) {
    const u = a.data;
    switch (u.type) {
      case 'init':
        (r = u.decoderConfig),
          (e = new Promise(function (m) {
            (r.onModuleLoaded = function (g) {
              m({ draco: g });
            }),
              DracoDecoderModule(r);
          }));
        break;
      case 'decode':
        const d = u.buffer,
          h = u.taskConfig;
        e.then((m) => {
          const g = m.draco,
            v = new g.Decoder(),
            x = new g.DecoderBuffer();
          x.Init(new Int8Array(d), d.byteLength);
          try {
            const A = t(g, v, x, h),
              C = A.attributes.map((E) => E.array.buffer);
            A.index && C.push(A.index.array.buffer),
              self.postMessage({ type: 'decode', id: u.id, geometry: A }, C);
          } catch (A) {
            console.error(A), self.postMessage({ type: 'error', id: u.id, error: A.message });
          } finally {
            g.destroy(x), g.destroy(v);
          }
        });
        break;
    }
  };
  function t(a, u, d, h) {
    const m = h.attributeIDs,
      g = h.attributeTypes;
    let v, x;
    const A = u.GetEncodedGeometryType(d);
    if (A === a.TRIANGULAR_MESH) (v = new a.Mesh()), (x = u.DecodeBufferToMesh(d, v));
    else if (A === a.POINT_CLOUD) (v = new a.PointCloud()), (x = u.DecodeBufferToPointCloud(d, v));
    else throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
    if (!x.ok() || v.ptr === 0)
      throw new Error('THREE.DRACOLoader: Decoding failed: ' + x.error_msg());
    const C = { index: null, attributes: [] };
    for (const E in m) {
      const S = self[g[E]];
      let b, I;
      if (h.useUniqueIDs) (I = m[E]), (b = u.GetAttributeByUniqueId(v, I));
      else {
        if (((I = u.GetAttributeId(v, a[m[E]])), I === -1)) continue;
        b = u.GetAttribute(v, I);
      }
      C.attributes.push(i(a, u, v, E, S, b));
    }
    return A === a.TRIANGULAR_MESH && (C.index = n(a, u, v)), a.destroy(v), C;
  }
  function n(a, u, d) {
    const m = d.num_faces() * 3,
      g = m * 4,
      v = a._malloc(g);
    u.GetTrianglesUInt32Array(d, g, v);
    const x = new Uint32Array(a.HEAPF32.buffer, v, m).slice();
    return a._free(v), { array: x, itemSize: 1 };
  }
  function i(a, u, d, h, m, g) {
    const v = g.num_components(),
      A = d.num_points() * v,
      C = A * m.BYTES_PER_ELEMENT,
      E = o(a, m),
      S = a._malloc(C);
    u.GetAttributeDataArrayForAllPoints(d, g, E, C, S);
    const b = new m(a.HEAPF32.buffer, S, A).slice();
    return a._free(S), { name: h, array: b, itemSize: v };
  }
  function o(a, u) {
    switch (u) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
let Gm;
const ny = () => {
    if (Gm) return Gm;
    const r =
        'B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB',
      e =
        'B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB',
      t = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10,
        22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      n = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64,
        19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132,
        17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167,
      ]);
    if (typeof WebAssembly != 'object') return { supported: !1 };
    let i = r;
    WebAssembly.validate(t) && (i = e);
    let o;
    const a = WebAssembly.instantiate(u(i), {}).then((g) => {
      (o = g.instance), o.exports.__wasm_call_ctors();
    });
    function u(g) {
      const v = new Uint8Array(g.length);
      for (let A = 0; A < g.length; ++A) {
        const C = g.charCodeAt(A);
        v[A] = C > 96 ? C - 71 : C > 64 ? C - 65 : C > 47 ? C + 4 : C > 46 ? 63 : 62;
      }
      let x = 0;
      for (let A = 0; A < g.length; ++A) v[x++] = v[A] < 60 ? n[v[A]] : (v[A] - 60) * 64 + v[++A];
      return v.buffer.slice(0, x);
    }
    function d(g, v, x, A, C, E) {
      const S = o.exports.sbrk,
        b = (x + 3) & -4,
        I = S(b * A),
        B = S(C.length),
        z = new Uint8Array(o.exports.memory.buffer);
      z.set(C, B);
      const N = g(I, x, A, B, C.length);
      if ((N === 0 && E && E(I, b, A), v.set(z.subarray(I, I + x * A)), S(I - S(0)), N !== 0))
        throw new Error(`Malformed buffer data: ${N}`);
    }
    const h = {
        0: '',
        1: 'meshopt_decodeFilterOct',
        2: 'meshopt_decodeFilterQuat',
        3: 'meshopt_decodeFilterExp',
        NONE: '',
        OCTAHEDRAL: 'meshopt_decodeFilterOct',
        QUATERNION: 'meshopt_decodeFilterQuat',
        EXPONENTIAL: 'meshopt_decodeFilterExp',
      },
      m = {
        0: 'meshopt_decodeVertexBuffer',
        1: 'meshopt_decodeIndexBuffer',
        2: 'meshopt_decodeIndexSequence',
        ATTRIBUTES: 'meshopt_decodeVertexBuffer',
        TRIANGLES: 'meshopt_decodeIndexBuffer',
        INDICES: 'meshopt_decodeIndexSequence',
      };
    return (
      (Gm = {
        ready: a,
        supported: !0,
        decodeVertexBuffer(g, v, x, A, C) {
          d(o.exports.meshopt_decodeVertexBuffer, g, v, x, A, o.exports[h[C]]);
        },
        decodeIndexBuffer(g, v, x, A) {
          d(o.exports.meshopt_decodeIndexBuffer, g, v, x, A);
        },
        decodeIndexSequence(g, v, x, A) {
          d(o.exports.meshopt_decodeIndexSequence, g, v, x, A);
        },
        decodeGltfBuffer(g, v, x, A, C, E) {
          d(o.exports[m[C]], g, v, x, A, o.exports[h[E]]);
        },
      }),
      Gm
    );
  },
  iy = (r) => r === Object(r) && !Array.isArray(r) && typeof r != 'function';
function w_(r, e) {
  const t = $r((o) => o.gl),
    n = Fs(Zh, iy(r) ? Object.values(r) : r);
  return (
    je.useLayoutEffect(() => {
      e == null || e(n);
    }, [e]),
    je.useEffect(() => {
      if ('initTexture' in t) {
        let o = [];
        Array.isArray(n) ? (o = n) : n instanceof Ln ? (o = [n]) : iy(n) && (o = Object.values(n)),
          o.forEach((a) => {
            a instanceof Ln && t.initTexture(a);
          });
      }
    }, [t, n]),
    je.useMemo(() => {
      if (iy(r)) {
        const o = {};
        let a = 0;
        for (const u in r) o[u] = n[a++];
        return o;
      } else return n;
    }, [r, n])
  );
}
w_.preload = (r) => Fs.preload(Zh, r);
w_.clear = (r) => Fs.clear(Zh, r);
let Vm = null,
  QE = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';
function qE(r = !0, e = !0, t) {
  return (n) => {
    t && t(n),
      r &&
        (Vm || (Vm = new GD()),
        Vm.setDecoderPath(typeof r == 'string' ? r : QE),
        n.setDRACOLoader(Vm)),
      e && n.setMeshoptDecoder(typeof ny == 'function' ? ny() : ny);
  };
}
const $h = (r, e, t, n) => Fs(E_, r, qE(e, t, n));
$h.preload = (r, e, t, n) => Fs.preload(E_, r, qE(e, t, n));
$h.clear = (r) => Fs.clear(E_, r);
$h.setDecoderPath = (r) => {
  QE = r;
};
const WD = je.forwardRef(
    (
      {
        makeDefault: r,
        camera: e,
        regress: t,
        domElement: n,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: a,
        onStart: u,
        onEnd: d,
        ...h
      },
      m,
    ) => {
      const g = $r((N) => N.invalidate),
        v = $r((N) => N.camera),
        x = $r((N) => N.gl),
        A = $r((N) => N.events),
        C = $r((N) => N.setEvents),
        E = $r((N) => N.set),
        S = $r((N) => N.get),
        b = $r((N) => N.performance),
        I = e || v,
        B = n || A.connected || x.domElement,
        z = je.useMemo(() => new rD(I), [I]);
      return (
        NE(() => {
          z.enabled && z.update();
        }, -1),
        je.useEffect(
          () => (o && z.connect(o === !0 ? B : o), z.connect(B), () => void z.dispose()),
          [o, B, t, z, g],
        ),
        je.useEffect(() => {
          const N = (L) => {
              g(), t && b.regress(), a && a(L);
            },
            G = (L) => {
              u && u(L);
            },
            k = (L) => {
              d && d(L);
            };
          return (
            z.addEventListener('change', N),
            z.addEventListener('start', G),
            z.addEventListener('end', k),
            () => {
              z.removeEventListener('start', G),
                z.removeEventListener('end', k),
                z.removeEventListener('change', N);
            }
          );
        }, [a, u, d, z, g, C]),
        je.useEffect(() => {
          if (r) {
            const N = S().controls;
            return E({ controls: z }), () => E({ controls: N });
          }
        }, [r, z]),
        je.createElement('primitive', Lg({ ref: m, object: z, enableDamping: i }, h))
      );
    },
  ),
  XD = 3e3,
  JD = 3001,
  $E = (r, e, t) => {
    let n;
    switch (r) {
      case ns:
        n = new Uint8ClampedArray(e * t * 4);
        break;
      case Yi:
        n = new Uint16Array(e * t * 4);
        break;
      case ko:
        n = new Uint32Array(e * t * 4);
        break;
      case kg:
        n = new Int8Array(e * t * 4);
        break;
      case zg:
        n = new Int16Array(e * t * 4);
        break;
      case Fh:
        n = new Int32Array(e * t * 4);
        break;
      case fi:
        n = new Float32Array(e * t * 4);
        break;
      default:
        throw new Error('Unsupported data type');
    }
    return n;
  };
let Wm;
const YD = (r, e, t, n) => {
  if (Wm !== void 0) return Wm;
  const i = new Ls(1, 1, n);
  e.setRenderTarget(i);
  const o = new oi(new Pl(), new ts({ color: 16777215 }));
  e.render(o, t), e.setRenderTarget(null);
  const a = $E(r, i.width, i.height);
  return (
    e.readRenderTargetPixels(i, 0, 0, i.width, i.height, a),
    i.dispose(),
    o.geometry.dispose(),
    o.material.dispose(),
    (Wm = a[0] !== 0),
    Wm
  );
};
class C_ {
  constructor(e) {
    var t, n, i, o, a, u, d, h, m, g, v, x, A, C, E, S;
    (this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (I) {
          throw (this._renderer.setRenderTarget(null), I);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace);
    const b = {
      format: Si,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0 ? void 0 : t.anisotropy) !== void 0
          ? (n = e.renderTargetOptions) === null || n === void 0
            ? void 0
            : n.anisotropy
          : 1,
      generateMipmaps:
        ((i = e.renderTargetOptions) === null || i === void 0 ? void 0 : i.generateMipmaps) !==
        void 0
          ? (o = e.renderTargetOptions) === null || o === void 0
            ? void 0
            : o.generateMipmaps
          : !1,
      magFilter:
        ((a = e.renderTargetOptions) === null || a === void 0 ? void 0 : a.magFilter) !== void 0
          ? (u = e.renderTargetOptions) === null || u === void 0
            ? void 0
            : u.magFilter
          : Fn,
      minFilter:
        ((d = e.renderTargetOptions) === null || d === void 0 ? void 0 : d.minFilter) !== void 0
          ? (h = e.renderTargetOptions) === null || h === void 0
            ? void 0
            : h.minFilter
          : Fn,
      samples:
        ((m = e.renderTargetOptions) === null || m === void 0 ? void 0 : m.samples) !== void 0
          ? (g = e.renderTargetOptions) === null || g === void 0
            ? void 0
            : g.samples
          : void 0,
      wrapS:
        ((v = e.renderTargetOptions) === null || v === void 0 ? void 0 : v.wrapS) !== void 0
          ? (x = e.renderTargetOptions) === null || x === void 0
            ? void 0
            : x.wrapS
          : Ai,
      wrapT:
        ((A = e.renderTargetOptions) === null || A === void 0 ? void 0 : A.wrapT) !== void 0
          ? (C = e.renderTargetOptions) === null || C === void 0
            ? void 0
            : C.wrapT
          : Ai,
    };
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = C_.instantiateRenderer()), (this._rendererIsDisposable = !0)),
      (this._scene = new Hh()),
      (this._camera = new No()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !YD(this._type, this._renderer, this._camera, b))
    ) {
      let I;
      switch (this._type) {
        case Yi:
          I = this._renderer.extensions.has('EXT_color_buffer_float') ? fi : void 0;
          break;
      }
      I !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${fi}`,
          ),
          (this._type = I))
        : ((this._supportsReadPixels = !1),
          console.warn(
            'This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown',
          ));
    }
    (this._quad = new oi(new Pl(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new Ls(this.width, this.height, b)),
      (this._renderTarget.texture.mapping =
        ((E = e.renderTargetOptions) === null || E === void 0 ? void 0 : E.mapping) !== void 0
          ? (S = e.renderTargetOptions) === null || S === void 0
            ? void 0
            : S.mapping
          : Cl);
  }
  static instantiateRenderer() {
    const e = new y_();
    return e.setSize(128, 128), e;
  }
  toArray() {
    if (!this._supportsReadPixels) throw new Error("Can't read pixels in this browser");
    const e = $E(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, e),
      e
    );
  }
  toDataTexture(e) {
    const t = new po(
      this.toArray(),
      this.width,
      this.height,
      Si,
      this._type,
      (e == null ? void 0 : e.mapping) || Cl,
      (e == null ? void 0 : e.wrapS) || Ai,
      (e == null ? void 0 : e.wrapT) || Ai,
      (e == null ? void 0 : e.magFilter) || Fn,
      (e == null ? void 0 : e.minFilter) || Fn,
      (e == null ? void 0 : e.anisotropy) || 1,
      zo,
    );
    return (
      (t.generateMipmaps =
        (e == null ? void 0 : e.generateMipmaps) !== void 0
          ? e == null
            ? void 0
            : e.generateMipmaps
          : !1),
      t
    );
  }
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null),
      this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  dispose(e) {
    this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof is &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Ln && t.value.dispose();
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Ln && t.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose();
  }
  get width() {
    return this._width;
  }
  set width(e) {
    (this._width = e), this._renderTarget.setSize(this._width, this._height);
  }
  get height() {
    return this._height;
  }
  set height(e) {
    (this._height = e), this._renderTarget.setSize(this._width, this._height);
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    (this._renderTarget = e), (this._width = e.width), (this._height = e.height);
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const KD = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  jD = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class ZD extends is {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: n,
    gainMapMin: i,
    gainMapMax: o,
    maxDisplayBoost: a,
    hdrCapacityMin: u,
    hdrCapacityMax: d,
    sdr: h,
    gainMap: m,
  }) {
    super({
      name: 'GainMapDecoderMaterial',
      vertexShader: KD,
      fragmentShader: jD,
      uniforms: {
        sdr: { value: h },
        gainMap: { value: m },
        gamma: { value: new J(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new J().fromArray(t) },
        offsetSdr: { value: new J().fromArray(n) },
        gainMapMin: { value: new J().fromArray(i) },
        gainMapMax: { value: new J().fromArray(o) },
        weightFactor: { value: (Math.log2(a) - u) / (d - u) },
      },
      blending: Do,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = a),
      (this._hdrCapacityMin = u),
      (this._hdrCapacityMax = d),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0);
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    (t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2]);
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    (this._hdrCapacityMin = e), this.calculateWeight();
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    (this._hdrCapacityMax = e), this.calculateWeight();
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    (this._maxDisplayBoost = Math.max(1, Math.min(65504, e))), this.calculateWeight();
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class e1 extends Error {}
class t1 extends Error {}
const oh = (r, e, t) => {
    const n = new RegExp(`${e}="([^"]*)"`, 'i').exec(r);
    if (n) return n[1];
    const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, 'i').exec(r);
    if (i) {
      const o = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return o && o.length === 3 ? o.map((a) => a.replace(/<\/?rdf:li>/g, '')) : i[1].trim();
    }
    if (t !== void 0) return t;
    throw new Error(`Can't find ${e} in gainmap metadata`);
  },
  QD = (r) => {
    let e;
    typeof TextDecoder < 'u' ? (e = new TextDecoder().decode(r)) : (e = r.toString());
    let t = e.indexOf('<x:xmpmeta');
    for (; t !== -1; ) {
      const n = e.indexOf('x:xmpmeta>', t),
        i = e.slice(t, n + 10);
      try {
        const o = oh(i, 'hdrgm:GainMapMin', '0'),
          a = oh(i, 'hdrgm:GainMapMax'),
          u = oh(i, 'hdrgm:Gamma', '1'),
          d = oh(i, 'hdrgm:OffsetSDR', '0.015625'),
          h = oh(i, 'hdrgm:OffsetHDR', '0.015625'),
          m = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),
          g = m ? m[1] : '0',
          v = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);
        if (!v) throw new Error('Incomplete gainmap metadata');
        const x = v[1];
        return {
          gainMapMin: Array.isArray(o)
            ? o.map((A) => parseFloat(A))
            : [parseFloat(o), parseFloat(o), parseFloat(o)],
          gainMapMax: Array.isArray(a)
            ? a.map((A) => parseFloat(A))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          gamma: Array.isArray(u)
            ? u.map((A) => parseFloat(A))
            : [parseFloat(u), parseFloat(u), parseFloat(u)],
          offsetSdr: Array.isArray(d)
            ? d.map((A) => parseFloat(A))
            : [parseFloat(d), parseFloat(d), parseFloat(d)],
          offsetHdr: Array.isArray(h)
            ? h.map((A) => parseFloat(A))
            : [parseFloat(h), parseFloat(h), parseFloat(h)],
          hdrCapacityMin: parseFloat(g),
          hdrCapacityMax: parseFloat(x),
        };
      } catch {}
      t = e.indexOf('<x:xmpmeta', n);
    }
  };
class qD {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    };
  }
  extract(e) {
    return new Promise((t, n) => {
      const i = this.options.debug,
        o = new DataView(e.buffer);
      if (o.getUint16(0) !== 65496) {
        n(new Error('Not a valid jpeg'));
        return;
      }
      const a = o.byteLength;
      let u = 2,
        d = 0,
        h;
      for (; u < a; ) {
        if (++d > 250) {
          n(new Error(`Found no marker after ${d} loops `));
          return;
        }
        if (o.getUint8(u) !== 255) {
          n(
            new Error(
              `Not a valid marker at offset 0x${u.toString(16)}, found: 0x${o
                .getUint8(u)
                .toString(16)}`,
            ),
          );
          return;
        }
        if (((h = o.getUint8(u + 1)), i && console.log(`Marker: ${h.toString(16)}`), h === 226)) {
          i && console.log('Found APP2 marker (0xffe2)');
          const m = u + 4;
          if (o.getUint32(m) === 1297106432) {
            const g = m + 4;
            let v;
            if (o.getUint16(g) === 18761) v = !1;
            else if (o.getUint16(g) === 19789) v = !0;
            else {
              n(new Error('No valid endianness marker found in TIFF header'));
              return;
            }
            if (o.getUint16(g + 2, !v) !== 42) {
              n(new Error('Not valid TIFF data! (no 0x002A marker)'));
              return;
            }
            const x = o.getUint32(g + 4, !v);
            if (x < 8) {
              n(new Error('Not valid TIFF data! (First offset less than 8)'));
              return;
            }
            const A = g + x,
              C = o.getUint16(A, !v),
              E = A + 2;
            let S = 0;
            for (let z = E; z < E + 12 * C; z += 12)
              o.getUint16(z, !v) === 45057 && (S = o.getUint32(z + 8, !v));
            const I = A + 2 + C * 12 + 4,
              B = [];
            for (let z = I; z < I + S * 16; z += 16) {
              const N = {
                MPType: o.getUint32(z, !v),
                size: o.getUint32(z + 4, !v),
                dataOffset: o.getUint32(z + 8, !v),
                dependantImages: o.getUint32(z + 12, !v),
                start: -1,
                end: -1,
                isFII: !1,
              };
              N.dataOffset
                ? ((N.start = g + N.dataOffset), (N.isFII = !1))
                : ((N.start = 0), (N.isFII = !0)),
                (N.end = N.start + N.size),
                B.push(N);
            }
            if (this.options.extractNonFII && B.length) {
              const z = new Blob([o]),
                N = [];
              for (const G of B) {
                if (G.isFII && !this.options.extractFII) continue;
                const k = z.slice(G.start, G.end + 1, 'image/jpeg');
                N.push(k);
              }
              t(N);
            }
          }
        }
        u += 2 + o.getUint16(u + 2);
      }
    });
  }
}
const $D = async (r) => {
    const e = QD(r);
    if (!e) throw new t1('Gain map XMP metadata not found');
    const n = await new qD({ extractFII: !0, extractNonFII: !0 }).extract(r);
    if (n.length !== 2) throw new e1('Gain map recovery image not found');
    return {
      sdr: new Uint8Array(await n[0].arrayBuffer()),
      gainMap: new Uint8Array(await n[1].arrayBuffer()),
      metadata: e,
    };
  },
  TS = (r) =>
    new Promise((e, t) => {
      const n = document.createElement('img');
      (n.onload = () => {
        e(n);
      }),
        (n.onerror = (i) => {
          t(i);
        }),
        (n.src = URL.createObjectURL(r));
    });
class n1 extends lr {
  constructor(e, t) {
    super(t), e && (this._renderer = e), (this._internalLoadingManager = new dv());
  }
  setRenderer(e) {
    return (this._renderer = e), this;
  }
  setRenderTargetOptions(e) {
    return (this._renderTargetOptions = e), this;
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        'WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.',
      );
    const e = new ZD({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Ln(),
      sdr: new Ln(),
    });
    return new C_({
      width: 16,
      height: 16,
      type: Yi,
      colorSpace: zo,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(e, t, n, i) {
    const o = i ? new Blob([i], { type: 'image/jpeg' }) : void 0,
      a = new Blob([n], { type: 'image/jpeg' });
    let u,
      d,
      h = !1;
    if (typeof createImageBitmap > 'u') {
      const v = await Promise.all([o ? TS(o) : Promise.resolve(void 0), TS(a)]);
      (d = v[0]), (u = v[1]), (h = !0);
    } else {
      const v = await Promise.all([
        o ? createImageBitmap(o, { imageOrientation: 'flipY' }) : Promise.resolve(void 0),
        createImageBitmap(a, { imageOrientation: 'flipY' }),
      ]);
      (d = v[0]), (u = v[1]);
    }
    const m = new Ln(d || new ImageData(2, 2), Cl, Ai, Ai, Fn, uy, Si, ns, 1, zo);
    (m.flipY = h), (m.needsUpdate = !0);
    const g = new Ln(u, Cl, Ai, Ai, Fn, uy, Si, ns, 1, xr);
    (g.flipY = h),
      (g.needsUpdate = !0),
      (e.width = u.width),
      (e.height = u.height),
      (e.material.gainMap = m),
      (e.material.sdr = g),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render();
  }
}
class eL extends n1 {
  load([e, t, n], i, o, a) {
    const u = this.prepareQuadRenderer();
    let d, h, m;
    const g = async () => {
      if (d && h && m) {
        try {
          await this.render(u, m, d, h);
        } catch (L) {
          this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(n),
            typeof a == 'function' && a(L),
            u.disposeOnDemandRenderer();
          return;
        }
        typeof i == 'function' && i(u),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(n),
          u.disposeOnDemandRenderer();
      }
    };
    let v = !0,
      x = 0,
      A = 0,
      C = !0,
      E = 0,
      S = 0,
      b = !0,
      I = 0,
      B = 0;
    const z = () => {
      if (typeof o == 'function') {
        const L = x + E + I,
          D = A + S + B,
          V = v && C && b;
        o(new ProgressEvent('progress', { lengthComputable: V, loaded: D, total: L }));
      }
    };
    this.manager.itemStart(e), this.manager.itemStart(t), this.manager.itemStart(n);
    const N = new ar(this._internalLoadingManager);
    N.setResponseType('arraybuffer'),
      N.setRequestHeader(this.requestHeader),
      N.setPath(this.path),
      N.setWithCredentials(this.withCredentials),
      N.load(
        e,
        async (L) => {
          if (typeof L == 'string') throw new Error('Invalid sdr buffer');
          (d = L), await g();
        },
        (L) => {
          (v = L.lengthComputable), (A = L.loaded), (x = L.total), z();
        },
        (L) => {
          this.manager.itemError(e), typeof a == 'function' && a(L);
        },
      );
    const G = new ar(this._internalLoadingManager);
    G.setResponseType('arraybuffer'),
      G.setRequestHeader(this.requestHeader),
      G.setPath(this.path),
      G.setWithCredentials(this.withCredentials),
      G.load(
        t,
        async (L) => {
          if (typeof L == 'string') throw new Error('Invalid gainmap buffer');
          (h = L), await g();
        },
        (L) => {
          (C = L.lengthComputable), (S = L.loaded), (E = L.total), z();
        },
        (L) => {
          this.manager.itemError(t), typeof a == 'function' && a(L);
        },
      );
    const k = new ar(this._internalLoadingManager);
    return (
      k.setRequestHeader(this.requestHeader),
      k.setPath(this.path),
      k.setWithCredentials(this.withCredentials),
      k.load(
        n,
        async (L) => {
          if (typeof L != 'string') throw new Error('Invalid metadata string');
          (m = JSON.parse(L)), await g();
        },
        (L) => {
          (b = L.lengthComputable), (B = L.loaded), (I = L.total), z();
        },
        (L) => {
          this.manager.itemError(n), typeof a == 'function' && a(L);
        },
      ),
      u
    );
  }
}
class tL extends n1 {
  load(e, t, n, i) {
    const o = this.prepareQuadRenderer(),
      a = new ar(this._internalLoadingManager);
    return (
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      a.load(
        e,
        async (u) => {
          if (typeof u == 'string')
            throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');
          const d = new Uint8Array(u);
          let h, m, g;
          try {
            const v = await $D(d);
            (h = v.sdr), (m = v.gainMap), (g = v.metadata);
          } catch (v) {
            if (v instanceof t1 || v instanceof e1)
              console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`,
              ),
                (g = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (h = d);
            else throw v;
          }
          try {
            await this.render(o, g, h, m);
          } catch (v) {
            this.manager.itemError(e), typeof i == 'function' && i(v), o.disposeOnDemandRenderer();
            return;
          }
          typeof t == 'function' && t(o), this.manager.itemEnd(e), o.disposeOnDemandRenderer();
        },
        n,
        (u) => {
          this.manager.itemError(e), typeof i == 'function' && i(u);
        },
      ),
      o
    );
  }
}
const Ph = {
    apartment: 'lebombo_1k.hdr',
    city: 'potsdamer_platz_1k.hdr',
    dawn: 'kiara_1_dawn_1k.hdr',
    forest: 'forest_slope_1k.hdr',
    lobby: 'st_fagans_interior_1k.hdr',
    night: 'dikhololo_night_1k.hdr',
    park: 'rooitou_park_1k.hdr',
    studio: 'studio_small_03_1k.hdr',
    sunset: 'venice_sunset_1k.hdr',
    warehouse: 'empty_warehouse_01_1k.hdr',
  },
  i1 = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/',
  Ff = (r) => Array.isArray(r),
  T_ = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'];
function mv({
  files: r = T_,
  path: e = '',
  preset: t = void 0,
  encoding: n = void 0,
  extensions: i,
} = {}) {
  let o = null,
    a = !1;
  t && (R_(t), (r = Ph[t]), (e = i1)), (a = Ff(r));
  const { extension: u, isCubemap: d } = b_(r);
  if (((o = I_(u)), !o)) throw new Error('useEnvironment: Unrecognized file extension: ' + r);
  const h = $r((x) => x.gl);
  je.useLayoutEffect(() => {
    if (u !== 'webp' && u !== 'jpg' && u !== 'jpeg') return;
    function x() {
      Fs.clear(o, a ? [r] : r);
    }
    h.domElement.addEventListener('webglcontextlost', x, { once: !0 });
  }, [r, h.domElement]);
  const m = Fs(o, a ? [r] : r, (x) => {
    (u === 'webp' || u === 'jpg' || u === 'jpeg') && x.setRenderer(h),
      x.setPath == null || x.setPath(e),
      i && i(x);
  });
  let g = a ? m[0] : m;
  if (u === 'jpg' || u === 'jpeg' || u === 'webp') {
    var v;
    g = (v = g.renderTarget) == null ? void 0 : v.texture;
  }
  return (
    (g.mapping = d ? Oo : Nf),
    'colorSpace' in g
      ? (g.colorSpace = n ?? d ? 'srgb' : 'srgb-linear')
      : (g.encoding = n ?? d ? JD : XD),
    g
  );
}
const nL = { files: T_, path: '', preset: void 0, extensions: void 0 };
mv.preload = (r) => {
  const e = { ...nL, ...r };
  let { files: t, path: n = '' } = e;
  const { preset: i, extensions: o } = e;
  i && (R_(i), (t = Ph[i]), (n = i1));
  const { extension: a } = b_(t);
  if (a === 'webp' || a === 'jpg' || a === 'jpeg')
    throw new Error('useEnvironment: Preloading gainmaps is not supported');
  const u = I_(a);
  if (!u) throw new Error('useEnvironment: Unrecognized file extension: ' + t);
  Fs.preload(u, Ff(t) ? [t] : t, (d) => {
    d.setPath == null || d.setPath(n), o && o(d);
  });
};
const iL = { files: T_, preset: void 0 };
mv.clear = (r) => {
  const e = { ...iL, ...r };
  let { files: t } = e;
  const { preset: n } = e;
  n && (R_(n), (t = Ph[n]));
  const { extension: i } = b_(t),
    o = I_(i);
  if (!o) throw new Error('useEnvironment: Unrecognized file extension: ' + t);
  Fs.clear(o, Ff(t) ? [t] : t);
};
function R_(r) {
  if (!(r in Ph)) throw new Error('Preset must be one of: ' + Object.keys(Ph).join(', '));
}
function b_(r) {
  var e;
  const t = Ff(r) && r.length === 6,
    n = Ff(r) && r.length === 3 && r.some((a) => a.endsWith('json')),
    i = Ff(r) ? r[0] : r;
  return {
    extension: t
      ? 'cube'
      : n
      ? 'webp'
      : i.startsWith('data:application/exr')
      ? 'exr'
      : i.startsWith('data:application/hdr')
      ? 'hdr'
      : i.startsWith('data:image/jpeg')
      ? 'jpg'
      : (e = i.split('.').pop()) == null || (e = e.split('?')) == null || (e = e.shift()) == null
      ? void 0
      : e.toLowerCase(),
    isCubemap: t,
    isGainmap: n,
  };
}
function I_(r) {
  return r === 'cube'
    ? tE
    : r === 'hdr'
    ? zD
    : r === 'exr'
    ? HD
    : r === 'jpg' || r === 'jpeg'
    ? tL
    : r === 'webp'
    ? eL
    : null;
}
const rL = (r) => r.current && r.current.isScene,
  sL = (r) => (rL(r) ? r.current : r);
function B_(r, e, t, n, i = {}) {
  var o, a, u, d;
  i = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...i,
  };
  const h = sL(e || t),
    m = h.background,
    g = h.environment,
    v = {
      backgroundBlurriness: h.backgroundBlurriness,
      backgroundIntensity: h.backgroundIntensity,
      backgroundRotation:
        (o = (a = h.backgroundRotation) == null || a.clone == null ? void 0 : a.clone()) !== null &&
        o !== void 0
          ? o
          : [0, 0, 0],
      environmentIntensity: h.environmentIntensity,
      environmentRotation:
        (u = (d = h.environmentRotation) == null || d.clone == null ? void 0 : d.clone()) !==
          null && u !== void 0
          ? u
          : [0, 0, 0],
    };
  return (
    r !== 'only' && (h.environment = n),
    r && (h.background = n),
    Sl(h, i),
    () => {
      r !== 'only' && (h.environment = g), r && (h.background = m), Sl(h, v);
    }
  );
}
function P_({ scene: r, background: e = !1, map: t, ...n }) {
  const i = $r((o) => o.scene);
  return (
    je.useLayoutEffect(() => {
      if (t) return B_(e, r, i, t, n);
    }),
    null
  );
}
function r1({
  background: r = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: n,
  backgroundIntensity: i,
  backgroundRotation: o,
  environmentIntensity: a,
  environmentRotation: u,
  ...d
}) {
  const h = mv(d),
    m = $r((g) => g.scene);
  return (
    je.useLayoutEffect(() =>
      B_(r, e, m, h, {
        backgroundBlurriness: t ?? n,
        backgroundIntensity: i,
        backgroundRotation: o,
        environmentIntensity: a,
        environmentRotation: u,
      }),
    ),
    je.useEffect(
      () => () => {
        h.dispose();
      },
      [h],
    ),
    null
  );
}
function oL({
  children: r,
  near: e = 0.1,
  far: t = 1e3,
  resolution: n = 256,
  frames: i = 1,
  map: o,
  background: a = !1,
  blur: u,
  backgroundBlurriness: d,
  backgroundIntensity: h,
  backgroundRotation: m,
  environmentIntensity: g,
  environmentRotation: v,
  scene: x,
  files: A,
  path: C,
  preset: E = void 0,
  extensions: S,
}) {
  const b = $r((k) => k.gl),
    I = $r((k) => k.scene),
    B = je.useRef(null),
    [z] = je.useState(() => new Hh()),
    N = je.useMemo(() => {
      const k = new Hy(n);
      return (k.texture.type = Yi), k;
    }, [n]);
  je.useEffect(
    () => () => {
      N.dispose();
    },
    [N],
  ),
    je.useLayoutEffect(() => {
      if (i === 1) {
        const k = b.autoClear;
        (b.autoClear = !0), B.current.update(b, z), (b.autoClear = k);
      }
      return B_(a, x, I, N.texture, {
        backgroundBlurriness: u ?? d,
        backgroundIntensity: h,
        backgroundRotation: m,
        environmentIntensity: g,
        environmentRotation: v,
      });
    }, [r, z, N.texture, x, I, a, i, b]);
  let G = 1;
  return (
    NE(() => {
      if (i === 1 / 0 || G < i) {
        const k = b.autoClear;
        (b.autoClear = !0), B.current.update(b, z), (b.autoClear = k), G++;
      }
    }),
    je.createElement(
      je.Fragment,
      null,
      v2(
        je.createElement(
          je.Fragment,
          null,
          r,
          je.createElement('cubeCamera', { ref: B, args: [e, t, N] }),
          A || E
            ? je.createElement(r1, { background: !0, files: A, preset: E, path: C, extensions: S })
            : o
            ? je.createElement(P_, { background: !0, map: o, extensions: S })
            : null,
        ),
        z,
      ),
    )
  );
}
function aL(r) {
  var e, t, n, i;
  const o = mv(r),
    a = r.map || o;
  je.useMemo(() => wE({ GroundProjectedEnvImpl: Z2 }), []),
    je.useEffect(
      () => () => {
        o.dispose();
      },
      [o],
    );
  const u = je.useMemo(() => [a], [a]),
    d = (e = r.ground) == null ? void 0 : e.height,
    h = (t = r.ground) == null ? void 0 : t.radius,
    m = (n = (i = r.ground) == null ? void 0 : i.scale) !== null && n !== void 0 ? n : 1e3;
  return je.createElement(
    je.Fragment,
    null,
    je.createElement(P_, Lg({}, r, { map: a })),
    je.createElement('groundProjectedEnvImpl', { args: u, scale: m, height: d, radius: h }),
  );
}
function lL(r) {
  return r.ground
    ? je.createElement(aL, r)
    : r.map
    ? je.createElement(P_, r)
    : r.children
    ? je.createElement(oL, r)
    : je.createElement(r1, r);
}
const uL = ({ textureUrl: r, color: e }) => {
  var o;
  const { nodes: t, materials: n } = $h('react-app/models/julia.gltf'),
    i = r ? w_(r) : null;
  return (
    i && ((i.rotation = Math.PI), (i.center = new Ge(0.5, 0.5)), (i.encoding = xr)),
    e &&
      (n['Plastic - Translucent Matte (Yellow)'] &&
        n['Plastic - Translucent Matte (Yellow)'].color.set(e),
      n['Tough 2000 (with Formlabs SLA 3D Printers)'] &&
        n['Tough 2000 (with Formlabs SLA 3D Printers)'].color.set(e)),
    Vt.jsxs('group', {
      dispose: null,
      scale: 35,
      position: [0, 0, 0],
      children: [
        Vt.jsxs('group', {
          rotation: [Math.PI / 2, 0, 0],
          scale: 0.001,
          children: [
            Vt.jsx('mesh', {
              geometry: t.IEM1.geometry,
              material: n['Plastic - Translucent Matte (Yellow)'],
              scale: 10,
            }),
            Vt.jsx('mesh', {
              geometry: t['IEM1-cap'].geometry,
              material: n['Tough 2000 (with Formlabs SLA 3D Printers)'],
              scale: 10,
            }),
          ],
        }),
        Vt.jsx('mesh', {
          geometry: t.mimipaulaaaaaa.geometry,
          position: [-0.005, 0.017, 0.018],
          children: Vt.jsx('meshStandardMaterial', {
            map: i,
            color: 'white',
            transparent: !!((o = i == null ? void 0 : i.image) != null && o.data),
            alphaTest: 0.5,
            side: gs,
          }),
        }),
      ],
    })
  );
};
$h.preload('react-app/models/julia.gltf');
const cL = ({ onImageUpload: r, onColorChange: e, selectedImage: t, selectedColor: n }) => {
  const [i, o] = je.useState(t || null),
    [a, u] = je.useState(n || '#ffffff');
  je.useEffect(() => {
    o(t);
  }, [t]),
    je.useEffect(() => {
      u(n);
    }, [n]);
  const d = (g) => {
      const v = g.target.files[0];
      if (v && v.type.startsWith('image/')) {
        const x = new FileReader();
        (x.onload = (A) => {
          const C = A.target.result;
          console.log('Uploaded image URL:', C), r(C), o(C);
        }),
          (x.onerror = () => console.error('Error reading file.')),
          x.readAsDataURL(v);
      } else alert('Please upload a valid image file.');
    },
    h = () => {
      window.confirm('Are you sure you want to remove the current design?') &&
        (r(null), e('#ffffff'), o(null), u('#ffffff'));
    },
    m = async () => {
      if (!i && a === '#ffffff') {
        alert('No changes to save. Please select a design or color.');
        return;
      }
      if (window.confirm('Are you sure you want to save this design?'))
        try {
          const g = { color: a, image: i };
          console.log('Sending design data to backend:', g);
          const v = await fetch('http://localhost:8080/api/save-design', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(g),
          });
          if (v.ok) {
            const x = await v.json();
            console.log('Backend response:', x), alert(x.message || 'Design saved successfully!');
          } else {
            const x = await v.json();
            console.error('Backend error:', x), alert(x.message || 'Failed to save the design.');
          }
        } catch (g) {
          console.error('Error saving design:', g),
            alert('An error occurred while saving the design.');
        }
    };
  return Vt.jsxs('div', {
    className: 'design-panel',
    style: { padding: '10px', border: '1px solid #ccc', borderRadius: '5px' },
    children: [
      Vt.jsx('h3', { children: 'Customize Earphone' }),
      Vt.jsxs('div', {
        className: 'color-picker',
        style: { marginBottom: '10px' },
        children: [
          Vt.jsx('label', { htmlFor: 'color', children: 'Pick a Color:' }),
          Vt.jsx('input', {
            type: 'color',
            id: 'color',
            value: a,
            onChange: (g) => {
              const v = g.target.value;
              console.log('Changing color to:', v), e(v), u(v);
            },
          }),
        ],
      }),
      Vt.jsxs('div', {
        className: 'image-upload',
        style: { marginBottom: '10px' },
        children: [
          Vt.jsx('label', { htmlFor: 'upload', children: 'Upload Design:' }),
          Vt.jsx('input', { type: 'file', id: 'upload', accept: 'image/*', onChange: d }),
          i &&
            Vt.jsx('div', {
              className: 'uploaded-image',
              style: { marginTop: '10px' },
              children: Vt.jsx('img', {
                src: i,
                alt: 'Selected Design',
                style: { maxWidth: '100px', maxHeight: '100px', borderRadius: '5px' },
              }),
            }),
        ],
      }),
      Vt.jsxs('div', {
        className: 'buttons',
        style: { display: 'flex', gap: '10px' },
        children: [
          Vt.jsx('button', { onClick: m, children: 'Save' }),
          Vt.jsx('button', { onClick: h, children: 'Remove' }),
        ],
      }),
    ],
  });
};
function fL() {
  const [r, e] = je.useState(null),
    [t, n] = je.useState('#ffffff'),
    i = (o) => {
      console.log('Reserved image clicked:', o), e(o);
    };
  return (
    je.useEffect(() => {
      console.log('Selected Image Updated:', r);
    }, [r]),
    Vt.jsx('div', {
      className: 'App',
      children: Vt.jsxs('div', {
        className: 'container',
        children: [
          Vt.jsxs('div', {
            className: 'left-container',
            style: { width: '100%', height: '100vh' },
            children: [
              Vt.jsx('div', {
                className: 'left-top',
                style: { width: '100%', height: '80%' },
                children: Vt.jsxs(F2, {
                  camera: { position: [0, 0, 50], fov: 50 },
                  children: [
                    Vt.jsx('ambientLight', { intensity: 0.6 }),
                    ' ',
                    Vt.jsx('hemisphereLight', {
                      skyColor: '#ffffff',
                      groundColor: '#444444',
                      intensity: 0.8,
                    }),
                    ' ',
                    Vt.jsx('directionalLight', {
                      position: [10, 10, 10],
                      intensity: 1,
                      castShadow: !0,
                    }),
                    ' ',
                    Vt.jsx('directionalLight', { position: [-10, -10, -10], intensity: 0.5 }),
                    ' ',
                    Vt.jsx('color', { attach: 'background', args: ['#222222'] }),
                    ' ',
                    Vt.jsx(lL, { preset: 'city' }),
                    Vt.jsx('group', {
                      scale: 35,
                      position: [5, -15, 0],
                      children: Vt.jsx(uL, { textureUrl: r, color: t }),
                    }),
                    Vt.jsx(WD, {
                      enableZoom: !1,
                      rotateSpeed: 0.5,
                      minPolarAngle: Math.PI / 4,
                      maxPolarAngle: Math.PI,
                      enablePan: !1,
                    }),
                  ],
                }),
              }),
              Vt.jsxs('div', {
                className: 'left-bottom',
                style: { width: '100%', height: '20%' },
                children: [
                  Vt.jsx('h3', { children: 'Reserved Designs' }),
                  Vt.jsx('div', {
                    className: 'design-thumbnails',
                    children: [
                      'react-app/design/dinoo.png',
                      'react-app/design/dragon.png',
                      'react-app/design/lion.png',
                    ].map((o, a) =>
                      Vt.jsx(
                        'img',
                        {
                          src: o,
                          alt: `Design ${a + 1}`,
                          onClick: () => i(o),
                          style: { cursor: 'pointer', width: '50px', height: '50px' },
                        },
                        a,
                      ),
                    ),
                  }),
                ],
              }),
            ],
          }),
          Vt.jsx('div', {
            className: 'right-container',
            style: { width: '30%', height: '100vh' },
            children: Vt.jsx(cL, {
              onImageUpload: e,
              onColorChange: n,
              selectedImage: r,
              selectedColor: t,
            }),
          }),
        ],
      }),
    })
  );
}
U1.createRoot(document.getElementById('root')).render(
  Vt.jsx(je.StrictMode, { children: Vt.jsx(fL, {}) }),
);
